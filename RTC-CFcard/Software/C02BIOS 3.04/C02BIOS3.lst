  Tue May 18 2021 22:26                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;**************************************************************************************************
     2                        ;*  C02BIOS 3.04 (c)2013-2021 by Kevin E. Maier   *     New Hardware design with the following:   *
     3                        ;* - BIOS in pages $F8-$FF, less I/O in page $FE  *  - W65C02 with clock rate up to 6.0 MHz       *
     4                        ;* - Full duplex interrupt-driven/buffered I/O    *  - AS6C66256 32KB Static RAM                  *
     5                        ;* - Extendable BIOS structure with soft vectors  *  - AT28H256 32KB EEPROM ROM                   *
     6                        ;* - Soft config parameters for I/O devices       *  - ATF22V10CQZ Single Glue Logic              *
     7                        ;* - Monitor cold/warm start soft vectored        *  - NXP SCC2691 UART for console/timer         *
     8                        ;* - Fully relocatable code (sans page $FF)       *  - Hardware map is flexible via Glue logic    *
     9                        ;* - Precision timer services w/10ms accuracy     *  - 5 I/O selects @ 32-bytes wide              *
    10                        ;* - RTC based Jiffy Clock, Sec, Min, Hour, Days  *  - 4 I/O selects available on expansion bus   *
    11                        ;* - Accurate delays from 10ms to ~497 days       *  - 1 I/O select used by SCC2691 UART          *
    12                        ;* - 10ms Benchmark Timing to 65535.99 seconds    *     Additional Hardware via Adapter Card      *
    13                        ;*                                                *  - Compact Flash True IDE mode interface      *
    14                        ;*                                                *    - 16-bit upper latch for data read/write   *
    15                        ;*                                                *  - DS1511Y Realtime Clock/Calendar            *
    16                        ;*                                                *                                               *
    17                        ;*                                                *   Note: default HW system memory map as       *
    18                        ;*  Uses <2KB EEPROM - JMP table page at $FF00    *         RAM - $0000 - $7FFF                   *
    19                        ;*    Uses 160 bytes for I/O: starts at $FE00     *         ROM - $8000 - $FDFF                   *
    20                        ;*        Default assembly starts at $F800:       *         I/O - $FE00 - $FE9F                   *
    21                        ;*          14/05/2021 (Day/Month/Year)           *         ROM - $FEA0 - $FFFF                   *
    22                        ;**************************************************************************************************
    23                                PL      66      ;Page Length
    24                                PW      132     ;Page Width (# of char/line)
    25                                CHIP    W65C02S ;Enable WDC 65C02 instructions
    26                                PASS1   OFF     ;Set ON when used for debug
    27                                INCLIST ON      ;Set ON for listing Include files
    28                        ;**************************************************************************************************
    29                        ;
    30                        ; C02BIOS Version 3.04 has some minor bug fixes for RTC and IDE routines, plus some cleanup.
    31                        ; C02BIOS Version 3.03 makes a major change in LBA Read and Write routines!
    32                        ; - To ensure compatibility with previously formatted IDE devices, the Byte swapping of high/low
    33                        ; - per word transfer has been eliminated. It's important to note that the Identity Command
    34                        ; - will provide data where the byte swapping needs to be done, otherwise it doesn't match up
    35                        ; - per the SanDisk documentation.
    36                        ;
    37                        ; This BIOS and Monitor version also use a common source file for constants and variables used by
    38                        ; both. This just simplifies keeping both code pieces in sync.
    39                        ;
    40                                INCLUDE         C02Constants3.asm
     1                        ;**************************************************************************************************
     2                        ;*                                                                                                *
     3                        ;*              C02 Constants used for the 3.xx releases of C02BIOS3 and C02Monitor3              *
     4                        ;*                                                                                                *
     5                        ;*                                                                                                *
     6                        ;*                                  14/05/2021 (Day/Month/Year)                                   *
     7                        ;*                                                                                                *
     8                        ;**************************************************************************************************
     9                        ; C02BIOS / C02Monitor Version is now 3.04                                                        *
    10                        ; - All Constants and Variables are now defined in a single source file (this one) for assembling *
    11                        ; - both the C02BIOS3 and the C02Monitor3. It is also used for the Template for writing code to   *
    12                        ; - be used for the C02 Pocket SBC and Adapters.                                                  *
    13                        ;                                                                                                 *
    14                        ; - Be sure to include this file at the start of any source file that needs it.                   *
    15                        ;                                                                                                 *
    16                        ;**************************************************************************************************
    17                        ;
  Tue May 18 2021 22:26                                                                                                    Page 2


    18                        ;       - Page Zero definitions ($00 to $9F reserved for user routines)
    19             000000A0   PGZERO_ST       .EQU    $A0                     ;Start of Page Zero usage for C02 Monitor
    20                        ;
    21             000000A0   BUFF_PG0        .EQU    PGZERO_ST+00            ;Default Page zero location for Monitor buffers
    22                        ;
    23             000000A0   INBUFF          .EQU    BUFF_PG0+00             ;Input Buffer - 4 bytes ($A0-$A3)
    24             000000A4   DATABUFF        .EQU    BUFF_PG0+04             ;Data Buffer - 6 bytes ($A4-$A9)
    25                        ;
    26                        ;       - 16-bit variables:
    27             000000AA   HEXDATAH        .EQU    PGZERO_ST+10            ;Hexadecimal input
    28             000000AB   HEXDATAL        .EQU    PGZERO_ST+11
    29             000000AC   BINVALL         .EQU    PGZERO_ST+12            ;Binary Value for HEX2ASC
    30             000000AD   BINVALH         .EQU    PGZERO_ST+13
    31             000000AE   COMLO           .EQU    PGZERO_ST+14            ;User command address
    32             000000AF   COMHI           .EQU    PGZERO_ST+15
    33             000000B0   INDEXL          .EQU    PGZERO_ST+16            ;Index for address - multiple routines
    34             000000B1   INDEXH          .EQU    PGZERO_ST+17
    35             000000B2   TEMP1L          .EQU    PGZERO_ST+18            ;Index for word temp value used by Memdump
    36             000000B3   TEMP1H          .EQU    PGZERO_ST+19
    37             000000B4   TEMP2L          .EQU    PGZERO_ST+20            ;Index for Text entry
    38             000000B5   TEMP2H          .EQU    PGZERO_ST+21
    39             000000B6   PROMPTL         .EQU    PGZERO_ST+22            ;Prompt string address
    40             000000B7   PROMPTH         .EQU    PGZERO_ST+23
    41             000000B8   SRCL            .EQU    PGZERO_ST+24            ;Source address for memory operations
    42             000000B9   SRCH            .EQU    PGZERO_ST+25
    43             000000BA   TGTL            .EQU    PGZERO_ST+26            ;Target address for memory operations
    44             000000BB   TGTH            .EQU    PGZERO_ST+27
    45             000000BC   LENL            .EQU    PGZERO_ST+28            ;Length address for memory operations
    46             000000BD   LENH            .EQU    PGZERO_ST+29
    47                        ;
    48                        ;       - 8-bit variables and constants:
    49             000000BE   BUFIDX          .EQU    PGZERO_ST+30            ;Buffer index
    50             000000BF   BUFLEN          .EQU    PGZERO_ST+31            ;Buffer length
    51             000000C0   IDX             .EQU    PGZERO_ST+32            ;Temp Indexing
    52             000000C1   IDY             .EQU    PGZERO_ST+33            ;Temp Indexing
    53             000000C2   TEMP1           .EQU    PGZERO_ST+34            ;Temp - Code Conversion routines
    54             000000C3   TEMP2           .EQU    PGZERO_ST+35            ;Temp - Memory/EEPROM/SREC routines - Disassembler
    55             000000C4   TEMP3           .EQU    PGZERO_ST+36            ;Temp - EEPROM/SREC routines
    56             000000C5   CMDFLAG         .EQU    PGZERO_ST+37            ;Command Flag, bit specific, used by many routines
    57             000000C6   OPXMDM          .EQU    PGZERO_ST+38            ;Saved Opcode/Xmodem Flag variable
    58                        ;
    59                        ;       - Xmodem transfer variables
    60             000000C7   CRCHI           .EQU    PGZERO_ST+39            ;CRC hi byte  (two byte variable)
    61             000000C8   CRCLO           .EQU    PGZERO_ST+40            ;CRC lo byte - Operand in Disassembler
    62             000000C9   CRCCNT          .EQU    PGZERO_ST+41            ;CRC retry count - Operand in Disassembler
    63             000000CA   PTRL            .EQU    PGZERO_ST+42            ;Data pointer lo byte - Mnemonic in Disassembler
    64             000000CB   PTRH            .EQU    PGZERO_ST+43            ;Data pointer hi byte - Mnemonic in Disassembler
    65             000000CC   BLKNO           .EQU    PGZERO_ST+44            ;Block number
    66                        ;
    67                        ;        - Macro Loop Counter variables
    68             000000CD   LPCNTL          .EQU    PGZERO_ST+45            ;Loop Count low byte
    69             000000CE   LPCNTH          .EQU    PGZERO_ST+46            ;Loop Count high byte
    70                        ;
    71                        ;       - Spare Monitor byte for future use
    72             000000CF   SPARE_M0        .EQU    PGZERO_ST+47            ;Spare Monitor page zero byte
    73                        ;
    74             000000D0   IDE_STATUS_RAM  .EQU    PGZERO_ST+48            ;IDE RAM-Based Status
    75                        ;
    76             000000D1   IDE_LBA0        .EQU    PGZERO_ST+49            ;IDE LBA Variables for DOS/65
    77             000000D2   IDE_LBA1        .EQU    PGZERO_ST+50
    78             000000D3   IDE_LBA2        .EQU    PGZERO_ST+51
    79                        ;
    80                        ;       - BIOS variables, pointers, flags located at top of Page Zero
  Tue May 18 2021 22:26                                                                                                    Page 3


    81             000000D8   BIOS_PG0        .EQU    PGZERO_ST+56            ;Start of BIOS page 0 use ($D8-$FF, 40 bytes total)
    82                        ;
    83                        ;       - BRK handler routine
    84             000000D8   PCL             .EQU    BIOS_PG0+00             ;Program Counter Low index
    85             000000D9   PCH             .EQU    BIOS_PG0+01             ;Program Counter High index
    86             000000DA   PREG            .EQU    BIOS_PG0+02             ;Temp Status Reg
    87             000000DB   SREG            .EQU    BIOS_PG0+03             ;Temp Stack ptr
    88             000000DC   YREG            .EQU    BIOS_PG0+04             ;Temp Y Reg
    89             000000DD   XREG            .EQU    BIOS_PG0+05             ;Temp X Reg
    90             000000DE   AREG            .EQU    BIOS_PG0+06             ;Temp A Reg
    91                        ;
    92                        ;       - 2691 IRQ handler pointers and status
    93             000000DF   ICNT            .EQU    BIOS_PG0+07             ;Input buffer count
    94             000000E0   IHEAD           .EQU    BIOS_PG0+08             ;Input buffer head pointer
    95             000000E1   ITAIL           .EQU    BIOS_PG0+09             ;Input buffer tail pointer
    96             000000E2   OCNT            .EQU    BIOS_PG0+10             ;Output buffer count
    97             000000E3   OHEAD           .EQU    BIOS_PG0+11             ;Output buffer head pointer
    98             000000E4   OTAIL           .EQU    BIOS_PG0+12             ;Output buffer tail pointer
    99             000000E5   UART_IRT        .EQU    BIOS_PG0+13             ;2691 Interrupt Status byte
   100             000000E6   UART_SRT        .EQU    BIOS_PG0+14             ;2691 Status Register byte
   101                        ;
   102                        ;       - Real-Time Clock variables
   103                        ; These are repurposed for adding a Realtime clock chip DS1511Y
   104                        ; The Ticks, Seconds, Minutes and Hours remain the same in function.
   105                        ; The 16-bit Days variable is replaced however.
   106                        ; - The DAY_DATE is a new variable. To minimize Page Zero usage, it has two functions
   107                        ;       Bits 0-4 represent the days of the Month 1-31
   108                        ;       Bits 5-7 represent the Day of the Week, 1-7 (Saturday=1)
   109                        ; The Months are handled by the upper 4 bits of the MONTH_YEAR variable
   110                        ; The Century is handled by a the Year (0-255) and the lower 4 bits of the MONTH_YEAR variable
   111             000000E7   TICKS           .EQU    BIOS_PG0+15             ;Number of timer countdowns = 1 second (100)
   112             000000E8   SECS            .EQU    BIOS_PG0+16             ;Seconds: 0-59
   113             000000E9   MINS            .EQU    BIOS_PG0+17             ;Minutes: 0-59
   114             000000EA   HOURS           .EQU    BIOS_PG0+18             ;Hours: 0-23
   115             000000EB   DAY_DATE        .EQU    BIOS_PG0+19             ;Day: (bits 5-7) Date: (bits 0-4)
   116             000000EC   MONTH_CENTURY   .EQU    BIOS_PG0+20             ;Month: (bits 4-7) Century: (bits 0-3)
   117             000000ED   YEAR            .EQU    BIOS_PG0+21             ;Century 0-255 plus 4 bits as noted above
   118             000000EE   RTC_TEMP        .EQU    BIOS_PG0+22             ;Temp work byte for updating shared variables
   119                        ;
   120                        ;       - Delay Timer variables
   121             000000EF   MSDELAY         .EQU    BIOS_PG0+23             ;Timer delay countdown byte (255 > 0)
   122             000000F0   SETMS           .EQU    BIOS_PG0+24             ;Set timeout for delay routines - BIOS use only
   123             000000F1   DELLO           .EQU    BIOS_PG0+25             ;Delay value BIOS use only
   124             000000F2   DELHI           .EQU    BIOS_PG0+26             ;Delay value BIOS use only
   125             000000F3   XDL             .EQU    BIOS_PG0+27             ;XL Delay count
   126                        ;
   127                        ;       - Count variables for 10ms benchmark timing
   128             000000F4   MS10_CNT        .EQU    BIOS_PG0+28             ;10ms Count variable
   129             000000F5   SECL_CNT        .EQU    BIOS_PG0+29             ;Seconds Low byte count
   130             000000F6   SECH_CNT        .EQU    BIOS_PG0+30             ;Second High byte count
   131                        ;
   132                        ;       - Adddress and pointers for CF-Card IDE Interface
   133             000000F7   LBA_ADDR_LOW    .EQU    BIOS_PG0+31             ;LBA Transfer Address low byte
   134             000000F8   LBA_ADDR_HIGH   .EQU    BIOS_PG0+32             ;LBA Transfer Address high byte
   135             000000F9   LBA_XFER_CNT    .EQU    BIOS_PG0+33             ;LBA Transfer Count
   136                        
   137             000000FA   LBA_LOW_BYTE    .EQU    BIOS_PG0+34             ;LBA Block number 0-7
   138             000000FB   LBA_HIGH_BYTE   .EQU    BIOS_PG0+35             ;LBA Block number 8-15
   139             000000FC   LBA_EXT_BYTE    .EQU    BIOS_PG0+36             ;LBA Block number 16-23
   140                        ;
   141             000000FD   BIOS_XFERL      .EQU    BIOS_PG0+37             ;BIOS Move Routine low byte
   142             000000FE   BIOS_XFERH      .EQU    BIOS_PG0+38             ;BIOS Move Routine high byte
   143                        ;
  Tue May 18 2021 22:26                                                                                                    Page 4


   144                        ;       - Timer/Counter Match flag for Delay/Benchmark
   145             000000FF   MATCH           .EQU    BIOS_PG0+39             ;Bit7 used for Delay, Bit6 used for Benchmark
   146                                                                        ;Bits 5,4 used for BRG Test register status
   147                                                                        ;Bits 3,2,1 used for CF Card Interrupt Handler
   148                        ;
   149                        ;       - Default for RTC tick count - number of IRQs for 1 second
   150             00000064   DF_TICKS        .EQU    100                     ;Timer is 10 milliseconds (100 x 10ms = 1 second)
   151                        ;
   152                        ;**************************************************************************************************
   153             00000200   IBUF            .EQU    $0200                   ;Console Input Buffer - 128 bytes
   154             00000280   OBUF            .EQU    $0280                   ;Console Output Buffer - 128 bytes
   155                        ;**************************************************************************************************
   156             00000300   SOFTVEC         .EQU    $0300                   ;Start of soft vectors
   157                        ;The Interrupt structure is vector based. During startup, Page $03 is loaded from ROM.
   158                        ; The soft vectors are structured to allow inserting additional routines either before
   159                        ; or after the ROM based routines. This allows flexibility and changing of routine priority.
   160                        ;
   161                        ;The main set of vectors occupy the first 16 bytes of Page $03. The ROM handler for
   162                        ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
   163                        ; return addresses to the ROM handler for each. The following 2 vectors are the cold and
   164                        ; warm entry points for the Monitor. After the basic initialization, the monitor is entered.
   165                        ;
   166                        ;The following vector set allows inserts, pre or post for NMI/BRK/IRQ. There a total of 8 inserts
   167                        ; which occupy 16 bytes. They can be used as required.
   168                        ; Currently, VECINSRT0 will be used if a CF-Card IDE Controller is detected.
   169                        ;
   170             00000300   NMIVEC0         .EQU    SOFTVEC+00              ;NMI Vector Entry 0
   171             00000302   BRKVEC0         .EQU    SOFTVEC+02              ;BRK Vector Entry 0
   172             00000304   IRQVEC0         .EQU    SOFTVEC+04              ;IRQ Vector Entry 0
   173                        ;
   174             00000306   NMIRTVEC0       .EQU    SOFTVEC+06              ;NMI Vector Return 0
   175             00000308   BRKRTVEC0       .EQU    SOFTVEC+08              ;BRK Vector Return 0
   176             0000030A   IRQRTVEC0       .EQU    SOFTVEC+10              ;IRQ Vector Return 0
   177                        ;
   178             0000030C   CLDMNVEC0       .EQU    SOFTVEC+12              ;Monitor Cold Entry Vector 0
   179             0000030E   WRMMNVEC0       .EQU    SOFTVEC+14              ;Monitor Warm Entry Vector 0
   180                        ;
   181             00000310   VECINSRT0       .EQU    SOFTVEC+16              ;1st Vector Insert
   182             00000312   VECINSRT1       .EQU    SOFTVEC+18              ;2nd Vector Insert
   183             00000314   VECINSRT2       .EQU    SOFTVEC+20              ;3rd Vector Insert
   184             00000316   VECINSRT3       .EQU    SOFTVEC+22              ;4th Vector Insert
   185             00000318   VECINSRT4       .EQU    SOFTVEC+24              ;5th Vector Insert
   186             0000031A   VECINSRT5       .EQU    SOFTVEC+26              ;6th Vector Insert
   187             0000031C   VECINSRT6       .EQU    SOFTVEC+28              ;7th Vector Insert
   188             0000031E   VECINSRT7       .EQU    SOFTVEC+30              ;8th Vector Insert
   189                        ;
   190                        ;**************************************************************************************************
   191             00000320   SOFTCFG         .EQU    SOFTVEC+32              ;Start of hardware config parameters
   192                        ;Soft Config values below are loaded from ROM and are the default I/O setup configuration data that
   193                        ; the INIT_x routines use. As a result, you can write a routine to change the I/O configuration
   194                        ; data and use the standard ROM routines to initialize the I/O without restarting or changing ROM
   195                        ; A Reset (HW or coded) will reinitialize the I/O with the ROM default I/O configuration.
   196                        ;
   197                        ;There are a total of 32 Bytes configuration data reserved starting at $0320
   198                        ;
   199             00000320   LOAD_2691       .EQU    SOFTCFG+00              ;SCC2691 Soft Config Data
   200                        ;
   201             00000330   LOAD_IDE        .EQU    SOFTCFG+16              ;IDE/CF-Card Soft Config Data
   202                        ;
   203                        ;Search Buffer is 16 bytes in length. Used to hold search string for text or hex data
   204             00000340   SRCHBUFF        .EQU    SOFTCFG+32              ;Located in Page $03 following Hardware config data
   205                        ;
   206                        ;Xmodem/CRC Loader also provides Motorola S19 Record sense and load. Designed to handle the S19
  Tue May 18 2021 22:26                                                                                                    Page 5


   207                        ; records from the WDC Assembler/Linker package. This requires a 44 byte buffer to parse each valid
   208                        ; S1 record, located just before the 132 Byte Xmodem frame buffer. Total Buffer space for the
   209                        ; Xmodem/CRC Loader is 176 bytes
   210                        ;
   211                        ;Valid S-record headers are "S1" and "S9". For S1, the maximum length is "$19" hex. The last S1
   212                        ; record can be less. S9 record is always the last record with no data. WDC Linker also appends
   213                        ; a CR/LF to the end of each record for a total of 44 bytes.
   214             00000350   SRBUFF          .EQU    SOFTCFG+48              ;S-Record buffer, up to 44 bytes in length
   215                        ;
   216                        ;Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked for proper header
   217                        ; and frame number, CRC-16 on the data, then moved to user RAM.
   218             0000037C   RBUFF           .EQU    SOFTCFG+92              ;Xmodem temp 132 byte receive buffer
   219                        ;
   220                        ;Page $03 is completely allocated for Buffers, Config Data and Vector pointers.
   221                        ; Some of the buffer space can be used as needed, provided any required Monitor functions are NOT
   222                        ; being used concurrently.
   223                        ;
   224                        ;Page $04 is Reserved for a second UART Receive/Transmit buffer (future SC28L92)
   225             00000400   IBUF2           .EQU    $0400                   ;Alternate Input Buffer - 128 bytes
   226             00000480   OBUF2           .EQU    $0480                   ;Alternate Output Buffer - 128 bytes
   227                        ;
   228                        ;Page $05 is used for the Realtime Clock NVRAM read and write routines
   229             00000500   NVRAM_DATA      .EQU    $0500                   ;NVRAM Data Buffer address
   230                        ;
   231                        ;Pages $06 - $07 are used for the IDE device Block Buffer (512 bytes)
   232             00000600   LBA_BUFFER      .EQU    $0600                   ;Default IDE Block Buffer address
   233                        ; 
   234                        ;XMODEM Control Character Constants
   235             00000001   SOH             .EQU    $01                     ;Start of Block Header
   236             00000004   EOT             .EQU    $04                     ;End of Text marker
   237             00000006   ACK             .EQU    $06                     ;Good Block Acknowledge
   238             00000015   NAK             .EQU    $15                     ;Bad Block acknowledged
   239             00000018   CAN             .EQU    $18                     ;Cancel character
   240                        ;
   241                        ;**************************************************************************************************
   242                        ;RAM location used for the EEPROM Byte Write routine
   243                        ; Note: location moved from $00 to $88 to avoid conflict with EhBasic Page 0 usage
   244                        ;
   245             00000088   BURN_BYTE       .EQU    $0088                   ;Page 0 RAM for EEPROM BYTE write routine
   246                        ;**************************************************************************************************
   247                        ;EnHanced Basic or DOS/65 can be called from the Monitor via the Ctrl-B comand.
   248                        ; The default is different for each of these optional software components.
   249                        ;
   250                        ;The start location is just added here for convienience, but should be changed as needed.
   251                        ;
   252             0000B000   EH_BASIC        .EQU    $B000                   ;Default location for EnHanced BASIC (optional)
   253             0000D680   DOS_65          .EQU    $D680                   ;Default location to Boot DOS/65 (optional)
   254                        ;**************************************************************************************************
   255             0000FE00   IOPAGE          .EQU    $FE00                   ;I/O Page Base Start Address
   256                        ;**************************************************************************************************
   257             0000FE80   SCC2691_BASE    .EQU    IOPAGE+$80              ;Beginning of Console UART address
   258                        ;
   259             0000FE80   UART_MODEREG    .EQU    SCC2691_BASE+$00        ;MR1/MR2 same address, sequential read/write
   260             0000FE81   UART_STATUS     .EQU    SCC2691_BASE+$01        ;UART Status Register (READ)
   261             0000FE81   UART_CLKSEL     .EQU    SCC2691_BASE+$01        ;UART Clock Select Register (WRITE)
   262             0000FE82   UART_BRGTST     .EQU    SCC2691_BASE+$02        ;UART BRG Test Register (READ)
   263             0000FE82   UART_COMMAND    .EQU    SCC2691_BASE+$02        ;UART Command Register (WRITE)
   264             0000FE83   UART_RECEIVE    .EQU    SCC2691_BASE+$03        ;UART Receive Register (READ)
   265             0000FE83   UART_TRANSMIT   .EQU    SCC2691_BASE+$03        ;UART Transmit Register (WRITE)
   266             0000FE84   UART_CLKTEST    .EQU    SCC2691_BASE+$04        ;X1/X16 Test Register (READ)
   267             0000FE84   UART_AUXCR      .EQU    SCC2691_BASE+$04        ;Aux Command Register (WRITE)
   268             0000FE85   UART_ISR        .EQU    SCC2691_BASE+$05        ;Interrupt Status Register (READ)
   269             0000FE85   UART_IMR        .EQU    SCC2691_BASE+$05        ;Interrupt Mask Register (WRITE)
  Tue May 18 2021 22:26                                                                                                    Page 6


   270             0000FE86   UART_CNTU       .EQU    SCC2691_BASE+$06        ;Counter/Timer Upper Register (READ)
   271             0000FE86   UART_CNTUP      .EQU    SCC2691_BASE+$06        ;Counter/Timer Upper Preset Register (WRITE)
   272             0000FE87   UART_CNTL       .EQU    SCC2691_BASE+$07        ;Counter/Timer Lower Register (READ)
   273             0000FE87   UART_CNTLP      .EQU    SCC2691_BASE+$07        ;Counter/Timer Lower Preset Register (WRITE)
   274                        ;
   275                        ;Additional Hardware
   276                        ; Adding BIOS definitions for Realtime Clock chip - DS1511Y
   277                        ; uses the first 16 addresses for RTC registers and basic operation
   278                        ; uses two addresses for extended RAM of 256 bytes
   279                        ;
   280                        ; upper addresses are used for a 16-bit IDE interface (below)
   281                        ; NOTE: offset $11 and $12 are unused (reserved per the datasheet).
   282                        ;
   283             0000FE60   RTC_IDE_BASE    .EQU    IOPAGE+$60              ;Beginning of Realtime Clock address
   284                        ;
   285             0000FE60   RTC_SECONDS     .EQU    RTC_IDE_BASE+$00        ;Seconds in BCD 00-59
   286             0000FE61   RTC_MINUTES     .EQU    RTC_IDE_BASE+$01        ;Minutes in BCD 00-59
   287             0000FE62   RTC_HOURS       .EQU    RTC_IDE_BASE+$02        ;Hours in BCD 00-23
   288             0000FE63   RTC_DAY         .EQU    RTC_IDE_BASE+$03        ;Day in BCD 1-7
   289             0000FE64   RTC_DATE        .EQU    RTC_IDE_BASE+$04        ;Date in BCD 1-31
   290             0000FE65   RTC_MONTH       .EQU    RTC_IDE_BASE+$05        ;Month in BCD 1-12
   291             0000FE66   RTC_YEAR        .EQU    RTC_IDE_BASE+$06        ;Year in BCD 00-99
   292             0000FE67   RTC_CENTURY     .EQU    RTC_IDE_BASE+$07        ;Century in BCD 00-39
   293             0000FE68   RTC_ALARM_SEC   .EQU    RTC_IDE_BASE+$08        ;Alarm Seconds in BCD 00-59
   294             0000FE69   RTC_ALARM_MIN   .EQU    RTC_IDE_BASE+$09        ;Alarm Minutes in BCD 00-59
   295             0000FE6A   RTC_ALARM_HRS   .EQU    RTC_IDE_BASE+$0A        ;Alarm Hours in BCD 00-23
   296             0000FE6B   RTC_ALARM_DYDT  .EQU    RTC_IDE_BASE+$0B        ;Alarm Day/Date in BCD 0-7 1-31
   297             0000FE6C   RTC_WTCHDOG_01  .EQU    RTC_IDE_BASE+$0C        ;Watchdog 0.1 / 0.01 Seconds in BCD 00-99
   298             0000FE6D   RTC_WTCHDOG_10  .EQU    RTC_IDE_BASE+$0D        ;Watchdog 10 / 1 Seconds in BCD 00-99
   299             0000FE6E   RTC_CONTROL_A   .EQU    RTC_IDE_BASE+$0E        ;Control A
   300             0000FE6F   RTC_CONTROL_B   .EQU    RTC_IDE_BASE+$0F        ;Control B
   301             0000FE70   RTC_RAM_ADDR    .EQU    RTC_IDE_BASE+$10        ;Extended RAM address
   302             0000FE73   RTC_RAM_DATA    .EQU    RTC_IDE_BASE+$13        ;Extended RAM data
   303                        ;
   304                        ; Adding BIOS definitions for 16-bit IDE interface
   305                        ; uses two addresses for Upper Byte Latch read / write
   306                        ; uses eight addresses for Command Block Registers
   307                        ; uses two addresses for Control Block Registers
   308                        ;
   309             0000FE74   IDE_16_READ     .EQU    RTC_IDE_BASE+$14        ;Upper byte Read address
   310             0000FE75   IDE_16_WRITE    .EQU    RTC_IDE_BASE+$15        ;Upper byte Write address
   311                        ;
   312                        ; Adding BIOS definitions for IDE Controller (HARD DISK, Flash Module, etc.)
   313                        ; Hardware Adapter provides a 16-bit IDE Port per:
   314                        ;        Seagate ATA Interface Reference Manual 36111-001, Rev. C (21st May 1993)
   315                        ;
   316                        ; Compact Flash Adapter BIOS is based on documentation from SanDisk:
   317                        ;       OEM Product Manual Version 12.0 Doc # 20-10-00038m 02/2007
   318                        ;
   319                        ; Control Block Registers
   320             0000FE76   IDE_ALT_STATUS  .EQU    RTC_IDE_BASE+$16        ;Alternate Status Register (READ)
   321             0000FE76   IDE_DEV_CTRL    .EQU    RTC_IDE_BASE+$16        ;Device Control Register (WRITE)
   322             0000FE77   IDE_DRV_ADDR    .EQU    RTC_IDE_BASE+$17        ;Drive Address Register (READ)
   323                        ;
   324                        ; Command Block Registers
   325             0000FE78   IDE_DATA        .EQU    RTC_IDE_BASE+$18        ;Data Register (R/W)
   326             0000FE79   IDE_ERROR       .EQU    RTC_IDE_BASE+$19        ;Error Register (READ)
   327             0000FE79   IDE_FEATURE     .EQU    RTC_IDE_BASE+$19        ;Feature Register (WRITE)
   328             0000FE7A   IDE_SCT_CNT     .EQU    RTC_IDE_BASE+$1A        ;Sector Count Register
   329             0000FE7B   IDE_SCT_NUM     .EQU    RTC_IDE_BASE+$1B        ;Sector Number Register
   330             0000FE7C   IDE_CYL_LOW     .EQU    RTC_IDE_BASE+$1C        ;Cylinder Low Register
   331             0000FE7D   IDE_CYL_HIGH    .EQU    RTC_IDE_BASE+$1D        ;Cylinder High Register
   332             0000FE7E   IDE_DRV_HEAD    .EQU    RTC_IDE_BASE+$1E        ;Drive/Head Register
  Tue May 18 2021 22:26                                                                                                    Page 7


   333             0000FE7F   IDE_STATUS      .EQU    RTC_IDE_BASE+$1F        ;Status Register (READ)
   334             0000FE7F   IDE_COMMAND     .EQU    RTC_IDE_BASE+$1F        ;Command Register (WRITE)
   335                        ;
   336                        ;**************************************************************************************************
   337                                .END
    41                        ;
    42                        ;**************************************************************************************************
    43                        ;       - Monitor JUMP table: 32 JUMP calls are available. Calls 02-04 are currently Reserved
    44                        ;
    45             0000E000   M_COLD_MON      .EQU    $E000           ;Call 00        Monitor Cold Start
    46             0000E003   M_WARM_MON      .EQU    $E003           ;Call 01        Monitor Warm Start
    47                        ;
    48             0000E00F   M_BSOUT         .EQU    $E00F           ;Call 05        Send Backspace
    49             0000E012   M_XMDM_SAVE     .EQU    $E012           ;Call 06        Xmodem Save Entry
    50             0000E015   M_XMDM_LOAD     .EQU    $E015           ;Call 07        Xmodem Load Entry
    51             0000E018   M_BENCH         .EQU    $E018           ;Call 08        Benchmark Start
    52             0000E01B   M_QUITB         .EQU    $E01B           ;Call 09        Benchmark Stop/End
    53             0000E01E   M_UPTIME        .EQU    $E01E           ;Call 10        Monitor Uptime
    54             0000E021   M_PRSTAT1       .EQU    $E021           ;Call 11        CPU Status Display
    55             0000E024   M_DIS_LINE      .EQU    $E024           ;Call 12        Disassemble Line of Code
    56             0000E027   M_INCINDEX      .EQU    $E027           ;Call 13        Increment Index by 1
    57             0000E02A   M_DECINDEX      .EQU    $E02A           ;Call 14        Decrement Index by 1
    58             0000E02D   M_RDLINE        .EQU    $E02D           ;Call 15        Read Line from Terminal
    59             0000E030   M_RDCHAR        .EQU    $E030           ;Call 16        Read Character from Terminal
    60             0000E033   M_HEXIN2        .EQU    $E033           ;Call 17        Hex input 2 characters
    61             0000E036   M_HEXIN4        .EQU    $E036           ;Call 18        Hex input 4 characters
    62             0000E039   M_HEX2ASC       .EQU    $E039           ;Call 19        Convert Hex to ASCII
    63             0000E03C   M_BIN2ASC       .EQU    $E03C           ;Call 20        Convert Binary to ASCII
    64             0000E03F   M_ASC2BIN       .EQU    $E03F           ;Call 21        Convert ASCII to Binary
    65             0000E042   M_BEEP          .EQU    $E042           ;Call 22        Send BEEP to Terminal
    66             0000E045   M_DOLLAR        .EQU    $E045           ;Call 23        Send $ to Terminal
    67             0000E048   M_CROUT         .EQU    $E048           ;Call 24        Send C/R to Terminal
    68             0000E04B   M_SPC           .EQU    $E04B           ;Call 25        Send ASCII Space to Terminal
    69             0000E04E   M_PRBYTE        .EQU    $E04E           ;Call 26        Print Byte to Terminal
    70             0000E051   M_PRWORD        .EQU    $E051           ;Call 27        Print Word to Terminal
    71             0000E054   M_PRASC         .EQU    $E054           ;Call 28        Print ASCII to Terminal
    72             0000E057   M_PROMPT        .EQU    $E057           ;Call 29        Send Message by number to Terminal
    73             0000E05A   M_PROMPTR       .EQU    $E05A           ;Call 30        Send Message by address to Terminal
    74             0000E05D   M_CONTINUE      .EQU    $E05D           ;Call 31        Y/N Prompt to Continue Command
    75                        ;
    76                        ;**************************************************************************************************
    77                                .ORG    $F800   ;2KB reserved for BIOS, I/O device selects (160 bytes)                    *
    78                        ;**************************************************************************************************
    79                        ;                               START OF BIOS CODE                                                *
    80                        ;**************************************************************************************************
    81                        ;C02BIOS version used here is 3.04 (updated release)
    82                        ; Contains the base BIOS routines in top 2KB of EEPROM
    83                        ; - Input/Feedback from "BDD" - modified CHRIN/CHROUT I/O routines - saves 12 bytes
    84                        ; - $F800 - $F9FF 512 bytes for BIOS SCC2691, NMI Panic routine
    85                        ; - $FA00 - $FDFF reserved for BIOS expansion (1KB)
    86                        ; - $FE00 - $FE7F reserved for HW (4-I/O selects, 32 bytes wide)
    87                        ; - $FE80 - $FE9F SCC2691 UART (32 bytes wide, only 8 bytes used)
    88                        ; - $FEA0 - $FEFF used for Vector and Hardware configuration data
    89                        ; - $FF00 - $FFFF JMP table, CPU startup, NMI/BRK/IRQ pre-post routines, Page $03 init, BIOS msg
    90                        ;
    91                        ; UPDATEs:
    92                        ; Fixed IRQ enable for CF Card. Also streamlined some startup routines. 11th Oct 2020
    93                        ; Eliminates IDE byte swapping to ensure compatibility with standard formats 20th January 2021
    94                        ; Reserved $0400 for second UART buffer space 5th February 2021
    95                        ; Default IDE Block buffer at $0600 5th February 2021
    96                        ; Default RTC NVRAM buffer space at $0500 5th February 2021
    97                        ; Panic Routine changed, no longer saves multiple pages, just restores system 5th February 2021
    98                        ; New routine to Start Benchmark Counter. Allows counter Start/Stop (pause) 5th February 2021
  Tue May 18 2021 22:26                                                                                                    Page 8


    99                        ; Some minor cleanup and fixed a few bugs in the RTC and IDE routines 14th May 2021
   100                        ;
   101                        ; Note: Move Enhanced Basic buffer page to $0500
   102                        ;
   103                        ;**************************************************************************************************
   104                        ; The following 32 functions are provided by BIOS via the JMP Table
   105                        ; $FF21 - $FF2A are Reserved for future expansion (4 available)
   106                        ;
   107                        ; $FF00 IDE_RESET       ;Reset IDE Controller (run diagnostics)
   108                        ; $FF03 IDE_GET_STAT    ;Get Status and extended error code
   109                        ; $FF06 IDE_IDENTIFY    ;Load IDE Identity Data at $0600
   110                        ; $FF09 IDE_READ_LBA    ;Read LBA into memory
   111                        ; $FF0C IDE_WRITE_LBA   ;Write LBA from memory
   112                        ; $FF0F IDE_VERFY_LBA   ;Verify LBA from last Read/Write
   113                        ; $FF12 IDE_SET_LBA     ;Set LBA number (24-bit onlu)
   114                        ; $FF15 IDE_SET_ADDR    ;Set LBA transfer address (16-bit plus block count)
   115                        ;
   116                        ; $FF18 RTC_NVRD        ;Read NVRAM (256 bytes) from RTC to memory (16-bit)
   117                        ; $FF1B RTC_NVWR        ;Write NVRAM (256 bytes) from memory to RTC (16-bit)
   118                        ; $FF1E RTC_INIT        ;Initialize software RTC from hardware RTC
   119                        ;
   120                        ; $FF2D CNT_INIT        ;Reset benchmark timing counters/Start 10ms benchmark timer
   121                        ; $FF30 CNT_STRT        ;Start 10ms benchmark timing counter
   122                        ; $FF33 CNT_STOP        ;Stop 10ms benchmark timing counter
   123                        ;
   124                        ; $FF36 CHRIN_NW        ;Data input from console, no waiting, clear carry if none
   125                        ; $FF39 CHRIN           ;Data input from console
   126                        ; $FF3C CHROUT          ;Data output to console
   127                        ;
   128                        ; $FF3F SET_DLY         ;Set delay value for milliseconds and 16-bit counter
   129                        ; $FF42 EXE_MSDLY       ;Execute millisecond delay 1-256 * 10 milliseconds
   130                        ; $FF45 EXE_LGDLY       ;Execute long delay; millisecond delay * 16-bit count
   131                        ; $FF48 EXE_XLDLY       ;Execute extra long delay; 8-bit count * long delay
   132                        ;
   133                        ; $FF4B INIT_VEC        ;Initialize soft vectors at $0300 from ROM
   134                        ; $FF4E INIT_CFG        ;Initialize soft config values at $0320 from ROM
   135                        ;
   136                        ; $FF51 INIT_2691       ;Initialize SCC2691 console 38.4K, 8-N-1 RTS/CTS
   137                        ; $FF54 RESET_2691      ;Reset SCC2691 - called before INIT_2691
   138                        ;
   139                        ; $FF57 MONWARM         ;Monitor warm start - jumps to page $03
   140                        ; $FF5A MONCOLD         ;Monitor cold start - jumps to page $03
   141                        ; $FF5D COLDSTRT        ;System cold start - RESET vector for 65C02
   142                        ;**************************************************************************************************
   143                        ;               Data In and Out routines for Console I/O buffer                                   *
   144                        ;**************************************************************************************************
   145                        ;Data Input routines
   146                        ;CHRIN_NW uses CHRIN, returns if data is not available from the buffer with carry flag clear
   147                        ; else returns with data in A Reg and carry flag set. CHRIN waits for data to be in the
   148                        ; buffer, then returns with carry flag set. Receive is IRQ driven/buffered with a size of 128 bytes
   149                        ;
   150 00:F800: 18           CHRIN_NW        CLC                     ;Clear Carry flag for no data (2)
   151 00:F801: A5 DF                        LDA     ICNT            ;Get buffer count (4)
   152 00:F803: D0 05                        BNE     GET_CH          ;Branch if buffer is not empty (2/3)
   153 00:F805: 60                           RTS                     ;or return to caller (6)
   154                        ;
   155 00:F806: A5 DF        CHRIN           LDA     ICNT            ;Get data count (3)
   156 00:F808: F0 FC                        BEQ     CHRIN           ;If zero (no data, loop back) (2/3)
   157                        ;
   158 00:F80A: 5A           GET_CH          PHY                     ;Save Y Reg (3)
   159 00:F80B: A4 E0                        LDY     IHEAD           ;Get the buffer head pointer (3)
   160 00:F80D: B9 00 02                     LDA     IBUF,Y          ;Get the data from the buffer (4)
   161 00:F810: E6 E0                        INC     IHEAD           ;Increment head pointer (5)
  Tue May 18 2021 22:26                                                                                                    Page 9


   162 00:F812: 77 E0                        RMB7    IHEAD           ;Strip off bit 7, 128 bytes only (5)
   163 00:F814: C6 DF                        DEC     ICNT            ;Decrement the buffer count (5)
   164                        ;
   165 00:F816: 7A                           PLY                     ;Restore Y Reg (4)
   166 00:F817: 38                           SEC                     ;Set Carry flag for data available (2)
   167 00:F818: 60                           RTS                     ;Return to caller with data in A Reg (6)
   168                        ;
   169                        ;Data Output routine: puts the data in the A Reg into the xmit buffer, data in
   170                        ; A Reg is preserved on exit. Transmit is IRQ driven/buffered with a size of 128 bytes
   171                        ;
   172 00:F819: 5A           CHROUT          PHY                     ;save Y Reg (3)
   173 00:F81A: A4 E2        OUTCH           LDY     OCNT            ;get data output count in buffer (3)
   174 00:F81C: 30 FC                        BMI     OUTCH           ;check against limit, loop back if full (2/3)
   175                        ;
   176 00:F81E: A4 E4                        LDY     OTAIL           ;Get the buffer tail pointer (3)
   177 00:F820: 99 80 02                     STA     OBUF,Y          ;Place data in the buffer (5)
   178 00:F823: E6 E4                        INC     OTAIL           ;Increment Tail pointer (5)
   179 00:F825: 77 E4                        RMB7    OTAIL           ;Strip off bit 7, 128 bytes only (5)
   180 00:F827: E6 E2                        INC     OCNT            ;Increment data count (5)
   181                        ;
   182 00:F829: A0 04                        LDY     #%00000100      ;Get mask for xmit on (2)
   183 00:F82B: 8C 82 FE                     STY     UART_COMMAND    ;Turn on xmit (4)
   184                        ;
   185 00:F82E: 7A                           PLY                     ;Restore Y Reg (4)
   186 00:F82F: 60                           RTS                     ;Return to caller (6)
   187                        ;
   188                        ;**************************************************************************************************
   189                        ;Delay Routines: SET_DLY sets up the MSDELAY value and also sets the 16-bit Long Delay
   190                        ; On entry, A Reg = 10-millisecond count, X Reg = High multiplier, Y Reg = Low multiplier
   191                        ; these values are used by the EXE_MSDLY and EXE_LGDLY routines. Minimum delay is 10ms
   192                        ; values for MSDELAY are $00-$FF ($00 = 256 times)
   193                        ; values for Long Delay are $0000-$FFFF (0-65535 times MSDELAY)
   194                        ; longest delay is 65,535*256*10ms = 16,776,960 * 0.01 = 167,769.60 seconds
   195                        ;
   196                        ;NOTE: All delay execution routines preserve registers (EXE_MSDLY, EXE_LGDLY, EXE_XLDLY)
   197                        ;
   198 00:F830: 85 F0        SET_DLY         STA     SETMS           ;Save Millisecond count
   199 00:F832: 84 F1                        STY     DELLO           ;Save Low multiplier
   200 00:F834: 86 F2                        STX     DELHI           ;Save High multiplier
   201 00:F836: 60                           RTS                     ;Return to caller
   202                        ;
   203                        ;EXE MSDELAY routine is the core delay routine. It sets the MSDELAY count value from the
   204                        ; SETMS variable, enables the MATCH flag, then waits for the MATCH flag to clear
   205                        ;
   206 00:F837: 48           EXE_MSDLY       PHA                     ;Save A Reg
   207 00:F838: F7 FF                        SMB7    MATCH           ;Set MATCH flag bit
   208 00:F83A: A5 F0                        LDA     SETMS           ;Get delay seed value
   209 00:F83C: 85 EF                        STA     MSDELAY         ;Set MS delay value
   210                        ;
   211 00:F83E: FF FF FD     MATCH_LP        BBS7    MATCH,MATCH_LP  ;Test MATCH flag, loop until cleared
   212 00:F841: 68                           PLA                     ;Restore A Reg
   213 00:F842: 60                           RTS                     ;Return to caller
   214                        ;
   215                        ;EXE LONG Delay routine is the 16-bit multiplier for the MSDELAY routine.
   216                        ; It loads the 16-bit count from DELLO/DELHI, then loops the MSDELAY routine until the
   217                        ; 16-bit count is decremented to zero.
   218                        ;
   219 00:F843: DA           EXE_LGDLY       PHX                     ;Save X Reg
   220 00:F844: 5A                           PHY                     ;Save Y Reg
   221 00:F845: A6 F2                        LDX     DELHI           ;Get high byte count
   222 00:F847: E8                           INX                     ;Increment by one (checks for $00 vs $FF)
   223 00:F848: A4 F1                        LDY     DELLO           ;Get low byte count
   224 00:F84A: F0 06                        BEQ     SKP_DLL         ;If zero, skip to high count
  Tue May 18 2021 22:26                                                                                                    Page 10


   225 00:F84C: 20 37 F8     DO_DLL          JSR     EXE_MSDLY       ;Call millisecond delay
   226 00:F84F: 88                           DEY                     ;Decrement low count
   227 00:F850: D0 FA                        BNE     DO_DLL          ;Branch back until done
   228                        ;
   229 00:F852: CA           SKP_DLL         DEX                     ;Decrement high byte index
   230 00:F853: D0 F7                        BNE     DO_DLL          ;Loop back to D0_DLL (will run 256 times)
   231 00:F855: 7A                           PLY                     ;Restore Y Reg
   232 00:F856: FA                           PLX                     ;Restore X Reg
   233 00:F857: 60                           RTS                     ;Return to caller
   234                        ;
   235                        ;EXE EXTRA LONG Delay routine uses XDL variable as an 8-bit count and calls the EXE LONG Delay
   236                        ; routine XDL times. On entry, XDL contains the number of iterations This can increase the delay
   237                        ; by 256 times the above value of 167,769.60 seconds (~497 Days). Note: $00 = 256 times
   238                        ;
   239 00:F858: 20 43 F8     EXE_XLDLY       JSR     EXE_LGDLY       ;Call the Long Delay routine
   240 00:F85B: C6 F3                        DEC     XDL             ;Decrement count
   241 00:F85D: D0 F9                        BNE     EXE_XLDLY       ;Loop back until XDL times out
   242 00:F85F: 60                           RTS                     ;Return to caller
   243                        ;
   244                        ;**************************************************************************************************
   245                        ;COUNTER BENCHMARK TIMING ROUTINES
   246                        ; To enable a level of benchmarking, three new routines have been added to C02BIOS version 2.05
   247                        ; Using the existing 10ms Jiffy Clock, three bytes of Page zero are used to hold the variables;
   248                        ; MS10_CNT - a 10ms count variable for 0.01 resolution of timing - resets at 100 counts (1 second)
   249                        ; SECL_CNT - a low byte seconds count
   250                        ; SECH_CNT - a high byte seconds count
   251                        ; This provides up to 65,535.99 seconds of timing with 0.01 seconds resolution
   252                        ; - the count variables reset to zero after 65,535.99 seconds!
   253                        ;
   254                        ; New routines in C02Monitor version 2.05:
   255                        ; - Start counter (calls CNT_STRT) after prompting user
   256                        ; - Stop counter (calls CNT_STOP) and displays the timing count as: XXXXX.XX Seconds.
   257                        ;
   258                        ; CNT_INIT has been added as a new BIOS call, effectively replacing CNT_STRT, as it does
   259                        ; the same thing. CNT_STRT has been changed to only set the MATCH flag to restart the timing.
   260                        ; This allows the Benchmark Timer to effectively be paused and resumed without resetting the
   261                        ; the count variables. CNT_INIT has also been added to the BIOS JUMP table.
   262                        ;
   263                        ;CNT_INIT is used to zero the timing pointers and start the benchmark timing
   264                        ;CNT_STRT is used to start the timing by setting bit 6 of the MATCH flag (new in BIOS 3.03)
   265                        ;CNT_STOP is used to stop the timing by clearing bit 6 of the MATCH flag
   266                        ; the interrupt handler for the UART timer increments the timing variables when bit 6 of the
   267                        ; MATCH flag is active.
   268                        ;
   269 00:F860: 67 FF        CNT_INIT        RMB6    MATCH           ;Clear bit 6 of MATCH flag, ensure timing is disabled
   270 00:F862: 64 F4                        STZ     MS10_CNT        ;Zero 10ms timing count
   271 00:F864: 64 F5                        STZ     SECL_CNT        ;Zero low byte of seconds timing count
   272 00:F866: 64 F6                        STZ     SECH_CNT        ;Zero high byte of seconds timing count
   273                        ;
   274 00:F868: E7 FF        CNT_STRT        SMB6    MATCH           ;Set bit 6 of MATCH flag to enable timing
   275 00:F86A: 60                           RTS                     ;Return to caller
   276                        ;
   277 00:F86B: 67 FF        CNT_STOP        RMB6    MATCH           ;Clear bit 6 of MATCH flag to disable timing
   278 00:F86D: 60                           RTS                     ;Return to caller
   279                        ;
   280                        ;**************************************************************************************************
   281                        ;START of IDE Routines for Compact Flash adapter                                                  *
   282                        ;**************************************************************************************************
   283                        ;
   284                        IDE_READ_LBA                            ;Read a Block of data from IDE device
   285                        ;
   286                        ; This routine requires loading the requested LBA into the appropriate registers and
   287                        ; issuing the READ command 20h. The LBA count supported for the BIOS are bits 0-23,
  Tue May 18 2021 22:26                                                                                                    Page 11


   288                        ; so bits 24-27 are always set to 0. This provides access to IDE devices up to 8GB.
   289                        ;
   290                        ; Once the registers/parameters are setup, the Read Block command is issued.
   291                        ; This results in an interrupt being generated. The ISR handles the transfer of LBA
   292                        ; data from the CF Card to memory.
   293                        ;
   294                        ; The registers used are the same for read/write/verify. These are:
   295                        ;
   296                        ;       IDE_COMMAND = function requested (20h = READ LBA command)
   297                        ;       IDE_DRV_HEAD = (Upper 4 bits) used as:
   298                        ;               bit 7 = 1 per Sandisk documentation
   299                        ;               bit 6 = 1 for LBA mode
   300                        ;               bit 5 = 1 per Sandisk documentation
   301                        ;               bit 4 = 0 for Drive 0
   302                        ;       IDE_DRV_HEAD = LBA Address bits 27-24 (lower 4 bits) - not used, always 0000
   303                        ;       IDE_CYL_HIGH = LBA Address bits 23-16
   304                        ;       IDE_CYL_LOW = LBA Address bits 15-8
   305                        ;       IDE_SCT_NUM = LBA Address bits 7-0
   306                        ;       IDE_SCT_CNT = number of blocks to read (most CF-Cards are limited to 1)
   307                        ;
   308 00:F86E: 20 06 F9                     JSR     IDE_SET_PARMS   ;Setup required parameters (6)
   309 00:F871: A9 20                        LDA     #$20            ;Get Read LBA command (2)
   310                        IDENT_READ                              ;Identity Command jumps to here to complete
   311 00:F873: B7 FF                        SMB3    MATCH           ;Set Read LBA bit (5)
   312 00:F875: 8D 7F FE                     STA     IDE_COMMAND     ;Send command to IDE Controller (4)
   313                        ;
   314                        LBA_RD_CMD
   315 00:F878: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   316 00:F87B: 30 FB                        BMI     LBA_RD_CMD      ;Loop until IDE controller not Busy (2/3)
   317                        ;
   318                        LBA_RD_WAIT
   319 00:F87D: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   320 00:F880: C9 50                        CMP     #$50            ;Compare for ready (2)
   321 00:F882: D0 04                        BNE     LBA_RD_ERR      ;If not, check for error condition (2/3)
   322                        LBA_RD_OK
   323 00:F884: BF FF FD                     BBS3    MATCH,LBA_RD_OK ;Wait for Read completed via ISR (5)
   324 00:F887: 60                           RTS                     ;Return to caller (status in A Reg) (6)
   325                        LBA_RD_ERR
   326 00:F888: 4A                           LSR     A               ;Shift error bit to carry (2)
   327 00:F889: 90 F2                        BCC     LBA_RD_WAIT     ;If clear, loop back and continue waiting (2/3)
   328                        ;
   329 00:F88B: 37 FF                        RMB3    MATCH           ;Reset Read LBA bit (no ISR invoked) (5)
   330 00:F88D: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   331 00:F890: 85 D0                        STA     IDE_STATUS_RAM  ;Update RAM Status Register (3)
   332 00:F892: 60                           RTS                     ;Return to caller (6)
   333                        ;
   334                        IDE_WRITE_LBA                           ;Write a block of data to LBA
   335                        ;
   336                        ; This routine requires loading the requested LBA into the appropriate registers and
   337                        ; issuing the WRITE command 30h. The LBA count supported for the BIOS are bits 0-23,
   338                        ; so bits 24-27 are always set to 0. This provides access to IDE devices up to 8GB.
   339                        ;
   340                        ; The registers used are the same for read/write/verify. These are:
   341                        ;
   342                        ;       IDE_COMMAND = function requested (30h = WRITE LBA command)
   343                        ;       IDE_DRV_HEAD = (Upper 4 bits) used as:
   344                        ;               bit 7 = 1 per Sandisk documentation
   345                        ;               bit 6 = 1 for LBA mode
   346                        ;               bit 5 = 1 per Sandisk documentation
   347                        ;               bit 4 = 0 for Drive 0
   348                        ;       IDE_DRV_HEAD = LBA Address bits 27-24 (lower 4 bits) - not used, always 0000
   349                        ;       IDE_CYL_HIGH = LBA Address bits 23-16
   350                        ;       IDE_CYL_LOW = LBA Address bits 15-8
  Tue May 18 2021 22:26                                                                                                    Page 12


   351                        ;       IDE_SCT_NUM = LBA Address bits 7-0
   352                        ;       IDE_SCT_CNT = number of blocks to read (most CF-Cards are limited to 1)
   353                        ;
   354 00:F893: 20 06 F9                     JSR     IDE_SET_PARMS   ;Setup required parameters (6)
   355                        ;
   356 00:F896: A7 FF                        SMB2    MATCH           ;Set Write LBA bit (5)
   357 00:F898: A9 30                        LDA     #$30            ;Get Write LBA command (2)
   358 00:F89A: 8D 7F FE                     STA     IDE_COMMAND     ;Send command to IDE Controller (4)
   359                        LBA_WR_CMD
   360 00:F89D: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   361 00:F8A0: 30 FB                        BMI     LBA_WR_CMD      ;Loop until IDE controller not Busy (2/3)
   362 00:F8A2: 4A                           LSR     A               ;Shift Error bit into Carry flag (2)
   363 00:F8A3: B0 2A                        BCS     IDE_WRITE_ERR   ;If Carry set, IDE error (2/3)
   364                        ;
   365                        ; Write Block routine integrated into IDE_WRITE_LBA
   366                        ;
   367                        ; - High byte needs to be loaded into the latch before the
   368                        ;   low byte is loaded into the Data Register!
   369                        ;
   370                        IDE_WRITE_BLK                           ;Write a block of data
   371 00:F8A5: 5A                           PHY                     ;Save Y reg
   372 00:F8A6: A0 01                        LDY     #$01            ;Set offset for high byte latch
   373                        ;
   374                        IDE_WRITE_LOOP
   375 00:F8A8: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register
   376 00:F8AB: 29 08                        AND     #%00001000      ;Check for DRQ active
   377 00:F8AD: F0 18                        BEQ     IDE_WR_FIN      ;If not active, exit (below)
   378                        IDE_WR_WBLK
   379 00:F8AF: B1 FD                        LDA     (BIOS_XFERL),Y  ;Get first byte of buffer + 1
   380 00:F8B1: 8D 75 FE                     STA     IDE_16_WRITE    ;Place into high byte latch
   381 00:F8B4: B2 FD                        LDA     (BIOS_XFERL)    ;Get first byte of buffer
   382 00:F8B6: 8D 78 FE                     STA     IDE_DATA        ;Write buffer to IDE (writes a word)
   383                        ;
   384                        ; - Buffer index needs to be incremented twice
   385                        ;
   386 00:F8B9: E6 FD                        INC     BIOS_XFERL      ;Increment pointers once
   387 00:F8BB: D0 02                        BNE     IDE_WR_BLK1
   388 00:F8BD: E6 FE                        INC     BIOS_XFERH
   389                        IDE_WR_BLK1
   390 00:F8BF: E6 FD                        INC     BIOS_XFERL      ;Increment pointers again
   391 00:F8C1: D0 E5                        BNE     IDE_WRITE_LOOP
   392 00:F8C3: E6 FE                        INC     BIOS_XFERH
   393                        IDE_WR_BLK2
   394 00:F8C5: 80 E1                        BRA     IDE_WRITE_LOOP  ;Loop back for 256 words
   395                        ;
   396 00:F8C7: 20 2F F9     IDE_WR_FIN      JSR     TST_IDE_RDY     ;Wait for IDE Controller ready
   397                        ;
   398                        WR_WAIT
   399 00:F8CA: AF FF FD                     BBS2    MATCH,WR_WAIT   ;Wait for Write completed via ISR
   400 00:F8CD: 7A                           PLY                     ;Restore Y reg
   401 00:F8CE: 60                           RTS                     ;Return to caller
   402                        ;
   403                        IDE_WRITE_ERR
   404 00:F8CF: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   405 00:F8D2: 85 D0                        STA     IDE_STATUS_RAM  ;Save Status Register (3)
   406 00:F8D4: 27 FF                        RMB2    MATCH           ;Reset Write LBA bit (no ISR) (5)
   407 00:F8D6: 60                           RTS                     ;Return to caller (6)
   408                        ;
   409                        IDE_VERIFY_LBA                          ;Verify LBA after write
   410                        ;
   411                        ; This routine requires loading the requested LBA into the appropriate registers and
   412                        ; issuing the VERIFY command 40h. The LBA count supported for the BIOS are bits 0-23,
   413                        ; so bits 24-27 are always set to 0. This provides access to IDE devices up to 8GB.
  Tue May 18 2021 22:26                                                                                                    Page 13


   414                        ;
   415                        ; Note: The Verify function here is a feature of the CF Card controller.
   416                        ; It is identical to a Read Block command except no Data is transferred, only verified.
   417                        ; Also, no DRQ is set, but an interrupt is generated after the Verify is completed.
   418                        ;
   419                        ; The registers used are the same for read/write/verify. These are:
   420                        ;
   421                        ;       IDE_COMMAND = function requested (40h = Verify LBA command)
   422                        ;       IDE_DRV_HEAD = (Upper 4 bits) used as:
   423                        ;               bit 7 = 1 per Sandisk documentation
   424                        ;               bit 6 = 1 for LBA mode
   425                        ;               bit 5 = 1 per Sandisk documentation
   426                        ;               bit 4 = 0 for Drive 0
   427                        ;       IDE_DRV_HEAD = LBA Address bits 27-24 (lower 4 bits) - not used, always 0000
   428                        ;       IDE_CYL_HIGH = LBA Address bits 23-16
   429                        ;       IDE_CYL_LOW = LBA Address bits 15-8
   430                        ;       IDE_SCT_NUM = LBA Address bits 7-0
   431                        ;       IDE_SCT_CNT = number of blocks to read (most CF-Cards are limited to 1)
   432                        ;
   433 00:F8D7: 20 06 F9                     JSR     IDE_SET_PARMS   ;Setup required parameters
   434                        ;
   435 00:F8DA: 97 FF                        SMB1    MATCH           ;Set Verify LBA bit
   436 00:F8DC: A9 40                        LDA     #$40            ;Get Verify LBA command
   437 00:F8DE: 8D 7F FE                     STA     IDE_COMMAND     ;Send command to IDE Controller
   438                        LBA_VF_CMD
   439 00:F8E1: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register
   440 00:F8E4: 30 FB                        BMI     LBA_VF_CMD      ;Loop until IDE controller not Busy
   441 00:F8E6: 4A                           LSR     A               ;Shift Error bit into Carry flag
   442 00:F8E7: 90 08                        BCC     VF_FINISH       ;If Carry clear, no error
   443                        ;
   444 00:F8E9: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register
   445 00:F8EC: 85 D0                        STA     IDE_STATUS_RAM  ;Save Status Register
   446 00:F8EE: 17 FF                        RMB1    MATCH           ;Reset Verify LBA bit (no ISR)
   447 00:F8F0: 60                           RTS                     ;Return to caller
   448                        ;
   449                        VF_FINISH
   450 00:F8F1: 20 2F F9                     JSR     TST_IDE_RDY     ;Wait for IDE Controller ready
   451                        VF_WAIT
   452 00:F8F4: 9F FF FD                     BBS1    MATCH,VF_WAIT   ;Wait for Verify to complete via ISR
   453 00:F8F7: 60                           RTS                     ;Return to caller
   454                        ;
   455                        IDE_SET_ADDRESS                         ;Set Address for LBA read or write
   456                        ;
   457                        ; This routine uses the A,Y,X registers to setup the address in memory that a block
   458                        ; will be read to or written from (16-bit address), along with the block count.
   459                        ; The Register usage is as follows:
   460                        ;       A Register = Memory address low byte
   461                        ;       Y Register = Memory address high byte
   462                        ;       X Register = Block count to transfer (device dependent, most CF Cards = 1)
   463 00:F8F8: 85 F7                        STA     LBA_ADDR_LOW    ;Set LBA low byte address (3)
   464 00:F8FA: 84 F8                        STY     LBA_ADDR_HIGH   ;Set LBA high byte address (3)
   465 00:F8FC: 86 F9                        STX     LBA_XFER_CNT    ;Set LBA Block count for xfer (3)
   466 00:F8FE: 60                           RTS                     ;Return to caller (6)
   467                        ;
   468                        IDE_SET_LBA                             ;Set the LBA block for transfer (read/write)
   469                        ;
   470                        ; This routine sets the variables used to select the starting LBA for transfer.
   471                        ; The Register usage is as follows:
   472                        ;       A Register = LBA Address bits 7-0
   473                        ;       Y Register = LBA Address bits 15-8
   474                        ;       X Register = LBA Address bits 23-16
   475 00:F8FF: 85 FA                        STA     LBA_LOW_BYTE    ;Store Address bits 0-7 (3)
   476 00:F901: 84 FB                        STY     LBA_HIGH_BYTE   ;Store Address bits 8-15 (3)
  Tue May 18 2021 22:26                                                                                                    Page 14


   477 00:F903: 86 FC                        STX     LBA_EXT_BYTE    ;Store Address bits 16-23 (3)
   478 00:F905: 60                           RTS                     ;Return to caller (6)
   479                        ;
   480                        ; This routine sets the LBA number used for all transfers.
   481                        ; - The IDE Controller is checked first to ensure it's ready to receive parameters
   482                        ; - then the requested LBA (stored in Page Zero variables) are loaded into the
   483                        ; - IDE Controller registers, followed by the required Mode parameters.
   484                        ; - Last, the transfer address is setup which points to the location in memory that
   485                        ; - will be used to transfer Data to or from.
   486                        ;
   487                        IDE_SET_PARMS                           ;Set All parameters for LBA transfers
   488                        ;
   489 00:F906: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   490 00:F909: 30 FB                        BMI     IDE_SET_PARMS   ;Loop until BUSY bit is clear (2/3)
   491                        ;
   492 00:F90B: A5 FC                        LDA     LBA_EXT_BYTE    ;Set LBA bits 23-16 (3)
   493 00:F90D: 8D 7D FE                     STA     IDE_CYL_HIGH    ;Send to IDE (4)
   494 00:F910: A5 FB                        LDA     LBA_HIGH_BYTE   ;Set LBA bits 15-8 (3)
   495 00:F912: 8D 7C FE                     STA     IDE_CYL_LOW     ;Send to IDE (4)
   496 00:F915: A5 FA                        LDA     LBA_LOW_BYTE    ;Get LBA bits 7-0 (3)
   497 00:F917: 8D 7B FE                     STA     IDE_SCT_NUM     ;Send to IDE (4)
   498 00:F91A: A5 F9                        LDA     LBA_XFER_CNT    ;Get Block count to read (CF always 1) (3)
   499 00:F91C: 8D 7A FE                     STA     IDE_SCT_CNT     ;Send to IDE (4)
   500                        ;
   501                        IDE_SET_PARMS2                          ;Set partial parameters (non LBA xfer commands)
   502                        ;
   503 00:F91F: A9 E0                        LDA     #%11100000      ;Set Drive 0, LBA mode, LBA bits 27-24 as 0 (2)
   504 00:F921: 8D 7E FE                     STA     IDE_DRV_HEAD    ;Send to IDE (4)
   505                        ;
   506 00:F924: A5 F7                        LDA     LBA_ADDR_LOW    ;Setup buffer address (3)
   507 00:F926: 85 FD                        STA     BIOS_XFERL      ;Store low byte (3)
   508 00:F928: A5 F8                        LDA     LBA_ADDR_HIGH   ;Block Buffer Address (3)
   509 00:F92A: 85 FE                        STA     BIOS_XFERH      ;Store high byte (3)
   510 00:F92C: 64 D0                        STZ     IDE_STATUS_RAM  ;Clear RAM Status Register, ISR updates it (3)
   511 00:F92E: 60                           RTS                     ;Return to caller (6)
   512                        ;
   513                        ;Test for IDE Controller Ready
   514                        ; This routine tests that the IDE Controller (CF Card) is ready and can accept a command
   515                        ; for execution. It turns out that two bits in the status register must be tested to ensure
   516                        ; the card is ready... testing only one flag is unreliable and results in random failures
   517                        ; in data transfers.
   518                        ;
   519                        TST_IDE_RDY
   520 00:F92F: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   521 00:F932: C9 50                        CMP     #$50            ;Mask off Ready bits (2)
   522 00:F934: D0 F9                        BNE     TST_IDE_RDY     ;Loop back until set (ready) (2/3)
   523 00:F936: 60                           RTS                     ;Return to caller (6)
   524                        ;
   525                        ;Test for IDE Controller Busy
   526                        ; This routine loops on the Busy flag. If the IDE Controller is busy, no other
   527                        ; status register flags are valid and no commands can be sent to the IDE Controller.
   528                        ; Hence, this routine is key to determine if the IDE Controller is available to
   529                        ; accept a command. Bit 7 is the Busy Bit. The 65C02 will set the "n" flag
   530                        ; if Bit 7 is active, else clear it.
   531                        ;
   532                        TST_IDE_BUSY
   533 00:F937: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   534 00:F93A: 30 FB                        BMI     TST_IDE_BUSY    ;Loop until BUSY bit is clear (2/3)
   535 00:F93C: 60                           RTS                     ;Return to Caller (6)
   536                        ;
   537                        ;**************************************************************************************************
   538                        ;START of Realtime Clock Routines for Compact Flash adapter                                       *
   539                        ;**************************************************************************************************
  Tue May 18 2021 22:26                                                                                                    Page 15


   540                        ;
   541                        ;RTC Routines to Read and Write Non-Volatile RAM - 256 Bytes
   542                        ; To use either routine, the starting memory address needs to be
   543                        ; loaded into the A/Y registers. A reg = low byte, Y reg = high byte
   544                        ;
   545 00:F93D: 20 5B F9     RTC_NVRD        JSR     RTC_NVSET       ;Setup for transfer
   546 00:F940: AD 73 FE     RTC_RD_LOOP     LDA     RTC_RAM_DATA    ;Get NVRAM Data
   547 00:F943: 91 FD                        STA     (BIOS_XFERL),Y  ;Save into RAM
   548 00:F945: C8                           INY                     ;Increment Y Index
   549 00:F946: D0 F8                        BNE     RTC_RD_LOOP     ;Loop back reading NVRAM
   550 00:F948: 80 0B                        BRA     CLEAR_BMI       ;Clear Burst Mode, exit
   551                        ;
   552 00:F94A: 20 5B F9     RTC_NVWR        JSR     RTC_NVSET       ;Setup for transfer
   553 00:F94D: B1 FD        RTC_WR_LOOP     LDA     (BIOS_XFERL),Y  ;Get RAM
   554 00:F94F: 8D 73 FE                     STA     RTC_RAM_DATA    ;Write to NVRAM Data
   555 00:F952: C8                           INY                     ;Increment Y Index
   556 00:F953: D0 F8                        BNE     RTC_WR_LOOP     ;Loop back writing NVRAM
   557 00:F955: A9 20        CLEAR_BMI       LDA     #%00100000      ;Get Burst Mode Increment bit
   558 00:F957: 1C 6F FE                     TRB     RTC_CONTROL_B   ;Clear Burst Mode for NVRAM
   559 00:F95A: 60                           RTS                     ;Return to caller
   560                        ;
   561 00:F95B: 85 FD        RTC_NVSET       STA     BIOS_XFERL      ;Save Low Address location
   562 00:F95D: 84 FE                        STY     BIOS_XFERH      ;Save High Address location
   563 00:F95F: A9 20                        LDA     #%00100000      ;Get Burst Mode Increment bit
   564 00:F961: 0C 6F FE                     TSB     RTC_CONTROL_B   ;Set Burst Mode for NVRAM
   565 00:F964: 9C 70 FE                     STZ     RTC_RAM_ADDR    ;Set NVRAM Address to Zero
   566 00:F967: A0 00                        LDY     #$00            ;Zero Y reg - Index
   567 00:F969: 60                           RTS                     ;Return to caller
   568                        ;
   569                        ;**************************************************************************************************
   570                        ;START OF PANIC ROUTINE
   571                        ;The Panic routine is for debug of system problems, i.e., a crash. The hardware design requires a
   572                        ; debounced NMI trigger button which is manually operated when the system crashes or malfunctions.
   573                        ;
   574                        ;Starting with C02BIOS 3.03, pages are no longer saved! This is the result of adding additional
   575                        ; hardware devices which require additional buffer space as:
   576                        ; - Second UART Port Receive/Transmit buffer (future reserve) at Page $04
   577                        ; - DS1511 Realtime Clock NVRAM buffer at Page $05
   578                        ; - IDE Controller device LBA buffer at Pages $06 and $07
   579                        ;
   580                        ; User presses the NMI (panic) button. The NMI vectored routine will perform the following tasks:
   581                        ; 1- Save registers in page zero locations
   582                        ; 2- Clear all Console I/O buffer pointers
   583                        ; 3- Call the ROM routines to init the vectors and config data (page $03)
   584                        ; 4- Call the ROM routines to reset/init the Console UART (SCC2691)
   585                        ; 5- Enter the Monitor via the warm start vector
   586                        ;
   587                        ; Note: The additional hardware detection (RTC-IDE) are NOT executed with the Panic routine!
   588                        ; The interrupt vectors are restored without including the additional ISR for the IDE controller.
   589                        ;
   590                        ; Note: no memory is cleared except the required pointers/vectors to restore the system.
   591                        ;
   592                        ;Note: it's possible to lockup the SCC2691 so that the Reset/Init routines can not recover it.
   593                        ; The problem is one of two possibilities:
   594                        ;  1- The BRG Test mode has been toggled via a read of the BRG Test Register. * - see below.
   595                        ;  2- The X1/X16 Test mode has been toggled via a read of the X1/X16 Test Register.
   596                        ;
   597                        ;The first scenario can be avoided if the baud rate is setup for 19.2K or 38.4K, as the test mode
   598                        ; uses the same baud rate as normal mode. Note that this does not lock up the UART in any way, but
   599                        ; simply changes the baud rate per the BRG Test mode table. A second read to the BRG Test mode
   600                        ; register will change the baud rate back to normal. As a default, the baud rate is set for 38.4K.
   601                        ;
   602                        ; NOTE: This is no longer a problem due to extended baud rates now supported starting in BIOS 2.05!
  Tue May 18 2021 22:26                                                                                                    Page 16


   603                        ; New default baud rate is now set to 115.2K.
   604                        ;
   605                        ;The second scenario is more difficult to workaround. There's no telling if a read was done to the
   606                        ; X1/X16 Test Mode Register. There are only two options to correct this:
   607                        ;  1- a second read of the X1/X16 Test Mode Register
   608                        ;  2- a hardware Reset applied to the UART.
   609                        ; In the interest of being able to use the NMI Panic routine, the code does a read of the X1/X16
   610                        ; Test Mode Register. If pressing the Panic button does not restore the UART, pressing it a second
   611                        ; time might, unless the NMI vector has been changed or corrupted!
   612                        ; NOTE: See below for a change in accessing this register in the NMI routine!
   613                        ;
   614                        ;NOTE: The X1/X16 Test mode is toggled via the INIT_2691 routine below! This is the result of an
   615                        ; anomaly in the W65C02 as explained in the Init section below. This is noted here for awareness
   616                        ; only. Please read the text below preceding the initialization routines for more detail!
   617                        ;
   618 00:F96A: 85 DE        NMI_VECTOR      STA     AREG            ;Save A Reg
   619 00:F96C: 86 DD                        STX     XREG            ;Save X Reg
   620 00:F96E: 84 DC                        STY     YREG            ;Save Y Reg
   621 00:F970: 68                           PLA                     ;Get Processor Status
   622 00:F971: 85 DA                        STA     PREG            ;Save in PROCESSOR STATUS preset/result
   623 00:F973: BA                           TSX                     ;Get Stack pointer
   624 00:F974: 86 DB                        STX     SREG            ;Save STACK POINTER
   625 00:F976: 68                           PLA                     ;Pull RETURN address from STACK
   626 00:F977: 85 D8                        STA     PCL             ;Store Low byte
   627 00:F979: 68                           PLA                     ;Pull high byte
   628 00:F97A: 85 D9                        STA     PCH             ;Store High byte
   629                        ;
   630 00:F97C: 9C 85 FE                     STZ     UART_IMR        ;Disable ALL interrupts from UART
   631 00:F97F: AD 81 FE                     LDA     UART_STATUS     ;Get UART Status Register
   632 00:F982: 85 E6                        STA     UART_SRT        ;Save it in Page 0
   633 00:F984: AD 85 FE                     LDA     UART_ISR        ;Get UART Interrupt Status Register
   634 00:F987: 85 E5                        STA     UART_IRT        ;Save it in Page 0
   635                        ;
   636                        ;The following line of code can be considered optional. It's a work-around for an anomaly of
   637                        ; the W65C02 which might toggle the X1/X16 Test Mode Register. In over a year of running
   638                        ; 3- C02 Pocket SBCs, this problem has not yet been encountered, so it is commented out.
   639                        ;
   640                        ;               LDA     UART_CLKTEST    ;Toggle the X1/X16 Test mode
   641                        ;
   642 00:F989: A2 08                        LDX     #$08            ;Set count for 8
   643 00:F98B: 74 DE        PAN_LP1         STZ     ICNT-1,X        ;Clear console I/O pointers/Status
   644 00:F98D: CA                           DEX                     ;Decrement index
   645 00:F98E: D0 FB                        BNE     PAN_LP1         ;Branch back till done
   646                        ;
   647 00:F990: 20 9C FF                     JSR     INIT_PG03       ;Xfer default Vectors/HW Config to $0300
   648 00:F993: 20 99 F9                     JSR     INIT_IO         ;Reset and Init the UART for Console
   649 00:F996: 6C 06 03     DO_NMI0         JMP     (NMIRTVEC0)     ;Jump to NMI Return Vector (Monitor Warm Start)
   650                        ;
   651                        ;**************************************************************************************************
   652                        ;Initializing the SCC2691 UART as a Console.
   653                        ;An anomaly in the W65C02 processor requires a different approach in programming the SCC2691
   654                        ; for proper setup/operation. The SCC2691 uses two Mode Registers which are accessed at the same
   655                        ; register in sequence. There is a command that Resets the Mode Register pointer (to MR1) that is
   656                        ; issued first. Then MR1 is loaded followed by MR2. The problem with the W65C02 is a false read of
   657                        ; the register when using indexed addressing (i.e., STA UART_REGISTER,X). This results in the Mode
   658                        ; Register pointer being moved to the second register, so the write to MR1 never happens. While
   659                        ; the indexed list works fine for all other register functions/commands, the loading of the
   660                        ; Mode Registers need to be handled separately.
   661                        ;
   662                        ;NOTE: the W65C02 will function normally "if" a page boundary is crossed as part of the STA
   663                        ; (i.e., STA $FDFF,X) where the value of the X Register is high enough to cross the page boundary.
   664                        ; Programming in this manner would be confusing and require modification if the base I/O address
   665                        ; is changed for a different hardware I/O map.
  Tue May 18 2021 22:26                                                                                                    Page 17


   666                        ;
   667                        ;The same anomaly in the W65C02 also creates a false read when sending any command to the Command
   668                        ; Register (assuming indexed addressing), as the read function of that hardware register is the
   669                        ; BRG Test Register. This can result in a different baud rate being selected, depending on the
   670                        ; baud rate tables listed in the Datasheet. When using either 19.2K or 38.4K baud rate, the tables
   671                        ; are the same for both normal and BRG Test mode, so the UART will operate normally. Changing to
   672                        ; a different baud rate via the BRG Test Register requires additional coding to use any of the
   673                        ; extended baud rates.
   674                        ;
   675                        ;There are two routines called to setup the 2691 UART:
   676                        ;
   677                        ;The first routine is a RESET of the UART.
   678                        ; It issues the following sequence of commands:
   679                        ;  1- Send a Power On command to the ACR
   680                        ;  2- Reset Break Change Interrupt
   681                        ;  3- Reset Receiver
   682                        ;  4- Reset Transmitter
   683                        ;  5- Reset All errors
   684                        ;
   685                        ;The second routine initializes the 2691 UART for operation. It uses two tables of data; one for
   686                        ; the register offset and the other for the register data. The table for register offsets is
   687                        ; maintained in ROM. The table for register data is copied to page $03, making it soft data. If
   688                        ; needed, operating parameters can be altered and the UART re-initialized via the ROM routine.
   689                        ;
   690                        ; Updated CO2BIOS version to Ver. 2.01 in April 2018. Shorten INIT_IO routine by moving up the
   691                        ; INIT_2691 to remove the "JMP INIT_2691", saves a few bytes and some clock cycles.
   692                        ;
   693                        ; Updated C02BIOS version to 2.05 provides for selecting extended baud rates. This is more of a
   694                        ; band-aid approach for the SCC2691 as the BRG Test register needs to be accessed (READ) to
   695                        ; toggle to the extended rates. To ensure this can be accomplished by soft config data only,
   696                        ; a modification to the MR2 data is implemented. Bit 7 is generally a zero (0) as the SCC2691
   697                        ; is configured for console use only. By setting Bit 7 to one (1), the BIOS config routine
   698                        ; will determine if extended baud rates are requested. It also requires that Bit 7 is masked
   699                        ; off when setting up the SCC2691 during power up, reset or a software config change.
   700                        ;
   701                        ; The BIOS init routine also uses MATCH bits 4,5 to track the status of the extended bit rates.
   702                        ; Bit 5 is used to show that the current config requires the BRG Test register to be toggled to
   703                        ; the extended bit rates. Bit 4 shows the current state of the BRG Test register.
   704                        ; Bit 5 is set to 1 if extended baud are required.
   705                        ; Bit 4 is set to 1 is extended baud rates are active.
   706                        ; NOTE: changing bits 4,5 should be avoided. The Init routine should only be used when extended
   707                        ; baud rates are required or any change is required.
   708                        ;
   709                        ; NOTE: The C02Monitor will also sense the active EBR status via Bit 4 when a Reset or Zero RAM
   710                        ; is selected. This is required as a Reset or Zero RAM will clear out the MATCH flags bits and
   711                        ; the status of the BRG Test register will be lost.
   712                        ;
   713                        ; Also realize that a hardware reset will rest the SCC2691 and the default ROM config will be
   714                        ; initialized. Also note that the Panic routine invoked by a NMI trigger will also reset the
   715                        ; UART to the default ROM config, but does not inquire or change any of the config data. It only
   716                        ; calls the init routines, which will track the UART operating mode and handle as required.
   717                        ;
   718 00:F999: 20 DA F9     INIT_IO         JSR     RESET_2691      ;Power-Up Reset of SCC2691 UART
   719 00:F99C: A9 64                        LDA     #DF_TICKS       ;Get divider for jiffy clock for 1-second
   720 00:F99E: 85 E7                        STA     TICKS           ;Preload TICK count
   721                        ;
   722                        ;This routine sets the initial operating mode of the UART
   723                        ;
   724 00:F9A0: 78           INIT_2691       SEI                     ;Disable interrupts
   725 00:F9A1: A2 0D                        LDX     #INIT_DATAE-INIT_DATA ;Get the Init byte count
   726 00:F9A3: BD 1F 03     2691_INT        LDA     LOAD_2691-1,X   ;Get Data for 2691 Register
   727 00:F9A6: BC E4 FE                     LDY     INIT_OFFSET-1,X ;Get Offset for 2691 Register
   728 00:F9A9: 99 80 FE                     STA     SCC2691_BASE,Y  ;Store Data to selected register
  Tue May 18 2021 22:26                                                                                                    Page 18


   729 00:F9AC: CA                           DEX                     ;Decrement count
   730 00:F9AD: D0 F4                        BNE     2691_INT        ;Loop back until all registers are loaded
   731                        ;
   732                        ; Mode Register is reset to MR1 by above INIT_2691
   733                        ; MR2 data Bit 7 is used for extended baud rates... should always be "0" for normal config!
   734                        ;
   735 00:F9AF: AD 2D 03                     LDA     LOAD_2691+13    ;Get Mode Register 1 Data
   736 00:F9B2: 8D 80 FE                     STA     UART_MODEREG    ;Send to 2691
   737 00:F9B5: AD 2E 03                     LDA     LOAD_2691+14    ;Get Mode Register 2 Data
   738 00:F9B8: 30 0F                        BMI     SET_EBR         ;If Bit7 set, branch
   739 00:F9BA: 8D 80 FE                     STA     UART_MODEREG    ;Else, Send MR2 data to 2691
   740 00:F9BD: 57 FF                        RMB5    MATCH           ;Turn off EBR Bit 5 in Match flag
   741 00:F9BF: 4F FF 05                     BBR4    MATCH,NO_EBR    ;If EBR off, no need to toggle off
   742 00:F9C2: 2C 82 FE                     BIT     UART_BRGTST     ;Toggle BRG Test register (read)
   743 00:F9C5: 47 FF                        RMB4    MATCH           ;Turn off EBR active bit
   744 00:F9C7: 58           NO_EBR          CLI                     ;Enable interrupts
   745 00:F9C8: 60                           RTS                     ;Return to caller
   746                        ;
   747 00:F9C9: D7 FF        SET_EBR         SMB5    MATCH           ;Set EBR bit in Match flag
   748 00:F9CB: 29 7F                        AND     #$7F            ;Mask off Bit 7 for EBR config
   749 00:F9CD: 8D 80 FE                     STA     UART_MODEREG    ;Else, Send MR2 to 2691
   750                        ;
   751 00:F9D0: CF FF 05                     BBS4    MATCH,SKIP_BRG  ;If BRG Test toggled, skip
   752 00:F9D3: 2C 82 FE                     BIT     UART_BRGTST     ;Else, toggle BRG Test register (read)
   753 00:F9D6: C7 FF                        SMB4    MATCH           ;Set Bit 4 fpr BRG Test toggled
   754 00:F9D8: 58           SKIP_BRG        CLI                     ;Enables interrupts
   755 00:F9D9: 60                           RTS                     ;Return to caller
   756                        ;
   757                        ;This routine does a Reset of the SCC2691
   758                        ;
   759 00:F9DA: A9 08        RESET_2691      LDA     #%00001000      ;Get Power On mask
   760 00:F9DC: 8D 84 FE                     STA     UART_AUXCR      ;Send to 2691 (ensure it's on)
   761                        ;
   762 00:F9DF: A2 04                        LDX     #UART_RDATAE-UART_RDATA1 ;Get the Reset commands byte count
   763 00:F9E1: BD E0 FE     UART_RES1       LDA     UART_RDATA1-1,X ;Get Reset commands
   764 00:F9E4: 8D 82 FE                     STA     UART_COMMAND    ;Send to UART CR
   765 00:F9E7: CA                           DEX                     ;Decrement the command list index
   766 00:F9E8: D0 F7                        BNE     UART_RES1       ;Loop back until all are sent
   767 00:F9EA: 60                           RTS                     ;Return to caller
   768                        ;
   769                        ;Core routines that are used to detect and configure additional I/O devices.
   770                        ; The I/O adapter supported by the 3.0x Release of C02BIOS contains two I/O devices:
   771                        ; - A Maxim DS1511 Realtime Clock
   772                        ; - A Compact Flash Card configured in True IDE Mode (per SanDisk documentation)
   773                        ;
   774                        ; The first routine is to detect the DS1511 RTC. This is done by reading the NVRAM section
   775                        ; and testing for the Signature at the end of NVRAM. Obviously, this is something that needs
   776                        ; to be setup before it can be detected. There is a separate utility that is used to configure
   777                        ; the RTC for Time/Date, NVRAM usage and the two-byte signature. This utility must be run first
   778                        ; to properly configure the RTC. Once completed, the BIOS will detect the RTC and read the
   779                        ; Date and Time to set the BIOS variables accordingly.
   780                        ;
   781                        ; The second routine is to detect the Compact Flash device. This can be a bit tricky...
   782                        ; as reading the Status register may or may not be valid depending on the individual CF Card
   783                        ; and it's internal timing to become ready after a hardware reset.
   784                        ; Assuming the CF Card is present and attempting to execute a Reset or Self Diagnostic command
   785                        ; could likely get stuck in a loop waiting for a bit change in the Status register.
   786                        ; From testing, the most reliable method is trying to load the Status register and comparing it
   787                        ; against the Phantom Address read when there is no device (or memory) at the decoded location.
   788                        ; As the configured I/O Page is $FE, this value will be returned if a CF Card is not present.
   789                        ; Also note that there is no valid condition of the Status register where all but the lowest
   790                        ; order bits would be active. If a read returns other than $FE, additional tests are done to
   791                        ; detect the CF Card and initialize it. Once completed, the ISR for the IDE controller is added
  Tue May 18 2021 22:26                                                                                                    Page 19


   792                        ; to the interrupt handler via a reserved interrupt vector.
   793                        ;
   794                        ;This routine detects the DS1511 RTC.
   795                        ; While there's really no standard method to detect the RTC, the NVRAM is initialized
   796                        ; during the configuration for Date, Time, etc. The last two bytes of the NVRAM will
   797                        ; contain a 2-byte signature of "KM", in honor of the author ;-)
   798                        ; If the signature is found, the INIT_RTC routine is called, which will setup the
   799                        ; RTC variables in Page Zero, where the correct Date and Time will be maintained.
   800                        ;
   801                        DETECT_RTC
   802 00:F9EB: A2 FE                        LDX     #$FE            ;Load NVRAM Offset
   803 00:F9ED: 8E 70 FE                     STX     RTC_RAM_ADDR    ;Set index to start of signature
   804 00:F9F0: AD 73 FE                     LDA     RTC_RAM_DATA    ;Get NVRAM Data
   805 00:F9F3: C9 4B                        CMP     #"K"            ;Check for "M"
   806 00:F9F5: D0 0B                        BNE     SET_EPOCH       ;If not found, set EPOCH as default
   807 00:F9F7: E8                           INX                     ;Increment Offset
   808 00:F9F8: 8E 70 FE                     STX     RTC_RAM_ADDR    ;Set index to start of signature
   809 00:F9FB: AD 73 FE                     LDA     RTC_RAM_DATA    ;Get NVRAM Data
   810 00:F9FE: C9 4D                        CMP     #"M"            ;Check for "K"
   811 00:FA00: F0 0B                        BEQ     FOUND_RTC       ;If good, go Init RTC and exit
   812                        ;
   813                        ;If RTC not found, preload Date variables as EPOCH time (Thursday, 1st January, 1970)
   814                        ; Note: Time variables default to zero from a cold start.
   815                        ;
   816                        SET_EPOCH
   817 00:FA02: A2 03                        LDX     #$03            ;Get Index of 3
   818 00:FA04: BD 19 FD     EPOCH_LP        LDA     EPOCH-1,X       ;Get Preload data
   819 00:FA07: 95 EA                        STA     DAY_DATE-1,X    ;Store in RTC variables
   820 00:FA09: CA                           DEX                     ;Decrement Index
   821 00:FA0A: D0 F8                        BNE     EPOCH_LP        ;Loop back until done
   822 00:FA0C: 60                           RTS                     ;Return, no RTC found
   823                        ;
   824                        FOUND_RTC
   825 00:FA0D: E8                           INX                     ;Increment Index ($FF -> $00)
   826 00:FA0E: BD B4 FF     FOUND_RTC_LP    LDA     RTC_MSG,X       ;Get BIOS init msg
   827 00:FA11: F0 06                        BEQ     INIT_RTC        ;If zero, msg done, go Init RTC
   828 00:FA13: 20 19 F8                     JSR     CHROUT          ;Send to console
   829 00:FA16: E8                           INX                     ;Increment Index
   830 00:FA17: 80 F5                        BRA     FOUND_RTC_LP    ;Loop back until done
   831                        ;
   832                        ;This routine reads the BCD registers from the DS1511 RTC, converts BCD to Binary and loads the
   833                        ; BIOS RTC variables. Note that some of the variables are shared to conserve Page Zero space.
   834                        ; Note: Buffer area used for init is also used by C02 Monitor for hex input and code conversion,
   835                        ; but is initialized as needed before usage, so we can clobber it here when configuring the BIOS.
   836                        ;
   837                        ;As there is a period of time required to get the data from the RTC, convert from BCD, then format
   838                        ; into the Page Zero locations used, we need to manage the existing Timer/Counter status to ensure
   839                        ; the best accuracy in time once the routine finishes. In short, the best we can manage accuracy
   840                        ; is within one second, as the RTC internal update of the registers we read are halted.
   841                        ;
   842                        ;To help minimize the timing transfer, we first set the tick count to it's maximum value of $FF
   843                        ; to ensure that the software RTC values are not updated during loading from the hardware RTC.
   844                        ; The time to detect and load the current time/date is less than 5000 clock cycles. However, the
   845                        ; overall accuracy can only be within one second. After the RTC values are transferred, the
   846                        ; software RTC tick count will be loaded with a minimal count to ensure the time is closer to
   847                        ; what the hardware RTC is set for.
   848                        ;
   849                        INIT_RTC
   850 00:FA19: A2 FF                        LDX     #$FF            ;Get $FF for tick count (2)
   851 00:FA1B: 86 E7                        STX     TICKS           ;Set the Tick count (3)
   852 00:FA1D: E8                           INX                     ;Increment Index ($FF -> $00) (2)
   853 00:FA1E: A9 80                        LDA     #%10000000      ;Get TE Bit mask (2)
   854 00:FA20: 1C 6F FE                     TRB     RTC_CONTROL_B   ;Turn off TE Bit to disable update (6)
  Tue May 18 2021 22:26                                                                                                    Page 20


   855                        ;
   856                        RTC_LOAD_LOOP
   857 00:FA23: BD 60 FE                     LDA     RTC_SECONDS,X   ;Get Data from RTC (4)
   858 00:FA26: 95 A0                        STA     BUFF_PG0,X      ;Store into RAM (4)
   859 00:FA28: E8                           INX                     ;Increment register count (2)
   860 00:FA29: E0 08                        CPX     #$08            ;Check for all 8 moved (2)
   861 00:FA2B: D0 F6                        BNE     RTC_LOAD_LOOP   :Loop back until all registers are read (2/3)
   862                        ;
   863 00:FA2D: A9 80                        LDA     #%10000000      ;Get TE Bit mask (2)
   864 00:FA2F: 0C 6F FE                     TSB     RTC_CONTROL_B   ;Turn on TE Bit to enable update (6)
   865                        ;
   866                        ;Now convert BCD to Binary (X reg = $08)
   867                        ;
   868 00:FA32: B5 9F        BCD_LOOP        LDA     BUFF_PG0-1,X    ;Get BCD Data from Buffer (4)
   869                        ;
   870 00:FA34: A8                           TAY                     ;Save BCD value (2)
   871 00:FA35: 29 F0                        AND     #$F0            ;Mask for high nibble (2)
   872 00:FA37: 4A                           LSR     A               ;Shift right (/2) (2)
   873 00:FA38: 85 EE                        STA     RTC_TEMP        ;Save in temp (3)
   874 00:FA3A: 4A                           LSR     A               ;Shift over (/4) (2)
   875 00:FA3B: 4A                           LSR     A               ;Shift over (/8) -Carry is clear (2)
   876 00:FA3C: 65 EE                        ADC     RTC_TEMP        ;Add to temp (3)
   877 00:FA3E: 85 EE                        STA     RTC_TEMP        ;Store it back (3)
   878 00:FA40: 98                           TYA                     ;Get BCD back (2)
   879 00:FA41: 29 0F                        AND     #$0F            ;Mask for low nibble (2)
   880 00:FA43: 65 EE                        ADC     RTC_TEMP        ;Add temp (upper converted nibble) (3)
   881                        ;
   882 00:FA45: 95 9F                        STA     BUFF_PG0-1,X    ;Save Binary Data back to Buffer (4)
   883 00:FA47: CA                           DEX                     ;Decrement Index (2)
   884 00:FA48: D0 E8                        BNE     BCD_LOOP        ;Loop back until done (2/3)
   885                        ;
   886                        ;Now take the binary data for the RTC, and format it for the BIOS RTC variables:
   887                        ; Seconds, Minutes and Hours are fine as they are, so they simply move over.
   888                        ; The Day (of the week) and the Date (of the Month) are combined into a single variable.
   889                        ; Note: Day (of the week) is variable and decided by the user. In honor of my past, I'm
   890                        ; declaring Saturday as the 1st day of the week, an IBM tradition.
   891                        ; The Month is also kept in the upper 4 bits of the Century variable.
   892                        ; Note: The Century and Year are two BCD digits each. As 4 BCD digits, these need to be
   893                        ; converted to a 16-bit binary integer. Only 12-bits are needed, which frees the upper
   894                        ; 4-bits to be used for the Month.
   895                        ;
   896 00:FA4A: A5 A3                        LDA     BUFF_PG0+3      ;Get the Day count (3)
   897 00:FA4C: 0A                           ASL     A               ;Shift to upper 3 bits (2)
   898 00:FA4D: 0A                           ASL     A               ; (2)
   899 00:FA4E: 0A                           ASL     A               ; (2)
   900 00:FA4F: 0A                           ASL     A               ; (2)
   901 00:FA50: 0A                           ASL     A               ; (2)
   902 00:FA51: 05 A4                        ORA     BUFF_PG0+4      ;OR in the Date variable (3)
   903 00:FA53: 85 A3                        STA     BUFF_PG0+3      ;Save to the Day variable (3)
   904                        ;
   905 00:FA55: A5 A5                        LDA     BUFF_PG0+5      ;Get the Month variable (3)
   906 00:FA57: 0A                           ASL     A               ;Shift to upper 4 bits (2)
   907 00:FA58: 0A                           ASL     A               ; (2)
   908 00:FA59: 0A                           ASL     A               ; (2)
   909 00:FA5A: 0A                           ASL     A               ; (2)
   910 00:FA5B: 85 A4                        STA     BUFF_PG0+4      ;Save it (lower nibble = 0) (3)
   911                        ;
   912                        ; The easist way to create the 16-bit Year is to take the high binary digit
   913                        ; and multiply it by 100, then add the low binary digit. We do the multiply
   914                        ; by adding it to the 16-bit variable 100 times ;-)
   915                        ;
   916 00:FA5D: A2 64                        LDX     #100            ;Get the index count for 100 (2)
   917 00:FA5F: 64 A8                        STZ     BUFF_PG0+8      ;Zero Temp low byte (3)
  Tue May 18 2021 22:26                                                                                                    Page 21


   918 00:FA61: 64 A9                        STZ     BUFF_PG0+9      ;Zero Temp high byte (3)
   919                        ;
   920 00:FA63: A5 A7        RTC_ADD         LDA     BUFF_PG0+7      ;Get Year value (3)
   921 00:FA65: 20 88 FA                     JSR     ADD_16          ;Go add it... (6)
   922 00:FA68: CA                           DEX                     ;Decrement count (2)
   923 00:FA69: D0 F8                        BNE     RTC_ADD         ;Loop back until done (2/3)
   924                        ;
   925 00:FA6B: A5 A6                        LDA     BUFF_PG0+6      ;Get Year lower digit (3)
   926 00:FA6D: 20 88 FA                     JSR     ADD_16          ;Add it into the Temp (6)
   927                        ;
   928 00:FA70: A5 A8                        LDA     BUFF_PG0+8      ;Get lower byte for year (3)
   929 00:FA72: 85 A5                        STA     BUFF_PG0+5      ;Save it (3)
   930 00:FA74: A5 A9                        LDA     BUFF_PG0+9      ;Get upper byte for year (3)
   931 00:FA76: 05 A4                        ORA     BUFF_PG0+4      ;OR in Month (upper 4 bits) (3)
   932 00:FA78: 85 A4                        STA     BUFF_PG0+4      ;Save it (3)
   933                        ;
   934                        ; Now transfer the buffer contents to the Page Zero RTC variables
   935                        ;
   936 00:FA7A: A2 06                        LDX     #$06            ;Set count for 6 (2)
   937 00:FA7C: B5 9F        RTC_XFER        LDA     BUFF_PG0-1,X    ;Get the buffer data (4)
   938 00:FA7E: 95 E7                        STA     SECS-1,X        ;Save to RTC variables (4)
   939 00:FA80: CA                           DEX                     ;Decrement count (2)
   940 00:FA81: D0 F9                        BNE     RTC_XFER        ;Loop back till done (2/3)
   941 00:FA83: A9 10                        LDA     #$10            ;Get a minimal tick count (2)
   942 00:FA85: 85 E7                        STA     TICKS           ;Update RTC tick count (3)
   943 00:FA87: 60                           RTS                     ;Return to caller (6)
   944                        ;
   945 00:FA88: 18           ADD_16          CLC                     ;Clear carry flag (2)
   946 00:FA89: 65 A8                        ADC     BUFF_PG0+8      ;Add to Temp low byte (3)
   947 00:FA8B: 85 A8                        STA     BUFF_PG0+8      ;And save itm (3)
   948 00:FA8D: A5 A9                        LDA     BUFF_PG0+9      ;Get high byte (3)
   949 00:FA8F: 69 00                        ADC     #$00            ;Add carry to Temp high byte (2)
   950 00:FA91: 85 A9                        STA     BUFF_PG0+9      ;And save it (3)
   951 00:FA93: 60                           RTS                     ;Return to caller (6)
   952                        ;
   953                        ;This routine detects the IDE Port
   954                        ; To detect the IDE controller (Compact Flash Card), it can be a bit tricky. It takes
   955                        ; a fairly long time from a physical Reset of the CF-Card before the Busy flag goes off.
   956                        ; During this time, any commands sent to the IDE controller will fail. As I like to say,
   957                        ; "timing is everything". After quite a bit of testing, the easy way to detect the IDE
   958                        ; controller present is to load the IDE_STATUS register. If a CF-Card is not plugged in,
   959                        ; The A Reg will show a phantom address of $FE (high order IDE hardware address) and
   960                        ; any initialization can be bypassed.
   961                        ;
   962                        ; If the IDE controller is present, the IDE_STATUS read may be invalid, so it's necassary
   963                        ; to test the BUSY flag of the status register. Once the IDE Controller is no longer busy,
   964                        ; the controller can be initialized. This does create an obvious pause in the startup, but
   965                        ; ensures that the IDE controller can be reliably detected and initialized at boot time.
   966                        ;
   967                        ; A change has been made in the IDE_SETUP routine. As the interrupts were disabled on the
   968                        ; CF Card initially, it needs to be re-enabled before the setup is completed. The short
   969                        ; bit of code that does this is also called by the Reset-Diag function (JMP $FF00).
   970                        ;
   971                        DETECT_IDE
   972 00:FA94: AD 7F FE                     LDA     IDE_STATUS      ;Get the IDE Status
   973 00:FA97: C9 FE                        CMP     #$FE            ;Check for an empty (phantom) address
   974 00:FA99: D0 01                        BNE     IDE_INIT        ;If not #$FE, try to Init the IDE controller
   975 00:FA9B: 60           NO_IDE          RTS                     ;Return to caller, no IDE controller found
   976                        ;
   977                        ;Init the IDE controller
   978                        ;
   979 00:FA9C: 20 37 F9     IDE_INIT        JSR     TST_IDE_BUSY    ;Check/wait if IDE is still busy after HW Reset
   980 00:FA9F: 20 33 FB                     JSR     IDE_RESET       ;Reset the IDE Controller
  Tue May 18 2021 22:26                                                                                                    Page 22


   981 00:FAA2: C9 50                        CMP     #$50            ;Check for $50 on A reg (drive ready)
   982 00:FAA4: D0 F5                        BNE     NO_IDE          ;If not, no IDE present
   983 00:FAA6: E0 00                        CPX     #$00            ;X Reg will show #$00 if successful
   984 00:FAA8: D0 F1                        BNE     NO_IDE          ;If failed, exit
   985                        ;
   986 00:FAAA: 20 37 FB                     JSR     IDE_DIAG        ;Run the self diagnostic
   987 00:FAAD: C9 50                        CMP     #$50            ;Check for $50 on A reg (drive ready)
   988 00:FAAF: D0 EA                        BNE     NO_IDE          ;If not, no IDE present
   989 00:FAB1: E0 01                        CPX     #$01            ;X Reg will show #$01 if diags successful
   990 00:FAB3: D0 E6                        BNE     NO_IDE          ;If failed, exit
   991                        ;
   992                        ; IDE Controller found and passed initial self diagnostics test.
   993                        ; Send IDE Found message to terminal
   994                        ;
   995 00:FAB5: A2 00                        LDX     #$00            ;Zero X Reg for index to msg
   996 00:FAB7: BD C0 FF     IDE_MSG_LP      LDA     IDE_MSG,X       ;Get BIOS init msg
   997 00:FABA: F0 06                        BEQ     IDE_SETUP       ;If zero, msg done, go setup IDE
   998 00:FABC: 20 19 F8                     JSR     CHROUT          ;Send to console
   999 00:FABF: E8                           INX                     ;Increment Index
  1000 00:FAC0: 80 F5                        BRA     IDE_MSG_LP      ;Loop back until done
  1001                        ;
  1002                        ;IDE Setup
  1003                        ; This will insert the IDE Controller ISR into the Interrupt Handler chain.
  1004                        ;
  1005                        ; First, disable interrupts, capture the current IRQ exit vector address
  1006                        ; and save it to the first Insert Vector. Second, load the IDE ISR routine
  1007                        ; address and store it to the main IRQ exit vector, then re-enable interrupts.
  1008                        ;
  1009                        ; Second, this routine will execute an Identify IDE command to load the Soft
  1010                        ; Config Data for the maximum LBA Count accessible by the current IDE device
  1011                        ;
  1012                        ; Note: Two routines are below, use only one! They allow a choice to insert
  1013                        ; the IDE ISR before or after the main Interrupt Handler. By default, loading
  1014                        ; is after the main ISR. Despite the high speed of the data transfers, the
  1015                        ; interrupt rate is not that high.
  1016                        ;
  1017 00:FAC2: 78           IDE_SETUP       SEI                     ;Disable interrupts
  1018                        ;
  1019                        ; To load the IDE ISR Handler AFTER the existing UART ISR Handler:
  1020                        ;
  1021                        ;                LDA     IRQRTVEC0       ;Get low byte of IRQ Exit
  1022                        ;                LDY     IRQRTVEC0+1     ;Get high byte of IRQ Exit
  1023                        ;                STA     VECINSRT0       ;Save low byte of IRQ Exit
  1024                        ;                STY     VECINSRT0+1     ;Save high byte of IRQ Exit
  1025                        ;
  1026                        ;                LDA     #<INTERUPT1     ;Get low byte of IDE ISR
  1027                        ;                LDY     #>INTERUPT1     ;Get high byte of IDE ISR
  1028                        ;                STA     IRQRTVEC0       ;Save low byte of IRQ Exit
  1029                        ;                STY     IRQRTVEC0+1     ;Save high byte of IRQ Exit
  1030                        ;
  1031                        ; To load the IDE ISR Handler BEFORE the existing UART ISR Handler:
  1032                        ;
  1033 00:FAC3: AD 04 03                     LDA     IRQVEC0         ;Get low byte of IRQ Exit
  1034 00:FAC6: AC 05 03                     LDY     IRQVEC0+1       ;Get high byte of IRQ Exit
  1035 00:FAC9: 8D 10 03                     STA     VECINSRT0       ;Save low byte of IRQ Exit
  1036 00:FACC: 8C 11 03                     STY     VECINSRT0+1     ;Save high byte of IRQ Exit
  1037                        ;
  1038 00:FACF: A9 60                        LDA     #<INTERUPT1     ;Get low byte of IDE ISR
  1039 00:FAD1: A0 FB                        LDY     #>INTERUPT1     ;Get high byte of IDE ISR
  1040 00:FAD3: 8D 04 03                     STA     IRQVEC0         ;Save low byte of IRQ Exit
  1041 00:FAD6: 8C 05 03                     STY     IRQVEC0+1       ;Save high byte of IRQ Exit
  1042                        ;
  1043 00:FAD9: 58                           CLI                     ;Enable interrupts
  Tue May 18 2021 22:26                                                                                                    Page 23


  1044                        ;
  1045 00:FADA: 20 57 FB                     JSR     IDE_EN_IRQ      ;Enable CF-Card interrupt
  1046                        ;
  1047                        ; Drop into Identify Drive routine
  1048                        ;
  1049                        IDE_IDENTIFY                            ;Identify Device
  1050                        ;
  1051                        ; This requests a 512-byte block of data that shows capabilities, CHS (not used), LBA Count, etc.
  1052                        ; The format is similar to Read LBA, except no LBA parameter is required. It effectively works as
  1053                        ; a Read Block operation and the data transferred is handled by the ISR for Read Block.
  1054                        ; NOTE: The Identify Command is coded to load into LBA_BUFFER (address $0600).
  1055                        ;
  1056 00:FADD: A9 00                        LDA     #<LBA_BUFFER    ;Set Address low byte
  1057 00:FADF: A0 06                        LDY     #>LBA_BUFFER    ;Set Address high byte
  1058 00:FAE1: A2 01                        LDX     #$01            ;Set Block count
  1059 00:FAE3: 20 F8 F8                     JSR     IDE_SET_ADDRESS ;Set Xfer address and block count
  1060                        ;
  1061 00:FAE6: 20 37 F9                     JSR     TST_IDE_BUSY    ;Wait for IDE Controller not busy
  1062 00:FAE9: 20 1F F9                     JSR     IDE_SET_PARMS2  ;Setup required parameters (no LBA parameter)
  1063                        ;
  1064 00:FAEC: A9 EC                        LDA     #$EC            ;Get Identify Command
  1065 00:FAEE: 20 73 F8                     JSR     IDENT_READ      ;Use READ_LBA routine to finish read
  1066                        ;
  1067                        ; Check for LBA mode supported by looking at Word 49 offset bit 9 active
  1068                        ;
  1069 00:FAF1: AD 63 06                     LDA     LBA_BUFFER+$63  ;Get Capabilities data (bit 9 of Word 49)
  1070 00:FAF4: 4A                           LSR     A               ;Shift DMA bit to Carry
  1071 00:FAF5: 4A                           LSR     A               ;Shift LBA bit to Carry
  1072 00:FAF6: B0 0D                        BCS     LBA_VALID       ;If active, finish setup
  1073                        ;
  1074                        ; Else, send an error messsage to console for LBA mode unsupported
  1075                        ;
  1076 00:FAF8: A2 00                        LDX     #$00            ;Set index to zero
  1077 00:FAFA: BD 1D FD     NO_LBA_LP       LDA     NO_LBA,X        ;Get LBA unsupported message
  1078 00:FAFD: F0 9C                        BEQ     NO_IDE          ;If done, exit
  1079 00:FAFF: 20 19 F8                     JSR     CHROUT          ;Send to console
  1080 00:FB02: E8                           INX                     ;Increment index
  1081 00:FB03: 80 F5                        BRA     NO_LBA_LP       ;Loop back until done
  1082                        ;
  1083                        ; Identify data loaded in buffer. Now extract LBA count and store to Soft Config Data for usage
  1084                        ; by access routines (Read/Write/Verify). Four bytes are used and the format from the Identify
  1085                        ; Command are Low-order Word / High-order Word, where each word is in Big Endian. We will store
  1086                        ; the LBA count as Little Endian, Low-order Word / High-order Word.
  1087                        ; The offset from the buffer are Words 60-61 (decimal).
  1088                        ;
  1089                        ; A table is used to index the offset of bytes to move into consecutive soft data.
  1090                        ;
  1091 00:FB05: A2 04        LBA_VALID       LDX     #$04            ;Set count for 4 bytes
  1092 00:FB07: BC CB FF     LBA_SIZE        LDY     LBA_OFFSET-1,X  ;Get Offset to LBA count
  1093 00:FB0A: B1 F7                        LDA     (LBA_ADDR_LOW),Y        ;Load LBA Data
  1094 00:FB0C: 9D 2F 03                     STA     LOAD_IDE-1,X    ;Store to Soft Config Data
  1095 00:FB0F: CA                           DEX                     ;Decrement count
  1096 00:FB10: D0 F5                        BNE     LBA_SIZE        ;Loop back until done
  1097 00:FB12: 60                           RTS                     ;Return to caller
  1098                        ;
  1099                        IDE_RES_DIAG                            ;Do a Reset and run Diagnostics
  1100 00:FB13: 20 33 FB                     JSR     IDE_RESET       ;Call IDE_RESET (set LBA mode)
  1101 00:FB16: 20 37 FB                     JSR     IDE_DIAG        ;Call IDE Self Diagnostics
  1102 00:FB19: 20 57 FB                     JSR     IDE_EN_IRQ      ;Re-enable CF-Card interrupt
  1103                        ;
  1104                        ; Drop into Get Status routine
  1105                        ;
  1106                        IDE_GET_STATUS                          ;Get Status / Extended error code from the IDE controller
  Tue May 18 2021 22:26                                                                                                    Page 24


  1107                        ;
  1108                        ; This routine gets the current status of the IDE Controller and can be issued at any time.
  1109                        ; It does not rely on any interrupt capability as it's a simple command issue and reads the
  1110                        ; status from the IDE Controller.
  1111                        ;
  1112                        ; Note: This routine should be invoked whenever an Error has occurred, as it returns the
  1113                        ; extended error code caused by the previous failed command. Error code details are listed
  1114                        ; in the SanDisk Documentation.
  1115                        ;
  1116 00:FB1C: 20 37 F9                     JSR     TST_IDE_BUSY    ;Wait for IDE Controller not busy
  1117 00:FB1F: A9 E0                        LDA     #%11100000      ;Set Drive 0, LBA mode and LBA 27-24 as 0 (lower 4 bits)
  1118 00:FB21: 8D 7E FE                     STA     IDE_DRV_HEAD    ;Send to IDE Controller
  1119                        ;
  1120 00:FB24: A9 03                        LDA     #$03            ;Get Request Sense command
  1121 00:FB26: 8D 7F FE                     STA     IDE_COMMAND     ;Send command to IDE Controller
  1122                        ;
  1123 00:FB29: 20 2F F9                     JSR     TST_IDE_RDY     ;Wait for IDE Controller ready
  1124 00:FB2C: AD 7F FE                     LDA     IDE_STATUS      ;Get IDE Status
  1125 00:FB2F: AE 79 FE                     LDX     IDE_ERROR       ;Get any extended error code
  1126 00:FB32: 60                           RTS                     ;Return to Caller
  1127                        ;
  1128                        IDE_RESET                               ;A Recalibrate Command
  1129                        ;
  1130                        ;According to Sandisk, the Recalibrate command is essentially a NOP,
  1131                        ; as there are no moving parts and nothing to calibrate. However, there is
  1132                        ; the option of setting LBA mode by setting bit 6 in the mask for DRV-HEAD
  1133                        ; To send this command, a seperate routine is used to save ROM space.
  1134                        ;
  1135 00:FB33: A9 10                        LDA     #$10            ;Get Reset Command
  1136 00:FB35: 80 02                        BRA     IDE_SEND_CMD    ;Send Command and return
  1137                        ;
  1138                        IDE_DIAG                                ;Run internal Diagnostics on the CF-Card controller
  1139                        ;
  1140                        ; This is a basic self test within the CF-Card controller... per SanDisk documentation.
  1141                        ; This runs some internal tests for the IDE controller and returns with drive ready bits
  1142                        ; active ($50) and the error register as $01 if successful.
  1143                        ; To send this command, a seperate routine is used to save ROM space.
  1144                        ;
  1145 00:FB37: A9 90                        LDA     #$90            ;Get Diagnostic Command
  1146                        ;
  1147                        ; Drop into Send Command routine
  1148                        ;
  1149                        IDE_SEND_CMD                            ;Send a Command to the IDE controller
  1150                        ;
  1151                        ;Accepts a Command code via the A reg and sets up the necassary CF Card
  1152                        ; registers to accept it. It also tests to ensure the controller is ready
  1153                        ; to accept the command and get the Status and Error registers on return.
  1154                        ;
  1155                        ; NOTE: this routine turns off the interrupt capability as it is called
  1156                        ; during initial setup, where the interrupt handler has not been setup yet.
  1157                        ; A seperate routine is called to enable the interrupt capability.
  1158                        ;
  1159 00:FB39: 78                           SEI                     ;Disable Interrupts
  1160 00:FB3A: AA                           TAX                     ;Save Command to X Reg
  1161 00:FB3B: 20 2F F9                     JSR     TST_IDE_RDY     ;Wait for IDE to be ready
  1162 00:FB3E: A9 0A                        LDA     #%00001010      ;Get Mask to disable IRQ
  1163 00:FB40: 8D 76 FE                     STA     IDE_DEV_CTRL    ;Send to control register
  1164 00:FB43: A9 E0                        LDA     #%11100000      ;Get Select Mask (LBA Mode, Drive 0)
  1165 00:FB45: 8D 7E FE                     STA     IDE_DRV_HEAD    ;Select Drive 0
  1166                        ;
  1167 00:FB48: 8A                           TXA                     ;Get Command from X Reg
  1168 00:FB49: 8D 7F FE                     STA     IDE_COMMAND     ;Send command to IDE
  1169 00:FB4C: 20 37 F9                     JSR     TST_IDE_BUSY    ;Wait for drive Busy
  Tue May 18 2021 22:26                                                                                                    Page 25


  1170                        ;
  1171 00:FB4F: AD 7F FE                     LDA     IDE_STATUS      ;Get IDE Status Register
  1172 00:FB52: AE 79 FE                     LDX     IDE_ERROR       ;Get IDE Error Register
  1173 00:FB55: 58                           CLI                     ;Enable interrupts
  1174 00:FB56: 60                           RTS                     ;Return to caller
  1175                        ;
  1176                        ; Enable Interrupts on the CF Card IDE Controller
  1177                        ; This needs to executed during initial setup and anytime the Reset/Diag BIOS function
  1178                        ; is called.
  1179                        ;
  1180                        IDE_EN_IRQ                              ;Enable CF-Card interrupt
  1181 00:FB57: 20 2F F9                     JSR     TST_IDE_RDY     ;Wait for IDE to be ready
  1182 00:FB5A: A9 08                        LDA     #%00001000      ;Get Mask to enable IRQ
  1183 00:FB5C: 8D 76 FE                     STA     IDE_DEV_CTRL    ;Send to control register
  1184 00:FB5F: 60                           RTS                     ;Return to caller
  1185                        ;
  1186                        ;Interrupt 1 - This is the ISR which is responsible for servicing the IDE controller on the
  1187                        ; RTC-CF-Card adapter. The RTC does not actually require any ISR capabilities as no Alarm functions
  1188                        ; are being used in the BIOS. There are extra inserts which can be used if needed at a later date.
  1189                        ; The only functions that might make sense would be to add the Alarm function at a future date.
  1190                        ; Once the IDE controller BIOS has matured, if there's any room left in the allocated ROM area,
  1191                        ; I'll revisit it.
  1192                        ;
  1193                        ;The ISR for the IDE controller will handle the data transfer for LBA read/write/verify functions
  1194                        ; and handle any error functions. By design, the 16-bit Data Transfer feature is used for:
  1195                        ; Reading / Writing / Verifying of all LBA block data and the IDE Identification data.
  1196                        ;
  1197                        ;The 16-bit IOCS16 line was routed to the Set Overflow (SO) pin on the CPU, so it could be used in
  1198                        ; the data transfer routine as a handshake signal. Testing showed that the IOSC16 line goes active
  1199                        ; during a block transfer, but you still need to read the Status Register and test the DRQ bit.
  1200                        ; As a result, there's really no advantage in using the IOCS16 line.
  1201                        ;
  1202                        ;Update: I've opted to remove the jumper and connection from the IOCS16 line to the SO line to the
  1203                        ; CPU in the latest hardware adapter version. It's clear that there's no actual value in trying to
  1204                        ; use it, as the Status register must be read for each 16-bit data transfer, so any access of the
  1205                        ; IOCS16 line would just be overhead.
  1206                        ;
  1207                        ;The BIOS is using the Alternate Status register to determine if DRQ (Data Request) is set.
  1208                        ; This works as a handshake for 16-bit data transfers without issue. Note that the normal Status
  1209                        ; register resets the interrupt when read, so this is only done once in the ISR.
  1210                        ;
  1211                        ;Arrival here takes place after the first ISR for the SCC2691 UART has been serviced. If the UART
  1212                        ; did not generate the interrupt, it will be quickly be directed to this routine. Note that during
  1213                        ; the Init and Setup of the IDE controller, the Init routine will insert a new vector into the
  1214                        ; chain by taking the existing exit vector, replacing it to point here and the exit from this ISR
  1215                        ; points to the original exit vector. In the source code here, you can also REM out the interrupt
  1216                        ; insert and choose to load this ISR first. This will improve data transfer rate slightly.
  1217                        ;
  1218                        ;Update: This ISR has been moved to the front of the ISR chain, i.e., this ISR routine gets
  1219                        ; serviced first, then jumps to the next ISR, which services the UART. This makes a noticeable
  1220                        ; improvement in data transfer from the IDE controller. Note that overhead for this routine will
  1221                        ; add 33 clock cycles if it just exits (IDE controller did not generate an interrupt).
  1222                        ;
  1223                        ;To check if an interrupt has been generated by the IDE controller, the Alternate Status register
  1224                        ; can be read. This contains the same information as the standard Status register but will NOT
  1225                        ; reset the interrupt on the IDE controller. By reading the Alternate Status register first, we
  1226                        ; can first determine what the status of the IDE controller is and take action if required.
  1227                        ; Note that not all bit settings imply an interrupt was generated. Specifically, looking at the
  1228                        ; bit definitions below, Bits 6 and 4 are set when the IDE is ready, hence a normal condition
  1229                        ; where nothing requires any attention. Also, a Busy condition can imply the IDE controller is
  1230                        ; working on a command but may not have generated an interrupt yet. If The Busy bit (7) is set,
  1231                        ; then all other bits are invalid per SanDisk documentation, so we trigger on that first.
  1232                        ;
  Tue May 18 2021 22:26                                                                                                    Page 26


  1233                        ;One annoying feature for IDE is "when" interrupts are generated. For any Read operation, once
  1234                        ; the command has been accepted, data is placed into the CF-Card buffer, followed by generating
  1235                        ; an interrupt to the system. Once this is done, the system will read the data. By accessing the
  1236                        ; Status register, the interrupt will be reset. This is normal operation. For a write operation,
  1237                        ; The command is sent, then DRQ goes active, which requires the data be sent to the CF-Card.
  1238                        ; Once the data is written, an interrupt is generated after it's completed. As a result, there's
  1239                        ; really no useful function of having an ISR for servicing the write functions, unless the command
  1240                        ; is to write multiple blocks.... which most CF-Cards do not support a block transfer of more than
  1241                        ; one block. Still, as interrupts are active for the CF Card, we handle it here to ensure there
  1242                        ; are no errors and the calling routine doesn't attempt to write another block until the last one
  1243                        ; has been completed.
  1244                        ;
  1245                        ; Status Register bits as defined as follows:
  1246                        ;       - Bit 7 = Busy (a Command has been accepted)
  1247                        ;       - Bit 6 = Ready (IDE controller is ready to accept a command)
  1248                        ;       - Bit 5 = Write Fault (A write command failed against the media)
  1249                        ;       - Bit 4 = DSC (is set when the CF Card is ready)
  1250                        ;       - Bit 3 = Data Request (set when there is data to transfer, read or write)
  1251                        ;       - Bit 2 = Correction (set when a recoverable data error was corrected)
  1252                        ;       - Bit 1 = 0 (not used)
  1253                        ;       - Bit 0 = Error (set when the previous command had an unrecoverable error)
  1254                        ;
  1255                        ;       NOTE: 25 clock cycles to here if UART ISR is second!
  1256                        ;       NOTE: 40 clock cycles to here if NO UART interrupt occurs!
  1257                        ;
  1258                        INTERUPT1                               ;Interrupt 1 (IDE)
  1259 00:FB60: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get Alternate Status Register (4)
  1260 00:FB63: 30 39                        BMI     REGEXT01        ;If Busy bit active, just exit (2/3)
  1261                        ;
  1262                        ; - Check for Data Request (DRQ), as it's the only function that will require servicing
  1263                        ; against the IDE controller.
  1264                        ;
  1265 00:FB65: AD 7F FE                     LDA     IDE_STATUS      ;Get Status (resets IRQ) (4)
  1266 00:FB68: 29 08                        AND     #%00001000      ;Check for DRQ (2)
  1267 00:FB6A: D0 09                        BNE     IDE_READ_BLK    ;Branch if active (2/3)
  1268                        ;
  1269                        ; - If no DRQ, possible Write or Verify Block command, check for these next.
  1270                        ;
  1271 00:FB6C: AF FF 32                     BBS2    MATCH,IDE_WRIT_BLK      ;If Bit 2 set, Write operation (5)
  1272 00:FB6F: 9F FF 33                     BBS1    MATCH,IDE_VRFY_BLK      ;If Bit 1 set, Verify operation (5)
  1273 00:FB72: 6C 10 03                     JMP     (VECINSRT0)     ;Exit ISR handler, saves 3 clock cycles (6)
  1274                        ;
  1275                        IDE_READ_BLK                            ;IDE Read a Block of data
  1276                        ;
  1277                        ;Note: This next instruction is required! Arrival here states that the DRQ bit in the
  1278                        ; status register is active, so a data transfer "is" in place. If it's not the result
  1279                        ; of a LBA Read command, then it's from a LBA Write command. Also realize that this ISR
  1280                        ; will be executed every time the UART generates an interrupt. This will happen every
  1281                        ; 10ms for the Jiffy-Clock timer and for character transmit and receive.
  1282                        ;
  1283 00:FB75: 3F FF 26                     BBR3    MATCH,REGEXT01  ;If Bit 3 not set, exit ISR, (Write Cmd) (5)
  1284                        ;
  1285 00:FB78: AD 76 FE     LBA_XFER        LDA     IDE_ALT_STATUS  ;Get Status (resets IRQ) (4)
  1286 00:FB7B: 29 08                        AND     #%00001000      ;Check for DRQ (2)
  1287 00:FB7D: F0 18                        BEQ     IDE_RD_DONE     ;If not active, done, exit (2/3)
  1288                        ;
  1289                        IDE_RD_RBLK
  1290 00:FB7F: AD 78 FE                     LDA     IDE_DATA        ;Read low byte (high byte in latch) (4)
  1291 00:FB82: 92 FD                        STA     (BIOS_XFERL)    ;Store low byte (5)
  1292 00:FB84: E6 FD                        INC     BIOS_XFERL      ;Increment pointers (5)
  1293 00:FB86: D0 02                        BNE     IDE_RD_BLK1     ; (2/3)
  1294 00:FB88: E6 FE                        INC     BIOS_XFERH      ; (5)
  1295                        IDE_RD_BLK1
  Tue May 18 2021 22:26                                                                                                    Page 27


  1296 00:FB8A: AD 74 FE                     LDA     IDE_16_READ     ;Read high byte from latch (4)
  1297 00:FB8D: 92 FD                        STA     (BIOS_XFERL)    ;Store high byte (5)
  1298 00:FB8F: E6 FD                        INC     BIOS_XFERL      ;Increment pointers (5)
  1299 00:FB91: D0 E5                        BNE     LBA_XFER        ;Loop back to Xfer, saves 3 clock cycles (2/3)
  1300 00:FB93: E6 FE                        INC     BIOS_XFERH      ; (5)
  1301                        IDE_RD_BLK2
  1302 00:FB95: 80 E1                        BRA     LBA_XFER        ;Loop back till no more DRQs (3)
  1303                        ;
  1304 00:FB97: 37 FF        IDE_RD_DONE     RMB3    MATCH           ;Clear Read Block flag (5)
  1305                        ;
  1306 00:FB99: AD 76 FE     IDE_ALL_DONE    LDA     IDE_ALT_STATUS  ;Get Alternate Status Register (4)
  1307 00:FB9C: 85 D0                        STA     IDE_STATUS_RAM  ;Save it to RAM location (3)
  1308 00:FB9E: 6C 10 03     REGEXT01        JMP     (VECINSRT0)     ;Exit ISR handler (6)
  1309                        ;
  1310                        IDE_WRIT_BLK                            ;IDE Write a Block of data
  1311 00:FBA1: 27 FF                        RMB2    MATCH           ;Clear Write Block flag (5)
  1312 00:FBA3: 80 F4                        BRA     IDE_ALL_DONE    ;Branch and finish ISR (3)
  1313                        ;
  1314                        IDE_VRFY_BLK                            ;IDE Verify a Block of data
  1315 00:FBA5: 17 FF                        RMB1    MATCH           ;Clear Verify Block flag (5)
  1316 00:FBA7: 80 F0                        BRA     IDE_ALL_DONE    ;Branch and finish ISR (3)
  1317                        ;
  1318                        ;**************************************************************************************************
  1319                        ;BRK/IRQ Interrupt service routines
  1320                        ;The pre-process routine located in page $FF soft-vectors to INTERUPT0/BRKINSTR0 below
  1321                        ;       These are the routines that handle BRK and IRQ functions
  1322                        ;       The BRK handler saves CPU details for register display
  1323                        ;       - A Monitor can provide a disassembly of the last executed instruction
  1324                        ;       - A Received Break is also handled here (ExtraPutty/Windows or Serial/OSX)
  1325                        ;
  1326                        ; SCC2691 handler
  1327                        ;       The 2691 IRQ routine handles Transmit, Receive, Timer and Received-Break interrupts
  1328                        ;       - Transmit and Receive each have a 128 byte circular FIFO buffer in memory
  1329                        ;       - Xmit IRQ is controlled (On/Off) by the handler and the CHROUT routine
  1330                        ; The 2691 Timer resolution is 10ms and used as a Jiffy Clock for RTC, delays and benchmarking
  1331                        ;
  1332                        ;**************************************************************************************************
  1333                        ;BIOS routines to handle interrupt-driven I/O for the SCC2691
  1334                        ;NOTE: MPI Pin is used for RTS, which is automatically handled in the chip. As a result,
  1335                        ; the upper 2 bits of the ISR are not used in the handler. The Lower 5 bits are used, but
  1336                        ; the lower two are used to determine when to disable transmit after the buffer is empty.
  1337                        ;
  1338                        ;The UART_ISR bits are defined as follows:
  1339                        ; 7- MPI Pin change             0=No, 1=Yes
  1340                        ; 6- MPI Pin current state      0=Low, 1=High
  1341                        ; 5- Unused                     Always Active=1
  1342                        ; 4- Counter Ready              0=No, 1=Yes
  1343                        ; 3- Delta Break                0=No, 1=Yes
  1344                        ; 2- RxRDY/Full                 0=No, 1=Yes
  1345                        ; 1- TxEMT                      0=No, 1=Yes
  1346                        ; 0- TXRDY                      0=No, 1=Yes
  1347                        ;
  1348                        ;**************************************************************************************************
  1349                        ;
  1350 00:FBA9: A4 DF        UART_RCV        LDY     ICNT            ;Get input buffer count (3)
  1351 00:FBAB: 30 3B                        BMI     BUFFUL          ;Check against limit ($80), branch if full (2/3)
  1352 00:FBAD: AD 83 FE                     LDA     UART_RECEIVE    ;Else, get data from 2691 (4)
  1353                        ;
  1354 00:FBB0: A4 E1                        LDY     ITAIL           ;Get the tail pointer to buffer (3)
  1355 00:FBB2: 99 00 02                     STA     IBUF,Y          ;Store into buffer (5)
  1356 00:FBB5: E6 E1                        INC     ITAIL           ;Increment tail pointer (5)
  1357 00:FBB7: 77 E1                        RMB7    ITAIL           ;Strip off bit 7, 128 bytes only (5)
  1358 00:FBB9: E6 DF                        INC     ICNT            ;increment data count (5)
  Tue May 18 2021 22:26                                                                                                    Page 28


  1359                        ;
  1360 00:FBBB: AD 81 FE                     LDA     UART_STATUS     ;Get 2691 Status Reg (4)
  1361 00:FBBE: 89 02                        BIT     #%00000010      ;Check for xmit active (2)
  1362 00:FBC0: F0 48                        BEQ     REGEXT0         ;Exit if inactive (2/3)
  1363                        ;
  1364 00:FBC2: A5 E2        UART_XMT        LDA     OCNT            ;Get output buffer count, any data to xmit? (3)
  1365 00:FBC4: F0 10                        BEQ     NODATA          ;If zero, no data left, turn off xmit (2/3)
  1366                        ;
  1367 00:FBC6: A4 E3                        LDY     OHEAD           ;Get the head pointer to buffer (3)
  1368 00:FBC8: B9 80 02                     LDA     OBUF,Y          ;Get the next data (5)
  1369 00:FBCB: 8D 83 FE                     STA     UART_TRANSMIT   ;Send the data to 2691 (4)
  1370 00:FBCE: E6 E3                        INC     OHEAD           ;Increment head pointer (5)
  1371 00:FBD0: 77 E3                        RMB7    OHEAD           ;Strip off bit 7, 128 bytes only (5)
  1372 00:FBD2: C6 E2                        DEC     OCNT            ;Decrement counter (5)
  1373 00:FBD4: D0 34                        BNE     REGEXT0         ;If not zero, exit and continue normal processing (2/3)
  1374                        ;
  1375                        ;No more buffer data to send, check 2691 status and disable transmit if it's finished.
  1376                        ;
  1377 00:FBD6: AD 81 FE     NODATA          LDA     UART_STATUS     ;Get Status Register (4)
  1378 00:FBD9: 89 08                        BIT     #%00001000      ;Check for THR empty (2)
  1379 00:FBDB: D0 2D                        BNE     REGEXT0         ;Exit if data still loaded (2/3)
  1380 00:FBDD: 89 04                        BIT     #%00000100      ;Check for TxRDY active (2)
  1381 00:FBDF: F0 29                        BEQ     REGEXT0         ;Exit if not active, another data byte in THR (2/3)
  1382 00:FBE1: A0 08                        LDY     #%00001000      ;Else, get mask for xmit off (2)
  1383 00:FBE3: 8C 82 FE                     STY     UART_COMMAND    ;Turn off xmit (4)
  1384 00:FBE6: 80 22                        BRA     REGEXT0         ;Exit IRQ handler (3)
  1385                        ;
  1386                        ; SCC2691 uses all bits in the Status Register!
  1387                        ; - for Receive Buffer full, we mimic the receiver FIFO being full. The SCC2691 init routine
  1388                        ;   enables an interrupt whenever a data is received, so the FIFO will not fill up unless
  1389                        ;   the buffer is full for 3 received data bytes.
  1390                        ;
  1391 00:FBE8: A9 02        BUFFUL          LDA     #%00000010      ;Get buffer overflow flag (2)
  1392 00:FBEA: 80 1C                        BRA     BUFF_ERR        ;Branch to exit (3)
  1393                        ;
  1394                        ;IRQ Vector defaults to here, which is the Start of Interrupt handler.
  1395                        ; NOTE: 25 clock cycles to get to this routine
  1396                        ; NOTE: If this ISR is after the IDE ISR, it will take 33 additional clock cycles
  1397                        ;
  1398                        INTERUPT0                               ;Interrupt 0 to handle the SCC2691 UART
  1399 00:FBEC: AD 85 FE                     LDA     UART_ISR        ;Get the UART Interrupt Status Register (4)
  1400 00:FBEF: C9 20                        CMP     #%00100000      ;Check for no active IRQ source (2)
  1401 00:FBF1: F0 17                        BEQ     REGEXT0         ;If no bits are set, exit handler (2/3)
  1402                        ;
  1403 00:FBF3: 89 08                        BIT     #%00001000      ;Test for Delta Break (2)
  1404 00:FBF5: D0 16                        BNE     UART_BRK        ;If yes, Reset the UART receiver (2/3)
  1405 00:FBF7: 89 04                        BIT     #%00000100      ;Test for RHR having data (2)
  1406 00:FBF9: D0 AE                        BNE     UART_RCV        ;If yes, put the data in the buffer (2/3)
  1407 00:FBFB: 89 01                        BIT     #%00000001      ;Test for THR ready to receive data (2)
  1408 00:FBFD: D0 C3                        BNE     UART_XMT        ;If yes, get data from buffer (2/3)
  1409 00:FBFF: 89 10                        BIT     #%00010000      ;Test for Counter ready (RTC) (2)
  1410 00:FC01: D0 0D                        BNE     UART_RTC        ;If yes, go increment RTC variables (2/3)
  1411                        ;
  1412 00:FC03: 85 E5        IRQEXT0         STA     UART_IRT        ;Else, save the 2691 IRT for later use (4)
  1413 00:FC05: AD 81 FE                     LDA     UART_STATUS     ;Get 2691 Status Register (4)
  1414 00:FC08: 85 E6        BUFF_ERR        STA     UART_SRT        ;Save 2691 Status Register for later use (4)
  1415 00:FC0A: 6C 0A 03     REGEXT0         JMP     (IRQRTVEC0)     ;Return to Exit/ROM IRQ handler (6)
  1416 00:FC0D: 4C C8 FC     UART_BRK        JMP     UART_BRK0       ;Gotta JUMP to the routine
  1417                        ;
  1418                        ;NOTE: Stop timer cmd resets the interrupt flag, counter continues to generate interrupts.
  1419                        ; NOTE: 25 clock cycles to here from INTERUPT0 - 50 in total
  1420                        ;
  1421 00:FC10: A9 90        UART_RTC        LDA     #%10010000      ;Get Command mask for stop timer (2)
  Tue May 18 2021 22:26                                                                                                    Page 29


  1422 00:FC12: 8D 82 FE                     STA     UART_COMMAND    ;Send command to 2691 (4)
  1423                        ;
  1424                        ; Check the MATCH flag bit7 to see if a Delay is active. If yes, decrement the MSDELAY
  1425                        ; variable once each pass until it is zero, then clear the MATCH flag bit7
  1426                        ;
  1427 00:FC15: 7F FF 06                     BBR7    MATCH,SKIP_DLY  ;Skip Delay if bit7 is clear (5)
  1428 00:FC18: C6 EF                        DEC     MSDELAY         ;Decrement Millisecond delay variable (5)
  1429 00:FC1A: D0 02                        BNE     SKIP_DLY        ;If not zero, skip (2/3)
  1430 00:FC1C: 77 FF                        RMB7    MATCH           ;Else clear MATCH flag (5)
  1431                        ;
  1432                        ; Check the MATCH flag bit6 to see if Benchmarking is active. If yes, increment the
  1433                        ; variables once each pass until the MATCH flag bit6 is inactive.
  1434                        ;
  1435 00:FC1E: 6F FF 10     SKIP_DLY        BBR6    MATCH,SKIP_CNT  ;Skip Count if bit6 bit is clear (5)
  1436 00:FC21: E6 F4                        INC     MS10_CNT        ;Else, increment 10ms count (5)
  1437 00:FC23: A5 F4                        LDA     MS10_CNT        ;Load current value (3)
  1438 00:FC25: C9 64                        CMP     #100            ;Compare for 1 second elapsed time (2)
  1439 00:FC27: 90 08                        BCC     SKIP_CNT        ;If not, skip to RTC update (2/3)
  1440 00:FC29: 64 F4                        STZ     MS10_CNT        ;Else, zero 10ms count (3)
  1441 00:FC2B: E6 F5                        INC     SECL_CNT        ;Increment low byte elapsed seconds (5)
  1442 00:FC2D: D0 02                        BNE     SKIP_CNT        ;If no overflow, skip to RTC update (2/3)
  1443 00:FC2F: E6 F6                        INC     SECH_CNT        ;Else, increment high byte elapsed seconds (5)
  1444                        ;
  1445 00:FC31: C6 E7        SKIP_CNT        DEC     TICKS           ;Decrement RTC tick count (5)
  1446 00:FC33: D0 D5                        BNE     REGEXT0         ;Exit if not zero (2/3)
  1447 00:FC35: A9 64                        LDA     #DF_TICKS       ;Get default tick count (2)
  1448 00:FC37: 85 E7                        STA     TICKS           ;Reset tick count (3)
  1449                        ;
  1450 00:FC39: E6 E8                        INC     SECS            ;Increment seconds (5)
  1451 00:FC3B: A5 E8                        LDA     SECS            ;Load it to A reg (3)
  1452 00:FC3D: C9 3C                        CMP     #60             ;Check for 60 seconds (2)
  1453 00:FC3F: 90 C9                        BCC     REGEXT0         ;If not, exit (2/3)
  1454 00:FC41: 64 E8                        STZ     SECS            ;Else, reset seconds, inc Minutes (3)
  1455                        ;
  1456 00:FC43: E6 E9                        INC     MINS            ;Increment Minutes (5)
  1457 00:FC45: A5 E9                        LDA     MINS            ;Load it to A reg (3)
  1458 00:FC47: C9 3C                        CMP     #60             ;Check for 60 minutes (2)
  1459 00:FC49: 90 BF                        BCC     REGEXT0         ;If not, exit (2/3)
  1460 00:FC4B: 64 E9                        STZ     MINS            ;Else, reset Minutes, inc Hours (3)
  1461                        ;
  1462 00:FC4D: E6 EA                        INC     HOURS           ;Increment Hours (5)
  1463 00:FC4F: A5 EA                        LDA     HOURS           ;Load it to A reg (3)
  1464 00:FC51: C9 18                        CMP     #24             ;Check for 24 hours (2)
  1465 00:FC53: 90 B5                        BCC     REGEXT0         ;If not, exit (2/3)
  1466 00:FC55: 64 EA                        STZ     HOURS           ;Else, reset hours, inc Days (3)
  1467                        ;
  1468                        ;This is the tricky part ;-)
  1469                        ; One variable holds the Day of the week and the Date of the Month!
  1470                        ; First, update the Day of the Week, which is the upper 3 bits of the variable
  1471                        ; Valid days are 1 to 7. Mask off the upper 3 bits, and add #%00100000 to it,
  1472                        ; if the result is zero, it was #%11100000, so start over by making the Day
  1473                        ; #%00100000, then save it to RTC_TEMP variable.
  1474                        ;
  1475                        ;Once that's done, load the variable again, mask off the Date and increase by
  1476                        ; one, then check against days of the month, update as required and check for
  1477                        ; Leap year and February 29th stuff. When all updated, OR in the Day from the
  1478                        ; RTC_TEMP variable and finish updating the DAY_DATE variable.
  1479                        ;
  1480 00:FC57: A5 EB                        LDA     DAY_DATE        ;Get Day and Date variable (3)
  1481 00:FC59: 29 E0                        AND     #%11100000      ;Mask off for Day of Week (1-7) (2)
  1482 00:FC5B: 18                           CLC                     ;Clear carry for add (2)
  1483 00:FC5C: 69 20                        ADC     #%00100000      ;Add effective "1" to Day of week (2)
  1484 00:FC5E: 18                           CLC                     ;Clear carry to avoid extra day add (2)
  Tue May 18 2021 22:26                                                                                                    Page 30


  1485 00:FC5F: D0 02                        BNE     NO_DAY_ADD      ;If non-zero, don't reset to "1" (2/3)
  1486 00:FC61: A9 20                        LDA     #%00100000      ;Else, reset Day to "1" (2)
  1487                        NO_DAY_ADD
  1488 00:FC63: 85 EE                        STA     RTC_TEMP        ;Store the updated Day into temp (3)
  1489                        ;
  1490                        ;Get the Month and Year variable, move the upper 4-bits down to get the
  1491                        ; current Month. Xfer it the X reg, then get the Date, increment by one
  1492                        ; and check against the number of days in that month.
  1493                        ;
  1494 00:FC65: A5 EC                        LDA     MONTH_CENTURY   ;Get Month and Year variable (3)
  1495 00:FC67: 4A                           LSR     A               ;Shift Month to lower 4 bits (2)
  1496 00:FC68: 4A                           LSR     A               ; (2)
  1497 00:FC69: 4A                           LSR     A               ; (2)
  1498 00:FC6A: 4A                           LSR     A               ; (2)
  1499 00:FC6B: AA                           TAX                     ;Move to X reg (2)
  1500 00:FC6C: A5 EB                        LDA     DAY_DATE        ;Get Day and Date variable (3)
  1501 00:FC6E: 29 1F                        AND     #%00011111      ;Mask off for Date of Month (1-31) (2)
  1502 00:FC70: 1A                           INC     A               ;Increment by one (2)
  1503 00:FC71: DD F1 FE                     CMP     MAX_DATE-1,X    ;Check for Max Day per Month+1 (4)
  1504 00:FC74: B0 06                        BCS     MONTH_ADD       ;Branch if we need to update the Month (2/3)
  1505 00:FC76: 05 EE        DO_29           ORA     RTC_TEMP        ;Else OR in updated Date to updated Day (3)
  1506 00:FC78: 85 EB                        STA     DAY_DATE        ;Update Day and Date variable (3)
  1507 00:FC7A: 80 49                        BRA     REGEXT00        ;Then exit IRQ Handler (3)
  1508                        ;
  1509 00:FC7C: E0 02        MONTH_ADD       CPX     #$02            ;Check for Month = February (2)
  1510 00:FC7E: D0 0F                        BNE     MONTH_INC       ;If not, increment Month (2/3)
  1511 00:FC80: A5 ED                        LDA     YEAR            ;Else, Get current year low byte (3)
  1512 00:FC82: 29 03                        AND     #%00000011      ;Mask off lower 2 bits (2)
  1513 00:FC84: D0 09                        BNE     MONTH_INC       ;If not a Leap Year, continue on (2/3)
  1514 00:FC86: A5 EB                        LDA     DAY_DATE        ;Get Day and Date variable (3)
  1515 00:FC88: 29 1F                        AND     #%00011111      :Mask off Date (2)
  1516 00:FC8A: 1A                           INC     A               ;Increment by one (2)
  1517 00:FC8B: C9 1E                        CMP     #30             ;Check for 29th+1 Day for Leap Year (2)
  1518 00:FC8D: 90 E7                        BCC     DO_29           ;Save Date as 29th and exit IRQ handler (2/3)
  1519                        ;
  1520 00:FC8F: A5 EE        MONTH_INC       LDA     RTC_TEMP        ;Get updated Day (Date is effective zero)
  1521 00:FC91: 09 01                        ORA     #%00000001      ;OR in the 1st Day of the Month
  1522 00:FC93: 85 EB                        STA     DAY_DATE        ;Save updated Day and Date of the Month
  1523                        ;
  1524 00:FC95: A5 EC                        LDA     MONTH_CENTURY   ;Get Month and Year variable
  1525 00:FC97: 18                           CLC                     ;Clear Carry for add
  1526 00:FC98: 69 10                        ADC     #$10            ;Add "1" to Month (upper 4 bits)
  1527 00:FC9A: 85 EE                        STA     RTC_TEMP        ;Save it to work temp
  1528 00:FC9C: 29 F0                        AND     #%11110000      ;Mask off Century (lower 4 bits)
  1529 00:FC9E: C9 D0                        CMP     #$D0            ;Check for "13" (December + 1)
  1530 00:FCA0: B0 06                        BCS     YEAR_ADD        ;If 13 go add to YEAR
  1531 00:FCA2: A5 EE                        LDA     RTC_TEMP        ;Else, Get updated Month and Century
  1532 00:FCA4: 85 EC                        STA     MONTH_CENTURY   ;Save it
  1533 00:FCA6: 80 1D                        BRA     REGEXT00        ;Exit IRQ Handler
  1534                        ;
  1535 00:FCA8: A5 EC        YEAR_ADD        LDA     MONTH_CENTURY   ;Get Month and Century
  1536 00:FCAA: 29 0F                        AND     #%00001111      ;Mask off old month
  1537 00:FCAC: 09 10                        ORA     #%00010000      ;OR in $10 for January
  1538 00:FCAE: 85 EC                        STA     MONTH_CENTURY   ;Save updated Month and existing upper 4 bits
  1539 00:FCB0: E6 ED                        INC     YEAR            ;Increment Year low byte (0-255)
  1540 00:FCB2: D0 11                        BNE     REGEXT00        ;If no rollver, exit ISR
  1541 00:FCB4: A5 EC                        LDA     MONTH_CENTURY   ;Get Month and Year variable
  1542 00:FCB6: AA                           TAX                     ;Save to X reg
  1543 00:FCB7: 29 F0                        AND     #%11110000      ;Mask off upper 4-bits for year
  1544 00:FCB9: 85 EE                        STA     RTC_TEMP        ;Save it in the temp area
  1545 00:FCBB: 8A                           TXA                     ;Get the Month and Year back
  1546 00:FCBC: 29 0F                        AND     #%00001111      ;Mask off the month
  1547 00:FCBE: 18                           CLC                     ;Clear carry for add
  Tue May 18 2021 22:26                                                                                                    Page 31


  1548 00:FCBF: 69 01                        ADC     #$01            ;Add 1 to upper 4 bits
  1549 00:FCC1: 05 EE                        ORA     RTC_TEMP        ;OR in the Month
  1550 00:FCC3: 85 EC                        STA     MONTH_CENTURY   ;Update Month and Century variable
  1551 00:FCC5: 6C 0A 03     REGEXT00        JMP     (IRQRTVEC0)     ;If no rollover, then exit IRQ handler (6)
  1552                        ;
  1553 00:FCC8: AD 81 FE     UART_BRK0       LDA     UART_STATUS     ;Get UART Status Register (4)
  1554 00:FCCB: 30 0D                        BMI     BREAKEY         ;If bit 7 set, received Break was detected (2/3)
  1555                        ;
  1556                        ; If a received Break was not the cause, we should reset the UART as the cause
  1557                        ; could have been a receiver error, i.e., parity or framing
  1558                        ;
  1559 00:FCCD: A2 05                        LDX     #UART_RDATAE-UART_RDATA ;Get index count (2)
  1560 00:FCCF: BD DF FE     UART_RST1       LDA     UART_RDATA-1,X  ;Get Reset commands (4)
  1561 00:FCD2: 8D 82 FE                     STA     UART_COMMAND    ;Send to UART CR (3)
  1562 00:FCD5: CA                           DEX                     ;Decrement the command list (2)
  1563 00:FCD6: D0 F7                        BNE     UART_RST1       ;Loop back until all are sent (2/3)
  1564 00:FCD8: 80 EB                        BRA     REGEXT00         ;Exit (3)
  1565                        ;
  1566 00:FCDA: A9 40        BREAKEY         LDA     #%01000000      ;Get Reset Received Break command (2)
  1567 00:FCDC: 8D 82 FE                     STA     UART_COMMAND    ;Send to UART to reset (4)
  1568 00:FCDF: A9 50                        LDA     #%01010000      ;Get Reset Break Interrupt command (2)
  1569 00:FCE1: 8D 82 FE                     STA     UART_COMMAND    ;Send to UART to reset (4)
  1570 00:FCE4: 58                           CLI                     ;Enable IRQ (2)
  1571                        ;
  1572                        ; BRK Vector defaults to here
  1573                        ;
  1574 00:FCE5: 7A           BRKINSTR0       PLY                     ;Restore Y Reg (4)
  1575 00:FCE6: FA                           PLX                     ;Restore X Reg (4)
  1576 00:FCE7: 68                           PLA                     ;Restore A Reg (4)
  1577 00:FCE8: 85 DE                        STA     AREG            ;Save A Reg (3)
  1578 00:FCEA: 86 DD                        STX     XREG            ;Save X Reg (3)
  1579 00:FCEC: 84 DC                        STY     YREG            ;Save Y Reg (3)
  1580 00:FCEE: 68                           PLA                     ;Get Processor Status (4)
  1581 00:FCEF: 85 DA                        STA     PREG            ;Save in PROCESSOR STATUS preset/result (3)
  1582 00:FCF1: BA                           TSX                     ;Xfer STACK pointer to X Reg (2)
  1583 00:FCF2: 86 DB                        STX     SREG            ;Save STACK pointer (3)
  1584                        ;
  1585 00:FCF4: FA                           PLX                     ;Pull Low RETURN address from STACK then save it (4)
  1586 00:FCF5: 86 D8                        STX     PCL             ;Store program counter Low byte (3)
  1587 00:FCF7: 86 B0                        STX     INDEXL          ;Seed Indexl for DIS_LINE (3)
  1588 00:FCF9: 7A                           PLY                     ;Pull High RETURN address from STACK then save it (4)
  1589 00:FCFA: 84 D9                        STY     PCH             ;Store program counter High byte (3)
  1590 00:FCFC: 84 B1                        STY     INDEXH          ;Seed Indexh for DIS_LINE (3)
  1591 00:FCFE: 4F DA 0C                     BBR4    PREG,DO_NULL    ;Check for BRK bit set (5)
  1592                        ;
  1593                        ; The following three subroutines are contained in the base C02 Monitor code. These calls
  1594                        ; do a register display and disassembles the line of code that caused the BRK to occur
  1595                        ;
  1596 00:FD01: 20 21 E0                     JSR     M_PRSTAT1       ;Display CPU status
  1597 00:FD04: 20 2A E0                     JSR     M_DECINDEX      ;Decrement Index to BRK ID Byte
  1598 00:FD07: 20 2A E0                     JSR     M_DECINDEX      ;Decrement Index to BRK instruction
  1599 00:FD0A: 20 24 E0                     JSR     M_DIS_LINE      ;Disassemble BRK instruction
  1600                        ;
  1601 00:FD0D: A9 00        DO_NULL         LDA     #$00            ;Clear all Processor Status Register bits (2)
  1602 00:FD0F: 48                           PHA                     ;Push it to Stack (3)
  1603 00:FD10: 28                           PLP                     ;Pull it to Processor Status (4)
  1604 00:FD11: 64 E1                        STZ     ITAIL           ;Clear input buffer pointers (3)
  1605 00:FD13: 64 E0                        STZ     IHEAD           ; (3)
  1606 00:FD15: 64 DF                        STZ     ICNT            ; (3)
  1607 00:FD17: 6C 08 03                     JMP     (BRKRTVEC0)     ;Done BRK service process, re-enter monitor (6)
  1608                        ;
  1609                        ; EPOCH time (Unix) starts on Thursday, 1st January, 1970.
  1610                        ; If no RTC is detected, preload the EPOCH Date as a start.
  Tue May 18 2021 22:26                                                                                                    Page 32


  1611                        ; Note: No time of day is preloaded, time is 00:00:00 after a cold start.
  1612                        ;
  1613 00:FD1A: C1           EPOCH           .DB     %11000001       ;Day 6 / Date 1
  1614 00:FD1B: 17                           .DB     %00010111       ;Month 1  High byte (nibble) of 1970
  1615 00:FD1C: B2                           .DB     %10110010       ;Low byte of 1970 ($B2)
  1616                        ;
  1617 00:FD1D: 4E 6F 20 4C  NO_LBA          .DB     "No LBA Support"
       00:FD21: 42 41 20 53 
       00:FD25: 75 70 70 6F 
       00:FD29: 72 74 
  1618 00:FD2B: 0D 0A 00                     .DB     $0D,$0A,$00
  1619                        ;
  1620                        ;END OF BIOS CODE for Pages $F8 through $FD
  1621                        ;**************************************************************************************************
  1622                                .ORG    $FE00   ;Reserved for I/O space - do NOT put code here
  1623                        ;There are 5- I/O Selects, each is 32-bytes wide.
  1624                        ; I/O-0 = $FE00-$FE1F  Available on BUS expansion connector
  1625                        ; I/O-1 = $FE20-$FE3F  Available on BUS expansion connector
  1626                        ; I/O-2 = $FE40-$FE5F  Available on BUS expansion connector
  1627                        ; I/O-3 = $FE60-$FE7F  Available on BUS expansion connector - Used for RTC-IDE Adapter!
  1628                        ; I/O-4 = $FE80-$FE9F  SCC2691 UART resides here (only 8 bytes used)
  1629                        ;**************************************************************************************************
  1630                                .ORG    $FEA0   ;Reserved space for Soft Vector and I/O initialization data
  1631                        ;START OF BIOS DEFAULT VECTOR DATA AND HARDWARE CONFIGURATION DATA
  1632                        ;
  1633                        ;There are 96 bytes of ROM space remaining on page $FE from $FEA0 - $FEFF
  1634                        ; 64 bytes of this are copied to page $03 and used for soft vectors/hardware soft configuration.
  1635                        ; 32 bytes are for vectors and 32 bytes are for hardware config. The last 32 bytes are only held
  1636                        ; in ROM and are used for hardware configuration that should not be changed.
  1637                        ;
  1638                        ;The default location for the NMI/BRK/IRQ Vector data is at $0300. They are defined at the top of
  1639                        ; the source file. There are 8 defined vectors and 8 vector inserts, all are free for base config.
  1640                        ;
  1641                        ;The default location for the hardware configuration data is at $0320. It is a freeform table which
  1642                        ; is copied from ROM to page $03. The allocated size for the hardware config table is 32 bytes.
  1643                        ;
  1644                        VEC_TABLE      ;Vector table data for default ROM handlers
  1645                        ;
  1646 00:FEA0: 6A F9                        .DW     NMI_VECTOR      ;NMI Location in ROM
  1647 00:FEA2: E5 FC                        .DW     BRKINSTR0       ;BRK Location in ROM
  1648 00:FEA4: EC FB                        .DW     INTERUPT0       ;IRQ Location in ROM
  1649                        ;
  1650 00:FEA6: 03 E0                        .DW     M_WARM_MON      ;NMI return handler in ROM
  1651 00:FEA8: 03 E0                        .DW     M_WARM_MON      ;BRK return handler in ROM
  1652 00:FEAA: 98 FF                        .DW     IRQ_EXIT0       ;IRQ return handler in ROM
  1653                        ;
  1654 00:FEAC: 00 E0                        .DW     M_COLD_MON      ;Monitor Cold start
  1655 00:FEAE: 03 E0                        .DW     M_WARM_MON      ;Monitor Warm start
  1656                        ;
  1657                        ;Vector Inserts (total of 8)
  1658                        ; these can be used as required, all are free for now, as NMI/BRK/IRQ and the Monitor are
  1659                        ; vectored, all can be extended by using these reserved vector locations.
  1660                        ;
  1661 00:FEB0: FF FF                        .DW     $FFFF           ;Insert 0 Location (used if IDE is found)
  1662 00:FEB2: FF FF                        .DW     $FFFF           ;Insert 1 Location
  1663 00:FEB4: FF FF                        .DW     $FFFF           ;Insert 2 Location
  1664 00:FEB6: FF FF                        .DW     $FFFF           ;Insert 3 Location
  1665 00:FEB8: FF FF                        .DW     $FFFF           ;Insert 4 Location
  1666 00:FEBA: FF FF                        .DW     $FFFF           ;Insert 5 Location
  1667 00:FEBC: FF FF                        .DW     $FFFF           ;Insert 6 Location
  1668 00:FEBE: FF FF                        .DW     $FFFF           ;Insert 7 Location
  1669                        ;
  1670                        ;Configuration Data - The following tables contains the default data used for:
  Tue May 18 2021 22:26                                                                                                    Page 33


  1671                        ; - Reset of the SCC2691 (RESET_2691 routine)
  1672                        ; - Init of the SCC2691 (INIT_2691 routine)
  1673                        ; - Basic details for register definitions are below, consult SCC2691 DataSheet
  1674                        ;   and Application Note AN405 for details and specific operating conditions.
  1675                        ;
  1676                        ;Mode Register 1 definition ($93)
  1677                        ; Bit7          ;RxRTS Control - 1 = Yes
  1678                        ; Bit6          ;RX-Int Select - 0 = RxRDY
  1679                        ; Bit5          ;Error Mode - 0 = Character
  1680                        ; Bit4/3        ;Parity Mode - 10 = No Parity
  1681                        ; Bit2          ;Parity Type - 0 = Even (doesn't matter)
  1682                        ; Bit1/0        ;Bits Per Character - 11 = 8
  1683                        ;
  1684                        ;Mode Register 2 Definition ($17)
  1685                        ; Bit7/6        ;Channel Mode   - 00 = Normal
  1686                        ; Bit5          ;TxRTS Control - 0 = Yes
  1687                        ; Bit4          ;CTS Enable - 1 = Yes
  1688                        ; Bit3-0        ;Stop Bits - 0111 = 1 Stop Bit
  1689                        ;
  1690                        ;Baud Rate Clock Definition ($CC)
  1691                        ; Upper 4 bits = Receive Baud Rate
  1692                        ; Lower 4 bits = Transmit Baud Rate
  1693                        ; for 38.4K setting is %11001100
  1694                        ; Also set ACR Bit7 = 0 for standard rates
  1695                        ;
  1696                        ;Command Register Definition
  1697                        ; Bit7-4        ;Special commands
  1698                        ; Bit3          ;Disable Transmit
  1699                        ; Bit2          ;Enable Transmit
  1700                        ; Bit1          ;Disable Receive
  1701                        ; Bit0          ;Enable Receive
  1702                        ;
  1703                        ;Aux Control Register Definition ($68)
  1704                        ; Bit7          ;BRG Set Select - 0 = Default
  1705                        ; Bit6-5-4      ;Counter/Timer operating mode 110 = Counter mode from XTAL
  1706                        ; Bit3          ;Power Down mode 1 = Off (normal)
  1707                        ; Bit2-1-0      ;MPO Pin Function 000 = RTSN (active low state)
  1708                        ;
  1709                        ;Interrupt Mask Register Definition ($1D)
  1710                        ; Bit7          ;MPI Pin Change Interrupt 1 = On
  1711                        ; Bit6          ;MPI Level Interrupt 1 = On
  1712                        ; Bit5          ;Not used (shows as active on read)
  1713                        ; Bit4          ;Counter Ready Interrupt 1 = On
  1714                        ; Bit3          ;Delta Break Interrupt 1 = On
  1715                        ; Bit2          ;RxRDY Interrupt 1 = On
  1716                        ; Bit1          ;TxEMT Interrupt 1 = On
  1717                        ; Bit0          ;TxRDY Interrupt 1 = On
  1718                        ;
  1719                        CFG_TABLE       ;Configuration table for hardware devices
  1720                        ;
  1721                        ;Data commands are sent in reverse order from list. This list is the default initialization for
  1722                        ; the UART as configured for use as a Console connected to either ExtraPutty(WIN) or Serial(OSX)
  1723                        ; The data here is copied to page $03 and is used to configure the UART during boot up. The soft
  1724                        ; data can be changed and the core INIT_2691 can be called to reconfigure the UART.
  1725                        ; NOTE: the register offset data is not kept in soft config memory as the initialization
  1726                        ; sequence should not be changed!
  1727                        ;
  1728                        INIT_DATA       ;Start of UART Initialization Data
  1729 00:FEC0: 10                           .DB     %00010000       ;Reset Mode Register pointer
  1730 00:FEC1: A0                           .DB     %10100000       ;Enable RTS (Receiver)
  1731 00:FEC2: 09                           .DB     %00001001       ;Enable Receiver/Disable Transmitter
  1732 00:FEC3: 1D                           .DB     %00011101       ;Interrupt Mask Register setup
  1733 00:FEC4: 68                           .DB     %01101000       ;Aux Register setup for Counter/Timer
  Tue May 18 2021 22:26                                                                                                    Page 34


  1734 00:FEC5: 48                           .DB     %01001000       ;Counter/Timer Upper Preset
  1735 00:FEC6: 00                           .DB     %00000000       ;Counter/Timer Lower Preset
  1736 00:FEC7: 66                           .DB     %01100110       ;Baud Rate clock for Rcv/Xmt - 115.2K
  1737 00:FEC8: 90                           .DB     %10010000       ;Disable Counter/Timer
  1738 00:FEC9: 0A                           .DB     %00001010       ;Disable Receiver/Transmitter
  1739 00:FECA: B0                           .DB     %10110000       ;Disable RTS (Receiver)
  1740 00:FECB: 00                           .DB     %00000000       ;Interrupt Mask Register setup
  1741 00:FECC: 08                           .DB     %00001000       ;Aux Register setup for Power On
  1742                        INIT_DATAE      ;End of UART Initialization Data
  1743                        ;
  1744                        ;Mode Register Data is defined separately. Using a loop routine to send this data to the
  1745                        ; UART does not work properly. See the description of the problem using Indexed addressing
  1746                        ; to load the UART registers above. This data is also kept in soft config memory in page $03.
  1747                        ;
  1748                        ; NOTE: MR2_DAT Bit 7 is now used to configure Extended Baud rates!
  1749                        ;
  1750 00:FECD: 93           MR1_DAT         .DB     %10010011       ;Mode Register 1 Data
  1751                        ;
  1752                        ; Bit 7 set for extended baud rates - 115.2k
  1753                        ;
  1754 00:FECE: 97           MR2_DAT         .DB     %10010111       ;Mode Register 2 data
  1755                        ;
  1756                        ;Reserved for additional I/O devices (17 bytes free)
  1757                        ;
  1758 00:FECF: FF FF FF FF                  .DB     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
       00:FED3: FF FF FF FF 
       00:FED7: FF FF FF FF 
       00:FEDB: FF FF FF FF 
       00:FEDF: FF 
  1759                        ;
  1760                        ;Reset UART Data is listed here. The sequence and commands do not require changes for any reason.
  1761                        ; These are maintained in ROM only. A total of 32 bytes are available for hard configuration data.
  1762                        ; These are the register offsets and Reset data for the UART
  1763                        ;
  1764                        UART_RDATA      ;UART Reset Data for Received Break (ExtraPutty/Serial Break)
  1765 00:FEE0: 01                           .DB     %00000001       ;Enable Receiver
  1766                        ;
  1767                        UART_RDATA1     ;Smaller list for entry level Reset (RESET_2691)
  1768 00:FEE1: 40                           .DB     %01000000       ;Reset All Errors
  1769 00:FEE2: 30                           .DB     %00110000       ;Reset Transmitter
  1770 00:FEE3: 20                           .DB     %00100000       ;Reset Receiver
  1771 00:FEE4: 50                           .DB     %01010000       ;Reset Break Change Interrupt
  1772                        UART_RDATAE     ;End of UART Reset Data
  1773                        ;
  1774                        INIT_OFFSET     ;Start of UART Initialization Register Offsets
  1775 00:FEE5: 02                           .DB     $02             ;Command Register
  1776 00:FEE6: 02                           .DB     $02             ;Command Register
  1777 00:FEE7: 02                           .DB     $02             ;Command Register
  1778 00:FEE8: 05                           .DB     $05             ;Interrupt Mask Register
  1779 00:FEE9: 04                           .DB     $04             ;Aux Command Register
  1780 00:FEEA: 06                           .DB     $06             ;Counter Preset Upper
  1781 00:FEEB: 07                           .DB     $07             ;Counter Preset Lower
  1782 00:FEEC: 01                           .DB     $01             ;Baud Clock Register
  1783 00:FEED: 02                           .DB     $02             ;Command Register
  1784 00:FEEE: 02                           .DB     $02             ;Command Register
  1785 00:FEEF: 02                           .DB     $02             ;Command Register
  1786 00:FEF0: 05                           .DB     $05             ;Interrupt Mask Register
  1787 00:FEF1: 04                           .DB     $04             ;Aux Command Register
  1788                        INIT_OFFSETE    ;End of UART Initialization Register Offsets
  1789                        ;
  1790                        ;Reserved for additional I/O devices (14 bytes)
  1791                        ;
  1792                        ; BIOS 3.00 Data space for software RTC.
  Tue May 18 2021 22:26                                                                                                    Page 35


  1793                        ;
  1794                        MAX_DATE                                ;Maximum days per Month+1
  1795 00:FEF2: 20 1D 20 1F                  .DB     32,29,32,31,32,31,32,32,31,32,31,32
       00:FEF6: 20 1F 20 20 
       00:FEFA: 1F 20 1F 20 
  1796                        ;
  1797 00:FEFE: FF FF                        .DB     $FF,$FF         ;Spare bytes
  1798                        ;
  1799                        ;END OF BIOS VECTOR DATA AND HARDWARE DEFAULT CONFIGURATION DATA
  1800                        ;**************************************************************************************************
  1801                        ;START OF TOP PAGE - DO NOT MOVE FROM THIS ADDRESS!! JUMP Table starts here.
  1802                        ; - BIOS calls are listed below - total of 32, Reserved calls are for future hardware support
  1803                        ; - "B_" JUMP Tables entries are for BIOS routines, provides isolation between Monitor and BIOS
  1804                        ; - Two new calls used for Benchmark Timer, calls 16/17 starting with CO2BIOS 2.02
  1805                        ; - New calls added for IDE Controller and RTC starting with C02BIOS 3.00
  1806                        ;
  1807                        ; NOTE: All Jump table calls add 3 clock cycles to execution time for each BIOS function.
  1808                        ;
  1809                                .ORG    $FF00   ;BIOS JMP Table, Cold Init and Vector handlers
  1810                        ;
  1811 00:FF00: 4C 13 FB     B_IDE_RESET     JMP     IDE_RES_DIAG    ;Call 00 $FF00
  1812 00:FF03: 4C 1C FB     B_IDE_GET_STAT  JMP     IDE_GET_STATUS  ;Call 01 $FF03
  1813 00:FF06: 4C DD FA     B_IDE_IDENTIFY  JMP     IDE_IDENTIFY    ;Call 02 $FF06
  1814 00:FF09: 4C 6E F8     B_IDE_READ_LBA  JMP     IDE_READ_LBA    ;Call 03 $FF09
  1815 00:FF0C: 4C 93 F8     B_IDE_WRITE_LBA JMP     IDE_WRITE_LBA   ;Call 04 $FF0C
  1816 00:FF0F: 4C D7 F8     B_IDE_VERFY_LBA JMP     IDE_VERIFY_LBA  ;Call 05 $FF0F
  1817 00:FF12: 4C FF F8     B_IDE_SET_LBA   JMP     IDE_SET_LBA     ;Call 06 $FF12
  1818 00:FF15: 4C F8 F8     B_IDE_SET_ADDR  JMP     IDE_SET_ADDRESS ;Call 07 $FF15
  1819                        ;
  1820 00:FF18: 4C 3D F9     B_RTC_NVRD      JMP     RTC_NVRD        ;Call 08 $FF18
  1821 00:FF1B: 4C 4A F9     B_RTC_NVWR      JMP     RTC_NVWR        ;Call 09 $FF1B
  1822 00:FF1E: 4C 19 FA     B_RTC_INIT      JMP     INIT_RTC        ;Call 10 $FF1E
  1823                        ;
  1824 00:FF21: 4C B3 FF     B_Reserve11     JMP     RESERVE         ;Call 11 $FF21
  1825 00:FF24: 4C B3 FF     B_Reserve12     JMP     RESERVE         ;Call 12 $FF24
  1826 00:FF27: 4C B3 FF     B_Reserve13     JMP     RESERVE         ;Call 13 $FF27
  1827 00:FF2A: 4C B3 FF     B_Reserve14     JMP     RESERVE         ;Call 14 $FF2A
  1828                        ;
  1829 00:FF2D: 4C 60 F8     B_CNT_INIT      JMP     CNT_INIT        ;Call 15 $FF2D
  1830 00:FF30: 4C 68 F8     B_CNT_STRT      JMP     CNT_STRT        ;Call 16 $FF30
  1831 00:FF33: 4C 6B F8     B_CNT_STOP      JMP     CNT_STOP        ;Call 17 $FF33
  1832                        ;
  1833 00:FF36: 4C 00 F8     B_CHRIN_NW      JMP     CHRIN_NW        ;Call 18 $FF36
  1834 00:FF39: 4C 06 F8     B_CHRIN         JMP     CHRIN           ;Call 19 $FF39
  1835 00:FF3C: 4C 19 F8     B_CHROUT        JMP     CHROUT          ;Call 20 $FF3C
  1836                        ;
  1837 00:FF3F: 4C 30 F8     B_SET_DLY       JMP     SET_DLY         ;Call 21 $FF3F
  1838 00:FF42: 4C 37 F8     B_EXE_MSDLY     JMP     EXE_MSDLY       ;Call 22 $FF42
  1839 00:FF45: 4C 43 F8     B_EXE_LGDLY     JMP     EXE_LGDLY       ;Call 23 $FF45
  1840 00:FF48: 4C 58 F8     B_EXE_XLDLY     JMP     EXE_XLDLY       ;Call 24 $FF48
  1841                        ;
  1842 00:FF4B: 4C A3 FF     B_INIT_VEC      JMP     INIT_VEC        ;Call 25 $FF4B
  1843 00:FF4E: 4C 9F FF     B_INIT_CFG      JMP     INIT_CFG        ;Call 26 $FF4E
  1844 00:FF51: 4C A0 F9     B_INIT_2691     JMP     INIT_2691       ;Call 27 $FF51
  1845 00:FF54: 4C DA F9     B_RESET_2691    JMP     RESET_2691      ;Call 28 $FF54
  1846                        ;
  1847 00:FF57: 6C 0E 03     B_WRMMNVEC0     JMP     (WRMMNVEC0)     ;Call 29 $FF57
  1848 00:FF5A: 6C 0C 03     B_CLDMNVEC0     JMP     (CLDMNVEC0)     ;Call 30 $FF5A
  1849                        ;
  1850 00:FF5D: 78           B_COLDSTRT      SEI                     ;Call 31 $FF5D - Disable Interrupts (safety)
  1851 00:FF5E: D8                           CLD                     ;Clear decimal mode (safety)
  1852 00:FF5F: A2 00                        LDX     #$00            ;Index for length of page
  1853 00:FF61: 74 00        PAGE0_LP        STZ     $00,X           ;Clear Page Zero
  Tue May 18 2021 22:26                                                                                                    Page 36


  1854 00:FF63: CA                           DEX                     ;Decrement index
  1855 00:FF64: D0 FB                        BNE     PAGE0_LP        ;Loop back till done
  1856 00:FF66: CA                           DEX                     ;LDX #$FF ;-)
  1857 00:FF67: 9A                           TXS                     ;Set Stack Pointer
  1858                        ;
  1859 00:FF68: 20 9C FF                     JSR     INIT_PG03       ;Xfer default Vectors/HW Config to $0300
  1860 00:FF6B: 20 99 F9                     JSR     INIT_IO         ;Init I/O - UART (Console/Timer)
  1861                        ;
  1862                        ; Send BIOS init msg to console - note: X Reg is zero on return from INIT_IO
  1863                        ;
  1864 00:FF6E: BD D0 FF     BMSG_LP         LDA     BIOS_MSG,X      ;Get BIOS init msg
  1865 00:FF71: F0 06                        BEQ     CHECK_IO        ;If zero, msg done, Test for extra I/O
  1866 00:FF73: 20 19 F8                     JSR     CHROUT          ;Send to console
  1867 00:FF76: E8                           INX                     ;Increment Index
  1868 00:FF77: 80 F5                        BRA     BMSG_LP         ;Loop back until done
  1869                        CHECK_IO
  1870 00:FF79: 20 EB F9                     JSR     DETECT_RTC      ;Detect and Init RTC
  1871 00:FF7C: 20 94 FA                     JSR     DETECT_IDE      ;Detect and Init IDE
  1872 00:FF7F: 20 B3 FF                     JSR     RESERVE         ;Reserve one more Init routine for future use
  1873 00:FF82: 80 D6                        BRA     B_CLDMNVEC0     ;Branch to Coldstart Monitor
  1874                        ;
  1875                        IRQ_VECTOR                              ;This is the ROM start for the BRK/IRQ handler
  1876 00:FF84: 48                           PHA                     ;Save A Reg (3)
  1877 00:FF85: DA                           PHX                     ;Save X Reg (3)
  1878 00:FF86: 5A                           PHY                     ;Save Y Reg (3)
  1879 00:FF87: BA                           TSX                     ;Get Stack pointer (2)
  1880 00:FF88: BD 04 01                     LDA     $0100+4,X       ;Get Status Register (4)
  1881 00:FF8B: 29 10                        AND     #$10            ;Mask for BRK bit set (2)
  1882 00:FF8D: D0 03                        BNE     DO_BRK          ;If set, handle BRK (2/3)
  1883 00:FF8F: 6C 04 03                     JMP     (IRQVEC0)       ;Jump to Soft vectored IRQ Handler (6)
  1884 00:FF92: 6C 02 03     DO_BRK          JMP     (BRKVEC0)       ;Jump to Soft vectored BRK Handler (6)
  1885 00:FF95: 6C 00 03     NMI_ROM         JMP     (NMIVEC0)       ;Jump to Soft vectored NMI handler (6)
  1886                        ;
  1887                        ;This is the standard return for the IRQ/BRK handler routines
  1888                        ;
  1889 00:FF98: 7A           IRQ_EXIT0       PLY                     ;Restore Y Reg (4)
  1890 00:FF99: FA                           PLX                     ;Restore X Reg (4)
  1891 00:FF9A: 68                           PLA                     ;Restore A Reg (4)
  1892 00:FF9B: 40                           RTI                     ;Return from IRQ/BRK routine (6)
  1893                        ;
  1894 00:FF9C: 20 A3 FF     INIT_PG03       JSR     INIT_VEC        ;Init the Soft Vectors first
  1895 00:FF9F: A0 40        INIT_CFG        LDY     #$40            ;Get offset to Config data
  1896 00:FFA1: 80 02                        BRA     DATA_XFER       ;Go move the Config data to page $03
  1897 00:FFA3: A0 20        INIT_VEC        LDY     #$20            ;Get offset to Vector data
  1898                        ;
  1899 00:FFA5: 78           DATA_XFER       SEI                     ;Disable Interrupts, can be called via JMP table
  1900 00:FFA6: A2 20                        LDX     #$20            ;Set count for 32 bytes
  1901 00:FFA8: B9 9F FE     DATA_XFLP       LDA     VEC_TABLE-1,Y   ;Get ROM table data
  1902 00:FFAB: 99 FF 02                     STA     SOFTVEC-1,Y     ;Store in Soft table location
  1903 00:FFAE: 88                           DEY                     ;Decrement index
  1904 00:FFAF: CA                           DEX                     ;Decrement count
  1905 00:FFB0: D0 F6                        BNE     DATA_XFLP       ;Loop back till done
  1906 00:FFB2: 58                           CLI                     ;Re-enable interrupts
  1907 00:FFB3: 60           RESERVE         RTS                     ;Return to caller
  1908                        ;
  1909                        RTC_MSG
  1910                        ;
  1911                        ;This is a short BIOS message that is displayed when the DS1511 RTC is found
  1912 00:FFB4: 52 54 43 20                  .DB     "RTC found"
       00:FFB8: 66 6F 75 6E 
       00:FFBC: 64 
  1913 00:FFBD: 0D 0A 00                     .DB     $0D,$0A,$00
  1914                        ;
  Tue May 18 2021 22:26                                                                                                    Page 37


  1915                        IDE_MSG
  1916                        ;
  1917                        ;This is a short BIOS message that is displayed when the IDE controller is found
  1918 00:FFC0: 49 44 45 20                  .DB     "IDE found"
       00:FFC4: 66 6F 75 6E 
       00:FFC8: 64 
  1919 00:FFC9: 0D 0A 00                     .DB     $0D,$0A,$00
  1920                        ;
  1921                        ;The offset data here is used as an index to the Identity Block of Data from the IDE controller
  1922 00:FFCC: 78 79 7A 7B  LBA_OFFSET      .DB     120,121,122,123 ;Offset Data for LBA Size
  1923                        ;
  1924                        ; This BIOS version does not rely on CPU clock frequency for RTC timing. Timing is based on the
  1925                        ; SCC2691 UART Timer/Counter which has a fixed frequency of 3.6864MHz. Jiffy clock set at 10ms.
  1926                        ; NOTE: The SCC2691 UART can run with a CPU clock frequency up to 6MHz! (datasheet limitation).
  1927                        ; Edit Displayed clock rate at CPU_CLK below as needed if running "other" than 6MHz.
  1928                        ;
  1929                                .ORG    $FFD0   ;Hard coded BIOS message to the top of memory (Monitor uses this)
  1930                        ;BIOS init message - sent before jumping to the monitor coldstart vector.
  1931                        ; CO2BIOS 2.01 provides a longer BIOS message with more detail, fixed length/location!
  1932                        ;
  1933 00:FFD0: 0D 0A        BIOS_MSG        .DB     $0D,$0A         ;CR/LF
  1934 00:FFD2: 43 30 32 42                  .DB     "C02BIOS 3.04"  ;Updated Release Version
       00:FFD6: 49 4F 53 20 
       00:FFDA: 33 2E 30 34 
  1935 00:FFDE: 0D 0A                        .DB     $0D,$0A         ;CR/LF
  1936 00:FFE0: 31 34 2F 30                  .DB     "14/05/2021"    ;DD/MM/YYYY
       00:FFE4: 35 2F 32 30 
       00:FFE8: 32 31 
  1937 00:FFEA: 0D 0A                        .DB     $0D,$0A         ;CR/LF
  1938 00:FFEC: 57 36 35 43                  .DB     "W65C02@"       ;Display CPU type
       00:FFF0: 30 32 40 
  1939 00:FFF3: 36 4D 48 7A  CPU_CLK         .DB     "6MHz"          ;Displayed CPU Clock frequency
  1940 00:FFF7: 0D 0A 00                     .DB     $0D,$0A,$00     ;CR/LF and terminate string
  1941                        ;
  1942                                .ORG    $FFFA   ;65C02 Vectors:
  1943 00:FFFA: 95 FF                        .DW     NMI_ROM         ;NMI
  1944 00:FFFC: 5D FF                        .DW     B_COLDSTRT      ;RESET
  1945 00:FFFE: 84 FF                        .DW     IRQ_VECTOR      ;IRQ
  1946                                .END


      Lines assembled: 2283
      Errors: 0
