  Mon Feb  8 2021  9:20                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;
     2                        ; Enhanced BASIC for the C02 Pocket SBC, Version 2.22p5C02
     3                        ; Original version/source by Lee Davison w/updates to Version 2.22
     4                        ; Patches and updates by Klaus Dorman Version 2.22p4 - see below
     5                        ; "C" is appended to define CMOS instructions/addressing modes used
     6                        ; "C02" is appemded to define CMOS only and working with C02Monitor/C02BIOS
     7                        ; Modified source code to assemble with WDC Tools package
     8                        ; Changes by K. E. Maier - July-November 2018
     9                        ;   minor changes and cleanup as of 13th November 2018
    10                        ;
    11                        ; Additional functions added 25th September 2019
    12                        ;   LOAD/SAVE functions via Xmodem-CRC routines in C02Monitor Version 2.03
    13                        ;
    14                        ; Additional patches added. Klaus provided a 2.22p5 patched version 13th January 2020
    15                        ; those patches are included here, albeit not in identical code for all patches
    16                        ;
    17                        ; NOTE: a couple patches to correct p5 patches on 27th February 2020 - oops
    18                        ;
    19                        ; NOTE: startup code is now contained here. Any Monitor or OS can now call the
    20                        ; ROM start location of EhBasic. Five Monitor/OS routines are required for the
    21                        ; core functions required: CHRIN, CHROUT, LOAD, SAVE, EXIT.
    22                        ; These are defined below. - 31st March, 2020
    23                        ;
    24                        ; Several of the Basic messages have been abbreviated to keep ROM space below $2700 bytes.
    25                        ; Well, We blew past $2700 on size after including all the startup code, so Basic messages
    26                        ; have been restored to their original text... sniff. It's still less than 10KB, so yeah!
    27                        ; Latest version shows as version 2.22p5C02 - 23rd May, 2020
    28                        ;
    29                        ;       Assembler/Linker directives for WDC Tools
    30                        ;
    31                                PL      66      ;Page Length
    32                                PW      132     ;Page Width (# of char/line)
    33                                CHIP    W65C02S ;Enable WDC 65C02 instructions/addressing modes
    34                                INCLIST ON      ;Include listing file
    35                                PASS1   OFF     ;Set ON when used for debug
    36                        ;
    37                        ; Code changes include:
    38                        ;  Use ROM based CHRGET/CHRGOT routine with Page Zero pointer
    39                        ;  All Page zero usage is from the bottom ($00) up ($AF is max available)
    40                        ;  CMOS opcodes/addressing modes are used! tested with WDC65C02 only!
    41                        ;  Note: new instructions used include SMBx, RMBx, BBSx, BBRx! Note that
    42                        ;  this version will NOT run on a W65C816 in emulation mode!!
    43                        ;  Version renamed to Ver 2.22p5C02 (concurrency with Klaus' patched version)
    44                        ;
    45                        ; The following functions and all associated code (interrupt related)
    46                        ;  have been removed as they aren't needed with the CO2 Pocket SBC:
    47                        ; - IRQ
    48                        ; - RETIRQ
    49                        ; - NMI
    50                        ; - RETNMI
    51                        ; - OFF
    52                        ; It is known that the interrupt functions above were not fully implemented
    53                        ; and didn't really work without additional coding. As the NMI routine is a
    54                        ; Panic routine on the C02 Pocket SBC, there's no need to support this one.
    55                        ; Also, the C02 Pocket SBC has a full IRQ code stack that is extendable. It
    56                        ; provides full support for the SCC2691 UART for Transmit, Receive, Break,
    57                        ; a 10ms jiffy-clock plus delays and a benchmark timer. These routines can
  Mon Feb  8 2021  9:20                                                                                                    Page 2


    58                        ; be called via JMP table entries in the C02 BIOS and Monitor. They could
    59                        ; also be added as additional Basic Commands, but I don't have any current
    60                        ; plan to do so as of now.
    61                        ;
    62                        ; NOTE: BASIC Tokens are NOT the same due to removal of the above commands!!
    63                        ; This would only be a problem if someone did a binary save of a BASIC program
    64                        ; from the original code and then loaded it to this version of Basic. This is
    65                        ; unlikely however, as the original Enhanced Basic had NO Load or Save functions
    66                        ; implemented! Also note that Lee (when asked) recommended that Load and Save be
    67                        ; implemented using the LIST function redirected to Save and Basic Entry for Load.
    68                        ;
    69                        ; NOTE: The LOAD and SAVE functions implemented in this version are done as Binary!
    70                        ; The actual Load and Save routines are contained in the C02 Monitor code and called
    71                        ; via vectors. The C02 Monitor uses Xmodem-CRC for transferring data to and from
    72                        ; the host machine running the terminal emulator. Serial (OSX) and ExtraPutty have
    73                        ; been tested and work properly.
    74                        ;
    75                        ; An EXIT primary command has been added
    76                        ;  The EXIT command performs a JMP to the C02Monitor Warm start vector
    77                        ;  EhBasic can be re-entered via Warm start unless pages zero/four are changed
    78                        ;
    79                        ; 2.00      new revision numbers start here
    80                        ; 2.01      fixed LCASE$() and UCASE$()
    81                        ; 2.02      new get value routine done
    82                        ; 2.03      changed RND() to galoise method
    83                        ; 2.04      fixed SPC()
    84                        ; 2.05      new get value routine fixed
    85                        ; 2.06      changed USR() code
    86                        ; 2.07      fixed STR$()
    87                        ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
    88                        ; 2.09      fixed RND()
    89                        ; 2.10      integrated missed changes from an earlier version
    90                        ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
    91                        ; 2.21      fixed IF .. THEN RETURN to not cause error
    92                        ; 2.22      fixed RND() breaking the get byte routine
    93                        ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
    94                        ;              (bugsnquirks.txt notes 2, 4 and 5)
    95                        ;              tabs converted to spaces, tabwidth=6
    96                        ; 2.22p2    fixed can't continue error on 1st statement after direct mode
    97                        ;              changed INPUT to throw "break in line ##" on empty line input
    98                        ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
    99                        ;              fix provided by github user mgcaret
   100                        ;              fixed string compare of equal strings in direct mode returns FALSE
   101                        ; 2.22p4    fixed FALSE stored to a variable after a string compare
   102                        ;                 is > 0 and < 1E-16
   103                        ;              added additional stack floor protection for background interrupts
   104                        ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
   105                        ; 2.22p4C   Port to C02 Pocket SBC - SCC2691 UART Console, 32KB RAM / 32KB ROM, 6MHz CPU
   106                        ;
   107                        ; 2.22p5C   Updates from Klaus for specific bug fixes added to the CMOS version
   108                        ;
   109                        ; NOTE: Input Buffer and Vectors moved to Page $05 for BIOS Version 3.03 - 5th February 2021
   110                        ;
   111             00000000   ZPSTART         .EQU $00        ; Start of zero page workspace
   112                        ;
   113             00000000   LAB_WARM        .EQU ZPSTART    ; $00=BASIC warm start entry point
   114             00000001   Wrmjpl          .EQU LAB_WARM+1 ; BASIC warm start vector jump low byte
   115             00000002   Wrmjph          .EQU LAB_WARM+2 ; BASIC warm start vector jump high byte
   116                        
   117             00000003   Usrjmp          .EQU Wrmjph+1   ; USR function JMP address
   118             00000004   Usrjpl          .EQU Usrjmp+1   ; USR function JMP vector low byte
   119             00000005   Usrjph          .EQU Usrjmp+2   ; USR function JMP vector high byte
   120                        
  Mon Feb  8 2021  9:20                                                                                                    Page 3


   121             00000006   Nullct          .EQU Usrjph+1   ; nulls output after each line
   122             00000007   TPos            .EQU Nullct+1   ; BASIC terminal position byte
   123             00000008   TWidth          .EQU TPos+1     ; BASIC terminal width byte
   124             00000009   Iclim           .EQU TWidth+1   ; input column limit
   125             0000000A   Itempl          .EQU Iclim+1    ; temporary integer low byte
   126             0000000B   Itemph          .EQU Itempl+1   ; temporary integer high byte
   127                        
   128             0000000A   nums_1          .EQU Itempl     ; number to bin/hex string convert MSB
   129             0000000B   nums_2          .EQU nums_1+1   ; number to bin/hex string convert
   130             0000000C   nums_3          .EQU nums_1+2   ; number to bin/hex string convert LSB
   131                        
   132             0000000D   Srchc           .EQU nums_3+1   ; search character
   133             0000000D   Temp3           .EQU Srchc      ; temp byte used in number routines
   134             0000000E   Scnquo          .EQU Srchc+1    ; scan-between-quotes flag
   135             0000000E   Asrch           .EQU Scnquo     ; alt search character
   136                        
   137             0000000D   XOAw_l          .EQU Srchc      ; eXclusive OR, OR and AND word low byte
   138             0000000E   XOAw_h          .EQU Scnquo     ; eXclusive OR, OR and AND word high byte
   139                        
   140             0000000F   Ibptr           .EQU Scnquo+1   ; input buffer pointer
   141             0000000F   Dimcnt          .EQU Ibptr      ; # of dimensions
   142             0000000F   Tindx           .EQU Ibptr      ; token index
   143                        
   144             00000010   Defdim          .EQU Ibptr+1    ; default DIM flag
   145             00000011   Dtypef          .EQU Defdim+1   ; data type flag, $FF=string, $00=numeric
   146             00000012   Oquote          .EQU Dtypef+1   ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
   147             00000012   Gclctd          .EQU Oquote     ; garbage collected flag
   148             00000013   Sufnxf          .EQU Gclctd+1   ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
   149             00000014   Imode           .EQU Sufnxf+1   ; input mode flag, $00=INPUT, $80=READ
   150                        
   151             00000015   Cflag           .EQU Imode+1    ; comparison evaluation flag
   152                        
   153             00000016   TabSiz          .EQU Cflag+1    ; TAB step size (was input flag)
   154                        
   155             00000017   next_s          .EQU TabSiz+1   ; next descriptor stack address
   156                        
   157                        ; these two bytes form a word pointer to the item
   158                        ; currently on top of the descriptor stack
   159                        
   160             00000018   last_sl         .EQU next_s+1   ; last descriptor stack address low byte
   161             00000019   last_sh         .EQU last_sl+1  ; last descriptor stack address high byte (always $00)
   162                        
   163             0000001A   des_sk          .EQU last_sh+1  ; descriptor stack start address (temp strings)
   164                        
   165             00000023   ut1_pl          .EQU des_sk+9   ; utility pointer 1 low byte
   166             00000024   ut1_ph          .EQU ut1_pl+1   ; utility pointer 1 high byte
   167             00000025   ut2_pl          .EQU ut1_ph+1   ; utility pointer 2 low byte
   168             00000026   ut2_ph          .EQU ut2_pl+1   ; utility pointer 2 high byte
   169                        
   170             00000023   Temp_2          .EQU ut1_pl     ; temp byte for block move
   171                        
   172             00000027   FACt_1          .EQU ut2_ph+1   ; FAC temp mantissa1
   173             00000028   FACt_2          .EQU FACt_1+1   ; FAC temp mantissa2
   174             00000029   FACt_3          .EQU FACt_2+1   ; FAC temp mantissa3
   175                        
   176             00000028   dims_l          .EQU FACt_2     ; array dimension size low byte
   177             00000029   dims_h          .EQU FACt_3     ; array dimension size high byte
   178                        
   179             0000002A   TempB           .EQU FACt_1+3   ; temp page 0 byte
   180                        
   181             0000002B   Smeml           .EQU TempB+1    ; start of mem low byte         (Start-of-Basic)
   182             0000002C   Smemh           .EQU Smeml+1    ; start of mem high byte        (Start-of-Basic)
   183             0000002D   Svarl           .EQU Smemh+1    ; start of vars low byte        (Start-of-Variables)
  Mon Feb  8 2021  9:20                                                                                                    Page 4


   184             0000002E   Svarh           .EQU Svarl+1    ; start of vars high byte       (Start-of-Variables)
   185             0000002F   Sarryl          .EQU Svarh+1    ; var mem end low byte          (Start-of-Arrays)
   186             00000030   Sarryh          .EQU Sarryl+1   ; var mem end high byte         (Start-of-Arrays)
   187             00000031   Earryl          .EQU Sarryh+1   ; array mem end low byte        (End-of-Arrays)
   188             00000032   Earryh          .EQU Earryl+1   ; array mem end high byte       (End-of-Arrays)
   189             00000033   Sstorl          .EQU Earryh+1   ; string storage low byte       (String storage (moving down))
   190             00000034   Sstorh          .EQU Sstorl+1   ; string storage high byte      (String storage (moving down))
   191             00000035   Sutill          .EQU Sstorh+1   ; string utility ptr low byte
   192             00000036   Sutilh          .EQU Sutill+1   ; string utility ptr high byte
   193             00000037   Ememl           .EQU Sutilh+1   ; end of mem low byte           (Limit-of-memory)
   194             00000038   Ememh           .EQU Ememl+1    ; end of mem high byte          (Limit-of-memory)
   195             00000039   Clinel          .EQU Ememh+1    ; current line low byte         (Basic line number)
   196             0000003A   Clineh          .EQU Clinel+1   ; current line high byte        (Basic line number)
   197             0000003B   Blinel          .EQU Clineh+1   ; break line low byte           (Previous Basic line number)
   198             0000003C   Blineh          .EQU Blinel+1   ; break line high byte          (Previous Basic line number)
   199                        
   200             0000003D   Cpntrl          .EQU Blineh+1   ; continue pointer low byte
   201             0000003E   Cpntrh          .EQU Cpntrl+1   ; continue pointer high byte
   202                        
   203             0000003F   Dlinel          .EQU Cpntrh+1   ; current DATA line low byte
   204             00000040   Dlineh          .EQU Dlinel+1   ; current DATA line high byte
   205                        
   206             00000041   Dptrl           .EQU Dlineh+1   ; DATA pointer low byte
   207             00000042   Dptrh           .EQU Dptrl+1    ; DATA pointer high byte
   208                        
   209             00000043   Rdptrl          .EQU Dptrh+1    ; read pointer low byte
   210             00000044   Rdptrh          .EQU Rdptrl+1   ; read pointer high byte
   211                        
   212             00000045   Varnm1          .EQU Rdptrh+1   ; current var name 1st byte
   213             00000046   Varnm2          .EQU Varnm1+1   ; current var name 2nd byte
   214                        
   215             00000047   Cvaral          .EQU Varnm2+1   ; current var address low byte
   216             00000048   Cvarah          .EQU Cvaral+1   ; current var address high byte
   217                        
   218             00000049   Frnxtl          .EQU Cvarah+1   ; var pointer for FOR/NEXT low byte
   219             0000004A   Frnxth          .EQU Frnxtl+1   ; var pointer for FOR/NEXT high byte
   220                        
   221             00000049   Tidx1           .EQU Frnxtl     ; temp line index
   222                        
   223             00000049   Lvarpl          .EQU Frnxtl     ; let var pointer low byte
   224             0000004A   Lvarph          .EQU Frnxth     ; let var pointer high byte
   225                        
   226             0000004B   prstk           .EQU Frnxtl+2   ; precedence stacked flag
   227                        
   228             0000004D   comp_f          .EQU prstk+2    ; compare function flag, bits 0,1 and 2 used
   229                                                        ; bit 2 set if >
   230                                                        ; bit 1 set if =
   231                                                        ; bit 0 set if <
   232                        
   233             0000004E   func_l          .EQU comp_f+1   ; function pointer low byte
   234             0000004F   func_h          .EQU func_l+1   ; function pointer high byte
   235                        
   236             0000004E   garb_l          .EQU func_l     ; garbage collection working pointer low byte
   237             0000004F   garb_h          .EQU func_h     ; garbage collection working pointer high byte
   238                        
   239             00000050   des_2l          .EQU func_h+1   ; string descriptor_2 pointer low byte
   240             00000051   des_2h          .EQU des_2l+1   ; string descriptor_2 pointer high byte
   241                        
   242             00000052   g_step          .EQU des_2l+2   ; garbage collect step size
   243                        
   244             00000053   Fnxjmp          .EQU g_step+1   ; jump vector for functions
   245             00000054   Fnxjpl          .EQU Fnxjmp+1   ; functions jump vector low byte
   246             00000055   Fnxjph          .EQU Fnxjmp+2   ; functions jump vector high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 5


   247                        
   248             00000054   g_indx          .EQU Fnxjpl     ; garbage collect temp index
   249                        
   250             00000055   FAC2_r          .EQU Fnxjmp+2   ; FAC2 rounding byte
   251                        
   252             00000056   Adatal          .EQU FAC2_r+1   ; array data pointer low byte
   253             00000057   Adatah          .EQU Adatal+1   ; array data pointer high byte
   254                        
   255             00000056   Nbendl          .EQU Adatal     ; new block end pointer low byte
   256             00000057   Nbendh          .EQU Adatah     ; new block end pointer high byte
   257                        
   258             00000058   Obendl          .EQU Adatah+1   ; old block end pointer low byte
   259             00000059   Obendh          .EQU Obendl+1   ; old block end pointer high byte
   260                        
   261             0000005A   numexp          .EQU Obendh+1   ; string to float number exponent count
   262             0000005B   expcnt          .EQU numexp+1   ; string to float exponent count
   263                        
   264             0000005A   numbit          .EQU numexp     ; bit count for array element calculations
   265                        
   266             0000005C   numdpf          .EQU expcnt+1   ; string to float decimal point flag
   267             0000005D   expneg          .EQU numdpf+1   ; string to float eval exponent -ve flag
   268                        
   269             0000005C   Astrtl          .EQU numdpf     ; array start pointer low byte
   270             0000005D   Astrth          .EQU expneg     ; array start pointer high byte
   271                        
   272             0000005C   Histrl          .EQU numdpf     ; highest string low byte
   273             0000005D   Histrh          .EQU expneg     ; highest string high byte
   274                        
   275             0000005C   Baslnl          .EQU numdpf     ; BASIC search line pointer low byte
   276             0000005D   Baslnh          .EQU expneg     ; BASIC search line pointer high byte
   277                        
   278             0000005C   Fvar_l          .EQU numdpf     ; find/found variable pointer low byte
   279             0000005D   Fvar_h          .EQU expneg     ; find/found variable pointer high byte
   280                        
   281             0000005C   Ostrtl          .EQU numdpf     ; old block start pointer low byte
   282             0000005D   Ostrth          .EQU expneg     ; old block start pointer high byte
   283                        
   284             0000005C   Vrschl          .EQU numdpf     ; variable search pointer low byte
   285             0000005D   Vrschh          .EQU expneg     ; variable search pointer high byte
   286                        
   287             0000005E   FAC1_e          .EQU expneg+1   ; FAC1 exponent
   288             0000005F   FAC1_1          .EQU FAC1_e+1   ; FAC1 mantissa1
   289             00000060   FAC1_2          .EQU FAC1_e+2   ; FAC1 mantissa2
   290             00000061   FAC1_3          .EQU FAC1_e+3   ; FAC1 mantissa3
   291             00000062   FAC1_s          .EQU FAC1_e+4   ; FAC1 sign (b7)
   292                        
   293             0000005E   str_ln          .EQU FAC1_e     ; string length
   294             0000005F   str_pl          .EQU FAC1_1     ; string pointer low byte
   295             00000060   str_ph          .EQU FAC1_2     ; string pointer high byte
   296                        
   297             00000060   des_pl          .EQU FAC1_2     ; string descriptor pointer low byte
   298             00000061   des_ph          .EQU FAC1_3     ; string descriptor pointer high byte
   299                        
   300             00000061   mids_l          .EQU FAC1_3     ; MID$ string temp length byte
   301                        
   302             00000063   negnum          .EQU FAC1_e+5   ; string to float eval -ve flag
   303             00000063   numcon          .EQU negnum     ; series evaluation constant count
   304                        
   305             00000064   FAC1_o          .EQU negnum+1   ; FAC1 overflow byte
   306                        
   307             00000065   FAC2_e          .EQU FAC1_o+1   ; FAC2 exponent
   308             00000066   FAC2_1          .EQU FAC2_e+1   ; FAC2 mantissa1
   309             00000067   FAC2_2          .EQU FAC2_e+2   ; FAC2 mantissa2
  Mon Feb  8 2021  9:20                                                                                                    Page 6


   310             00000068   FAC2_3          .EQU FAC2_e+3   ; FAC2 mantissa3
   311             00000069   FAC2_s          .EQU FAC2_e+4   ; FAC2 sign (b7)
   312                        
   313             0000006A   FAC_sc          .EQU FAC2_e+5   ; FAC sign comparison, Acc#1 vs #2
   314             0000006B   FAC1_r          .EQU FAC_sc+1   ; FAC1 rounding byte
   315                        
   316             0000006A   ssptr_l         .EQU FAC_sc     ; string start pointer low byte
   317             0000006B   ssptr_h         .EQU FAC1_r     ; string start pointer high byte
   318                        
   319             0000006A   sdescr          .EQU FAC_sc     ; string descriptor pointer
   320                        
   321             0000006C   csidx           .EQU FAC1_r+1   ; line crunch save index
   322             0000006C   Asptl           .EQU csidx      ; array size/pointer low byte
   323             0000006D   Aspth           .EQU csidx+1    ; array size/pointer high byte
   324                        
   325             0000006C   Btmpl           .EQU Asptl      ; BASIC pointer temp low byte
   326             0000006D   Btmph           .EQU Aspth      ; BASIC pointer temp low byte
   327                        
   328             0000006C   Cptrl           .EQU Asptl      ; BASIC pointer temp low byte
   329             0000006D   Cptrh           .EQU Aspth      ; BASIC pointer temp low byte
   330                        
   331             0000006C   Sendl           .EQU Asptl      ; BASIC pointer temp low byte
   332             0000006D   Sendh           .EQU Aspth      ; BASIC pointer temp low byte
   333                        ;
   334                        ; CHRGET/CHRGOT routine now located in ROM
   335                        ; The two pointers below are accessed via ROM
   336                        ; Reduces Page zero usage by quite a bit with a minor performance penalty
   337                        ; CMOS addressing mode used, saves memory and execution time
   338                        ;
   339             0000006E   Bpntrl          .EQU Sendh+1    ; BASIC execute (get byte) pointer low byte
   340             0000006F   Bpntrh          .EQU Bpntrl+1   ; BASIC execute (get byte) pointer high byte
   341                        
   342             00000070   Rbyte4          .EQU Bpntrh+1   ; extra PRNG byte
   343                        
   344             00000071   Rbyte1          .EQU Rbyte4+1   ; most significant PRNG byte
   345             00000072   Rbyte2          .EQU Rbyte4+2   ; middle PRNG byte
   346             00000073   Rbyte3          .EQU Rbyte4+3   ; least significant PRNG byte
   347                        
   348             00000074   Decss           .EQU Rbyte3+1   ; number to decimal string start
   349             00000075   Decssp1         .EQU Decss+1    ; number to decimal string start
   350             00000085   ZPLastByte      .EQU Decss+17   ; last declared byte in Page Zero
   351                        
   352                        ; Updated C02BIOS and C02Monitor to version 3.01
   353                        ; Note: C02BIOS uses Page Zero locations from $D8 - $FF
   354                        ; C02Monitor uses Page Zero locations from $A0 - $D7
   355                        
   356                        ; add page zero variables for Xmodem transfer using the CO2 Monitor routines
   357                        
   358             000000A0   PGZERO_ST       .EQU $A0               ; Start of Page Zero usage (C02 Monitor)
   359                        
   360             000000B6   PROMPTL         .EQU PGZERO_ST+22      ; Prompt string address
   361             000000B7   PROMPTH         .EQU PGZERO_ST+23
   362             000000B8   SRCL            .EQU PGZERO_ST+24      ; Source address for memory operations
   363             000000B9   SRCH            .EQU PGZERO_ST+25
   364             000000BA   TGTL            .EQU PGZERO_ST+26      ; Target address for memory operations
   365             000000BB   TGTH            .EQU PGZERO_ST+27
   366             000000BC   LENL            .EQU PGZERO_ST+28      ; Length address for memory operations
   367             000000BD   LENH            .EQU PGZERO_ST+29
   368                        
   369             000000C6   OPXMDM          .EQU PGZERO_ST+38      ; Saved Opcode/Xmodem Flag variable
   370             000000CA   PTRL            .EQU PGZERO_ST+42      ; Data pointer lo byte
   371             000000CB   PTRH            .EQU PGZERO_ST+43      ; Data pointer hi byte
   372             000000CC   BLKNO           .EQU PGZERO_ST+44      ; Block number
  Mon Feb  8 2021  9:20                                                                                                    Page 7


   373                        
   374                        ; token values needed for BASIC
   375                        
   376                        ; primary command tokens (can start a statement)
   377                        
   378             00000080   TK_END            .EQU $80             ; END token
   379             00000081   TK_FOR            .EQU TK_END+1        ; FOR token
   380             00000082   TK_NEXT           .EQU TK_FOR+1        ; NEXT token
   381             00000083   TK_DATA           .EQU TK_NEXT+1       ; DATA token
   382             00000084   TK_INPUT          .EQU TK_DATA+1       ; INPUT token
   383             00000085   TK_DIM            .EQU TK_INPUT+1      ; DIM token
   384             00000086   TK_READ           .EQU TK_DIM+1        ; READ token
   385             00000087   TK_LET            .EQU TK_READ+1       ; LET token
   386             00000088   TK_DEC            .EQU TK_LET+1        ; DEC token
   387             00000089   TK_GOTO           .EQU TK_DEC+1        ; GOTO token
   388             0000008A   TK_RUN            .EQU TK_GOTO+1       ; RUN token
   389             0000008B   TK_IF             .EQU TK_RUN+1        ; IF token
   390             0000008C   TK_RESTORE        .EQU TK_IF+1         ; RESTORE token
   391             0000008D   TK_GOSUB          .EQU TK_RESTORE+1    ; GOSUB token
   392             0000008E   TK_RETURN         .EQU TK_GOSUB+1      ; RETURN token
   393             0000008F   TK_REM            .EQU TK_RETURN+1     ; REM token
   394             00000090   TK_STOP           .EQU TK_REM+1        ; STOP token
   395             00000091   TK_ON             .EQU TK_STOP+1       ; ON token
   396             00000092   TK_NULL           .EQU TK_ON+1         ; NULL token
   397             00000093   TK_INC            .EQU TK_NULL+1       ; INC token
   398             00000094   TK_WAIT           .EQU TK_INC+1        ; WAIT token
   399             00000095   TK_LOAD           .EQU TK_WAIT+1       ; LOAD token
   400             00000096   TK_SAVE           .EQU TK_LOAD+1       ; SAVE token
   401             00000097   TK_DEF            .EQU TK_SAVE+1       ; DEF token
   402             00000098   TK_POKE           .EQU TK_DEF+1        ; POKE token
   403             00000099   TK_DOKE           .EQU TK_POKE+1       ; DOKE token
   404             0000009A   TK_CALL           .EQU TK_DOKE+1       ; CALL token
   405             0000009B   TK_DO             .EQU TK_CALL+1       ; DO token
   406             0000009C   TK_LOOP           .EQU TK_DO+1         ; LOOP token
   407             0000009D   TK_PRINT          .EQU TK_LOOP+1       ; PRINT token
   408             0000009E   TK_CONT           .EQU TK_PRINT+1      ; CONT token
   409             0000009F   TK_LIST           .EQU TK_CONT+1       ; LIST token
   410             000000A0   TK_CLEAR          .EQU TK_LIST+1       ; CLEAR token
   411             000000A1   TK_NEW            .EQU TK_CLEAR+1      ; NEW token
   412             000000A2   TK_WIDTH          .EQU TK_NEW+1        ; WIDTH token
   413             000000A3   TK_GET            .EQU TK_WIDTH+1      ; GET token
   414             000000A4   TK_SWAP           .EQU TK_GET+1        ; SWAP token
   415             000000A5   TK_BITSET         .EQU TK_SWAP+1       ; BITSET token
   416             000000A6   TK_BITCLR         .EQU TK_BITSET+1     ; BITCLR token
   417             000000A7   TK_EXIT           .EQU TK_BITCLR+1     ; EXIT token
   418                        
   419                        ; secondary command tokens, can't start a statement
   420                        
   421             000000A8   TK_TAB            .EQU TK_EXIT+1       ; TAB token
   422             000000A9   TK_ELSE           .EQU TK_TAB+1        ; ELSE token
   423             000000AA   TK_TO             .EQU TK_ELSE+1       ; TO token
   424             000000AB   TK_FN             .EQU TK_TO+1         ; FN token
   425             000000AC   TK_SPC            .EQU TK_FN+1         ; SPC token
   426             000000AD   TK_THEN           .EQU TK_SPC+1        ; THEN token
   427             000000AE   TK_NOT            .EQU TK_THEN+1       ; NOT token
   428             000000AF   TK_STEP           .EQU TK_NOT+1        ; STEP token
   429             000000B0   TK_UNTIL          .EQU TK_STEP+1       ; UNTIL token
   430             000000B1   TK_WHILE          .EQU TK_UNTIL+1      ; WHILE token
   431                        
   432                        ; operator tokens
   433                        
   434             000000B2   TK_PLUS           .EQU TK_WHILE+1      ; + token
   435             000000B3   TK_MINUS          .EQU TK_PLUS+1       ; - token
  Mon Feb  8 2021  9:20                                                                                                    Page 8


   436             000000B4   TK_MUL            .EQU TK_MINUS+1      ; * token
   437             000000B5   TK_DIV            .EQU TK_MUL+1        ; / token
   438             000000B6   TK_POWER          .EQU TK_DIV+1        ; ^ token
   439             000000B7   TK_AND            .EQU TK_POWER+1      ; AND token
   440             000000B8   TK_EOR            .EQU TK_AND+1        ; EOR token
   441             000000B9   TK_OR             .EQU TK_EOR+1        ; OR token
   442             000000BA   TK_RSHIFT         .EQU TK_OR+1         ; RSHIFT token
   443             000000BB   TK_LSHIFT         .EQU TK_RSHIFT+1     ; LSHIFT token
   444             000000BC   TK_GT             .EQU TK_LSHIFT+1     ; > token
   445             000000BD   TK_EQUAL          .EQU TK_GT+1         ; = token
   446             000000BE   TK_LT             .EQU TK_EQUAL+1      ; < token
   447                        
   448                        ; function tokens
   449                        
   450             000000BF   TK_SGN            .EQU TK_LT+1         ; SGN token
   451             000000C0   TK_INT            .EQU TK_SGN+1        ; INT token
   452             000000C1   TK_ABS            .EQU TK_INT+1        ; ABS token
   453             000000C2   TK_USR            .EQU TK_ABS+1        ; USR token
   454             000000C3   TK_FRE            .EQU TK_USR+1        ; FRE token
   455             000000C4   TK_POS            .EQU TK_FRE+1        ; POS token
   456             000000C5   TK_SQR            .EQU TK_POS+1        ; SQR token
   457             000000C6   TK_RND            .EQU TK_SQR+1        ; RND token
   458             000000C7   TK_LOG            .EQU TK_RND+1        ; LOG token
   459             000000C8   TK_EXP            .EQU TK_LOG+1        ; EXP token
   460             000000C9   TK_COS            .EQU TK_EXP+1        ; COS token
   461             000000CA   TK_SIN            .EQU TK_COS+1        ; SIN token
   462             000000CB   TK_TAN            .EQU TK_SIN+1        ; TAN token
   463             000000CC   TK_ATN            .EQU TK_TAN+1        ; ATN token
   464             000000CD   TK_PEEK           .EQU TK_ATN+1        ; PEEK token
   465             000000CE   TK_DEEK           .EQU TK_PEEK+1       ; DEEK token
   466             000000CF   TK_SADD           .EQU TK_DEEK+1       ; SADD token
   467             000000D0   TK_LEN            .EQU TK_SADD+1       ; LEN token
   468             000000D1   TK_STRS           .EQU TK_LEN+1        ; STR$ token
   469             000000D2   TK_VAL            .EQU TK_STRS+1       ; VAL token
   470             000000D3   TK_ASC            .EQU TK_VAL+1        ; ASC token
   471             000000D4   TK_UCASES         .EQU TK_ASC+1        ; UCASE$ token
   472             000000D5   TK_LCASES         .EQU TK_UCASES+1     ; LCASE$ token
   473             000000D6   TK_CHRS           .EQU TK_LCASES+1     ; CHR$ token
   474             000000D7   TK_HEXS           .EQU TK_CHRS+1       ; HEX$ token
   475             000000D8   TK_BINS           .EQU TK_HEXS+1       ; BIN$ token
   476             000000D9   TK_BITTST         .EQU TK_BINS+1       ; BITTST token
   477             000000DA   TK_MAX            .EQU TK_BITTST+1     ; MAX token
   478             000000DB   TK_MIN            .EQU TK_MAX+1        ; MIN token
   479             000000DC   TK_PI             .EQU TK_MIN+1        ; PI token
   480             000000DD   TK_TWOPI          .EQU TK_PI+1         ; TWOPI token
   481             000000DE   TK_VPTR           .EQU TK_TWOPI+1      ; VARPTR token
   482             000000DF   TK_LEFTS          .EQU TK_VPTR+1       ; LEFT$ token
   483             000000E0   TK_RIGHTS         .EQU TK_LEFTS+1      ; RIGHT$ token
   484             000000E1   TK_MIDS           .EQU TK_RIGHTS+1     ; MID$ token
   485                        
   486                        ; offsets from a base of X or Y
   487                        
   488             00000000   PLUS_0            .EQU $00       ; X or Y plus 0
   489             00000001   PLUS_1            .EQU $01       ; X or Y plus 1
   490             00000002   PLUS_2            .EQU $02       ; X or Y plus 2
   491             00000003   PLUS_3            .EQU $03       ; X or Y plus 3
   492                        
   493             00000014   STACK_RES         .EQU #20       ; reserved stack space
   494                        
   495             00000100   LAB_STAK          .EQU $0100     ; stack bottom, no offset
   496                        
   497             000001FE   LAB_SKFE          .EQU LAB_STAK+$FE
   498                                                         ; flushed stack address
  Mon Feb  8 2021  9:20                                                                                                    Page 9


   499             000001FF   LAB_SKFF          .EQU LAB_STAK+$FF
   500                                                         ; flushed stack address
   501                        
   502                        ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
   503                        ; the input buffer must not cross a page boundary and must not overlap with
   504                        ; program RAM pages!
   505                        
   506             00000500   Ibuffs          .EQU $0500     ; Start of input buffer
   507             0000057E   Ibuffe          .EQU $0500+$7E ; end of input buffer (127 bytes)
   508                        
   509             0000057F   ccflag          .EQU Ibuffe+1  ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
   510             00000580   ccbyte          .EQU ccflag+1  ; BASIC CTRL-C byte
   511             00000581   ccnull          .EQU ccbyte+1  ; BASIC CTRL-C byte timeout
   512                        
   513             00000582   VEC_CC          .EQU ccnull+1  ; CTRL-C check vector
   514                        
   515             00000584   VEC_IN          .EQU VEC_CC+2  ; input vector
   516             00000586   VEC_OUT         .EQU VEC_IN+2  ; output vector
   517             00000588   VEC_LD          .EQU VEC_OUT+2 ; load vector
   518             0000058A   VEC_SV          .EQU VEC_LD+2  ; save vector
   519             0000058C   VEC_EXIT        .EQU VEC_SV+2  ; exit vector
   520                        
   521             00000800   Ram_base        .EQU $0800     ; start of user RAM (1st 2KB used/reserved)
   522             00008000   Ram_top         .EQU $8000     ; end of user RAM+1 ($8000 is start of ROM)
   523                        
   524                        ; Host system routine addresses are defined here for convienence.
   525                        ; They provide the following functions required by EhBasic:
   526                        ; CHRIN_NW      - Character Input with no waiting - carry flag indicates data
   527                        ; CHROUT        - Character Output
   528                        ; LOAD          - Load data via Xmodem-CRC
   529                        ; SAVE          - Save data via Xmodem-CRC
   530                        ; EXIT          - Exit to warm start of C02 Monitor
   531                        
   532             0000FF36   B_CHRIN_NW      .EQU    $FF36
   533             0000FF3C   B_CHROUT        .EQU    $FF3C
   534             0000E015   M_LOAD          .EQU    $E015
   535             0000E012   M_SAVE          .EQU    $E012
   536             0000E003   M_EXIT          .EQU    $E003
   537                        
   538                        ; The start address can be changed, noting the BIOS/Monitor locations
   539                        
   540                              .ORG    $B000              ; Start of Basic in ROM
   541                                                         ; C02Monitor starts at $E000
   542                                                         ; C02BIOS starts at $F800
   543                        
   544                        ROM_START
   545                        ; BASIC cold start entry point
   546                        
   547 00:B000: 4C 68 D0           JMP   BOOT_BASIC        ; jump to Basic cold start routine
   548                        
   549                        ; new page $04 initialisation, copy ROM data to RAM
   550                        ; consists of the vectors Input/Output/Load/Save/Exit
   551                        ; and Control-C flags, pointers
   552                        
   553                        LAB_COLD
   554 00:B003: A2 0E              LDX   #PG4_TABE-PG4_TABS-1 ; byte count-1
   555                        LAB_2D13
   556 00:B005: BD 4D D0           LDA   PG4_TABS,X        ; get byte
   557 00:B008: 9D 7F 05           STA   ccflag,X          ; store in page 4
   558 00:B00B: CA                 DEX                     ; decrement count
   559 00:B00C: 10 F7              BPL   LAB_2D13          ; loop if not done
   560                        
   561 00:B00E: 9A                 TXS                     ; reset stack pointer (X Reg = $FF from above)
  Mon Feb  8 2021  9:20                                                                                                    Page 10


   562 00:B00F: 86 3A              STX   Clineh            ; set current line high byte (set immediate mode)
   563                        
   564 00:B011: A9 4C              LDA   #$4C              ; code for JMP
   565 00:B013: 85 53              STA   Fnxjmp            ; save for jump vector for functions
   566                        
   567                        ; copy block from StrTab to $0000 - $0012
   568                        
   569                        LAB_GMEM
   570 00:B015: A2 0B              LDX   #EndTab-StrTab-1  ; set byte count-1
   571                        TabLoop
   572 00:B017: BD 5C D0           LDA   StrTab,X          ; get byte from table
   573 00:B01A: 95 00              STA   PLUS_0,X          ; save byte in page zero
   574 00:B01C: CA                 DEX                     ; decrement count
   575 00:B01D: 10 F8              BPL   TabLoop           ; loop until done
   576                        
   577                        ; set-up start values
   578                        
   579 00:B01F: 64 64              STZ   FAC1_o            ; clear FAC1 overflow byte
   580 00:B021: 64 19              STZ   last_sh           ; clear descriptor stack top item pointer high byte
   581                        
   582 00:B023: A9 0E              LDA   #$0E              ; set default tab size
   583 00:B025: 85 16              STA   TabSiz            ; save it
   584 00:B027: A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
   585 00:B029: 85 52              STA   g_step            ; save it
   586 00:B02B: A2 1A              LDX   #des_sk           ; descriptor stack start
   587 00:B02D: 86 17              STX   next_s            ; set descriptor stack pointer
   588                        
   589                        ; bypass user memory prompt, just test, show and go
   590                        ; we get here with Itempl/h = Ram_base
   591                        
   592                        LAB_2D93
   593 00:B02F: A9 55              LDA   #$55              ; set test byte
   594 00:B031: 92 0A              STA   (Itempl)          ; save via temporary integer
   595 00:B033: D2 0A              CMP   (Itempl)          ; compare via temporary integer
   596 00:B035: D0 1B              BNE   LAB_2DB6          ; branch if fail
   597                        
   598 00:B037: 0A                 ASL                     ; shift test byte left (now $AA)
   599 00:B038: 92 0A              STA   (Itempl)          ; save via temporary integer
   600 00:B03A: D2 0A              CMP   (Itempl)          ; compare via temporary integer
   601 00:B03C: D0 14              BNE   LAB_2DB6          ; branch if fail
   602                        
   603 00:B03E: A9 00              LDA   #$00              ; get zero
   604 00:B040: 92 0A              STA   (Itempl)          ; clear tested byte
   605 00:B042: D2 0A              CMP   (Itempl)          ; compare via temporary integer
   606 00:B044: D0 0C              BNE   LAB_2DB6          ; branch if fail
   607                        
   608 00:B046: E6 0A              INC   Itempl            ; increment temporary integer low byte
   609 00:B048: D0 E5              BNE   LAB_2D93          ; branch if no overflow
   610                        
   611 00:B04A: E6 0B              INC   Itemph            ; increment temporary integer high byte
   612 00:B04C: A5 0B              LDA   Itemph            ; get high byte
   613 00:B04E: C9 80              CMP   #>Ram_top         ; compare with top of RAM+1
   614 00:B050: D0 DD              BNE   LAB_2D93          ; branch and continue testing RAM
   615                        
   616                        LAB_2DB6
   617 00:B052: A5 0A              LDA   Itempl            ; get temporary integer low byte
   618 00:B054: A4 0B              LDY   Itemph            ; get temporary integer high byte ($00)
   619                        
   620 00:B056: 85 37              STA   Ememl             ; set end of mem low byte
   621 00:B058: 84 38              STY   Ememh             ; set end of mem high byte
   622 00:B05A: 85 33              STA   Sstorl            ; set bottom of string space low byte
   623 00:B05C: 84 34              STY   Sstorh            ; set bottom of string space high byte
   624                        
  Mon Feb  8 2021  9:20                                                                                                    Page 11


   625 00:B05E: A0 00              LDY   #<Ram_base        ; set start addr low byte
   626 00:B060: A2 08              LDX   #>Ram_base        ; set start addr high byte
   627 00:B062: C8                 INY                     ; increment Ram_base low byte
   628 00:B063: 84 2B              STY   Smeml             ; save start of mem low byte
   629 00:B065: 86 2C              STX   Smemh             ; save start of mem high byte
   630                        
   631 00:B067: 20 32 B8           JSR   LAB_CRLF          ; print CR/LF
   632 00:B06A: 20 1E B3           JSR   LAB_1463          ; do "NEW" and "CLEAR"
   633 00:B06D: A5 37              LDA   Ememl             ; get end of mem low byte
   634 00:B06F: 38                 SEC                     ; set carry for subtract
   635 00:B070: E5 2B              SBC   Smeml             ; subtract start of mem low byte
   636 00:B072: AA                 TAX                     ; copy to X
   637 00:B073: A5 38              LDA   Ememh             ; get end of mem high byte
   638 00:B075: E5 2C              SBC   Smemh             ; subtract start of mem high byte
   639 00:B077: 20 FB C9           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
   640 00:B07A: A9 E0              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
   641 00:B07C: A0 D0              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
   642 00:B07E: 20 73 B8           JSR   LAB_18C3          ; print null terminated string from memory
   643 00:B081: 6C 01 00           JMP   (Wrmjpl)          ; jump to warm start
   644                        
   645                        ; open up space in memory
   646                        ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   647                        
   648                        ; Nbendl,Nbendh - new block end address (A/Y)
   649                        ; Obendl,Obendh - old block end address
   650                        ; Ostrtl,Ostrth - old block start address
   651                        
   652                        ; returns with ..
   653                        
   654                        ; Nbendl,Nbendh - new block start address (high byte - $100)
   655                        ; Obendl,Obendh - old block start address (high byte - $100)
   656                        ; Ostrtl,Ostrth - old block start address (unchanged)
   657                        
   658                        LAB_11CF
   659 00:B084: 20 D1 B0           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
   660                                                      ; addr to check is in AY (low/high)
   661 00:B087: 85 31              STA   Earryl            ; save new array mem end low byte
   662 00:B089: 84 32              STY   Earryh            ; save new array mem end high byte
   663                        
   664                        ; open up space in memory
   665                        ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   666                        ; don't set array end
   667                        
   668                        LAB_11D6
   669 00:B08B: 38                 SEC                     ; set carry for subtract
   670 00:B08C: A5 58              LDA   Obendl            ; get block end low byte
   671 00:B08E: E5 5C              SBC   Ostrtl            ; subtract block start low byte
   672 00:B090: A8                 TAY                     ; copy MOD(block length/$100) byte to Y
   673 00:B091: A5 59              LDA   Obendh            ; get block end high byte
   674 00:B093: E5 5D              SBC   Ostrth            ; subtract block start high byte
   675 00:B095: AA                 TAX                     ; copy block length high byte to X
   676 00:B096: E8                 INX                     ; +1 to allow for count=0 exit
   677 00:B097: 98                 TYA                     ; copy block length low byte to A
   678 00:B098: F0 24              BEQ   LAB_120A          ; branch if length low byte=0
   679                        
   680                                                      ; block is (X-1)*256+Y bytes, do the Y bytes first
   681 00:B09A: 38                 SEC                     ; set carry for add + 1, two's complement
   682 00:B09B: 49 FF              EOR   #$FF              ; invert low byte for subtract
   683 00:B09D: 65 58              ADC   Obendl            ; add block end low byte
   684 00:B09F: 85 58              STA   Obendl            ; save corrected old block end low byte
   685 00:B0A1: B0 03              BCS   LAB_11F3          ; branch if no underflow
   686 00:B0A3: C6 59              DEC   Obendh            ; else decrement block end high byte
   687 00:B0A5: 38                 SEC                     ; set carry for add + 1, two's complement
  Mon Feb  8 2021  9:20                                                                                                    Page 12


   688                        LAB_11F3
   689 00:B0A6: 98                 TYA                     ; get MOD(block length/$100) byte
   690 00:B0A7: 49 FF              EOR   #$FF              ; invert low byte for subtract
   691 00:B0A9: 65 56              ADC   Nbendl            ; add destination end low byte
   692 00:B0AB: 85 56              STA   Nbendl            ; save modified new block end low byte
   693 00:B0AD: B0 08              BCS   LAB_1203          ; branch if no underflow
   694 00:B0AF: C6 57              DEC   Nbendh            ; else decrement block end high byte
   695 00:B0B1: 80 04              BRA   LAB_1203          ; branch always
   696                        
   697                        LAB_11FF
   698 00:B0B3: B1 58              LDA   (Obendl),Y        ; get byte from source
   699 00:B0B5: 91 56              STA   (Nbendl),Y        ; copy byte to destination
   700                        LAB_1203
   701 00:B0B7: 88                 DEY                     ; decrement index
   702 00:B0B8: D0 F9              BNE   LAB_11FF          ; loop until Y=0
   703                                                      ; now do Y=0 indexed byte
   704 00:B0BA: B1 58              LDA   (Obendl),Y        ; get byte from source
   705 00:B0BC: 91 56              STA   (Nbendl),Y        ; save byte to destination
   706                        LAB_120A
   707 00:B0BE: C6 59              DEC   Obendh            ; decrement source pointer high byte
   708 00:B0C0: C6 57              DEC   Nbendh            ; decrement destination pointer high byte
   709 00:B0C2: CA                 DEX                     ; decrement block count
   710 00:B0C3: D0 F2              BNE   LAB_1203          ; loop until count = $0
   711 00:B0C5: 60                 RTS
   712                        
   713                        ; check room on stack for A bytes
   714                        ; stack too deep? do OM error
   715                        
   716                        LAB_1212                      ; patched for stack floor
   717 00:B0C6: 18                 CLC                     ; prep ADC
   718 00:B0C7: 69 14              ADC   #STACK_RES        ; stack pointer lower limit before interrupts
   719 00:B0C9: 85 2A              STA   TempB             ; save result in temp byte
   720 00:B0CB: BA                 TSX                     ; copy stack
   721 00:B0CC: E4 2A              CPX   TempB             ; compare new "limit" with stack
   722 00:B0CE: 90 2F              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
   723 00:B0D0: 60                 RTS
   724                        
   725                        ; check available memory, "Out of memory" error if no room
   726                        ; addr to check is in AY (low/high)
   727                        
   728                        LAB_121F
   729 00:B0D1: C4 34              CPY   Sstorh            ; compare bottom of string mem high byte
   730 00:B0D3: 90 29              BCC   LAB_124B          ; if less then exit (is ok)
   731                        
   732 00:B0D5: D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
   733                        
   734                                                      ; high byte was =, now do low byte
   735 00:B0D7: C5 33              CMP   Sstorl            ; compare with bottom of string mem low byte
   736 00:B0D9: 90 23              BCC   LAB_124B          ; if less then exit (is ok)
   737                        
   738                                                      ; addr is > string storage ptr (oops!)
   739                        LAB_1229
   740 00:B0DB: 48                 PHA                     ; push addr low byte
   741 00:B0DC: A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
   742 00:B0DE: 98                 TYA                     ; copy addr high byte (to push on stack)
   743                        
   744                                                      ; save misc numeric work area
   745                        LAB_122D
   746 00:B0DF: 48                 PHA                     ; push byte
   747 00:B0E0: B5 55              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
   748 00:B0E2: CA                 DEX                     ; decrement index
   749 00:B0E3: 10 FA              BPL   LAB_122D          ; loop until all done
   750                        
  Mon Feb  8 2021  9:20                                                                                                    Page 13


   751 00:B0E5: 20 7B C1           JSR   LAB_GARB          ; garbage collection routine
   752                        
   753                                                      ; restore misc numeric work area
   754 00:B0E8: A2 00              LDX   #$00              ; clear the index to restore bytes
   755                        LAB_1238
   756 00:B0EA: 68                 PLA                     ; pop byte
   757 00:B0EB: 95 56              STA   Adatal,X          ; save byte to Adatal to expneg
   758 00:B0ED: E8                 INX                     ; increment index
   759 00:B0EE: E0 08              CPX   #$08              ; compare with end + 1
   760 00:B0F0: 30 F8              BMI   LAB_1238          ; loop if more to do
   761                        
   762 00:B0F2: 7A                 PLY                     ; pop addr high byte
   763 00:B0F3: 68                 PLA                     ; pop addr low byte
   764 00:B0F4: C4 34              CPY   Sstorh            ; compare bottom of string mem high byte
   765 00:B0F6: 90 06              BCC   LAB_124B          ; if less then exit (is ok)
   766                        
   767 00:B0F8: D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
   768                        
   769                                                      ; high byte was =, now do low byte
   770 00:B0FA: C5 33              CMP   Sstorl            ; compare with bottom of string mem low byte
   771 00:B0FC: B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
   772                                                      ; ok exit, carry clear
   773                        LAB_124B
   774 00:B0FE: 60                 RTS
   775                        
   776                        ; do "Out of memory" error then warm start
   777                        
   778                        LAB_OMER
   779 00:B0FF: A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
   780                        
   781                        ; do error #X, then warm start
   782                        
   783                        LAB_XERR
   784 00:B101: 20 32 B8           JSR   LAB_CRLF          ; print CR/LF
   785                        
   786 00:B104: BD 12 D6           LDA   LAB_BAER,X        ; get error message pointer low byte
   787 00:B107: BC 13 D6           LDY   LAB_BAER+1,X      ; get error message pointer high byte
   788 00:B10A: 20 73 B8           JSR   LAB_18C3          ; print null terminated string from memory
   789                        
   790 00:B10D: 20 57 B3           JSR   LAB_1491          ; flush stack and clear continue flag
   791 00:B110: A9 4F              LDA   #<LAB_EMSG        ; point to " Error" low addr
   792 00:B112: A0 D7              LDY   #>LAB_EMSG        ; point to " Error" high addr
   793                        LAB_1269
   794 00:B114: 20 73 B8           JSR   LAB_18C3          ; print null terminated string from memory
   795 00:B117: A4 3A              LDY   Clineh            ; get current line high byte
   796 00:B119: C8                 INY                     ; increment it
   797 00:B11A: F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
   798                        
   799                                                      ; else print line number
   800 00:B11C: 20 F0 C9           JSR   LAB_2953          ; print " in line [LINE #]"
   801                        
   802                        ; BASIC warm start entry point
   803                        ; wait for Basic command
   804                        
   805                        LAB_1274
   806 00:B11F: A9 60              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
   807 00:B121: A0 D7              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
   808                        
   809 00:B123: 20 73 B8           JSR   LAB_18C3          ; go do print string
   810                        
   811                        ; wait for Basic command (no "Ready")
   812                        
   813                        LAB_127D
  Mon Feb  8 2021  9:20                                                                                                    Page 14


   814 00:B126: 20 15 B2           JSR   LAB_1357          ; call for BASIC input
   815                        LAB_1280
   816 00:B129: 86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
   817 00:B12B: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
   818 00:B12D: 20 BB CF           JSR   LAB_GBYT          ; scan memory
   819 00:B130: F0 F4              BEQ   LAB_127D          ; loop while null
   820                        
   821                        ; got to interpret input line now ..
   822                        
   823 00:B132: A2 FF              LDX   #$FF              ; current line to null value
   824 00:B134: 86 3A              STX   Clineh            ; set current line high byte
   825 00:B136: 90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
   826                        
   827                                                      ; no line number .. immediate mode
   828 00:B138: 20 46 B2           JSR   LAB_13A6          ; crunch keywords into Basic tokens
   829 00:B13B: 4C B9 B4           JMP   LAB_15F6          ; go scan and interpret code
   830                        
   831                        ; handle new BASIC line
   832                        
   833                        LAB_1295
   834 00:B13E: 20 00 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
   835 00:B141: 20 46 B2           JSR   LAB_13A6          ; crunch keywords into Basic tokens
   836 00:B144: 84 0F              STY   Ibptr             ; save index pointer to end of crunched line
   837 00:B146: 20 F2 B2           JSR   LAB_SSLN          ; search BASIC for temp integer line number
   838 00:B149: 90 44              BCC   LAB_12E6          ; branch if not found
   839                        
   840                                                      ; aroooogah! line # already exists! delete it
   841 00:B14B: A0 01              LDY   #$01              ; set index to next line pointer high byte
   842 00:B14D: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
   843 00:B14F: 85 24              STA   ut1_ph            ; save it
   844 00:B151: A5 2D              LDA   Svarl             ; get start of vars low byte
   845 00:B153: 85 23              STA   ut1_pl            ; save it
   846 00:B155: A5 5D              LDA   Baslnh            ; get found line pointer high byte
   847 00:B157: 85 26              STA   ut2_ph            ; save it
   848 00:B159: A5 5C              LDA   Baslnl            ; get found line pointer low byte
   849 00:B15B: 88                 DEY                     ; decrement index
   850 00:B15C: F1 5C              SBC   (Baslnl),Y        ; subtract next line pointer low byte
   851 00:B15E: 18                 CLC                     ; clear carry for add
   852 00:B15F: 65 2D              ADC   Svarl             ; add start of vars low byte
   853 00:B161: 85 2D              STA   Svarl             ; save new start of vars low byte
   854 00:B163: 85 25              STA   ut2_pl            ; save destination pointer low byte
   855 00:B165: A5 2E              LDA   Svarh             ; get start of vars high byte
   856 00:B167: 69 FF              ADC   #$FF              ; -1 + carry
   857 00:B169: 85 2E              STA   Svarh             ; save start of vars high byte
   858 00:B16B: E5 5D              SBC   Baslnh            ; subtract found line pointer high byte
   859 00:B16D: AA                 TAX                     ; copy to block count
   860 00:B16E: 38                 SEC                     ; set carry for subtract
   861 00:B16F: A5 5C              LDA   Baslnl            ; get found line pointer low byte
   862 00:B171: E5 2D              SBC   Svarl             ; subtract start of vars low byte
   863 00:B173: A8                 TAY                     ; copy to bytes in first block count
   864 00:B174: B0 03              BCS   LAB_12D0          ; branch if overflow
   865                        
   866 00:B176: E8                 INX                     ; increment block count (correct for =0 loop exit)
   867 00:B177: C6 26              DEC   ut2_ph            ; decrement destination high byte
   868                        LAB_12D0
   869 00:B179: 18                 CLC                     ; clear carry for add
   870 00:B17A: 65 23              ADC   ut1_pl            ; add source pointer low byte
   871 00:B17C: 90 03              BCC   LAB_12D8          ; branch if no overflow
   872                        
   873 00:B17E: C6 24              DEC   ut1_ph            ; else decrement source pointer high byte
   874 00:B180: 18                 CLC                     ; clear carry
   875                        
   876                                                      ; close up memory to delete old line
  Mon Feb  8 2021  9:20                                                                                                    Page 15


   877                        LAB_12D8
   878 00:B181: B1 23              LDA   (ut1_pl),Y        ; get byte from source
   879 00:B183: 91 25              STA   (ut2_pl),Y        ; copy to destination
   880 00:B185: C8                 INY                     ; increment index
   881 00:B186: D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
   882                        
   883 00:B188: E6 24              INC   ut1_ph            ; increment source pointer high byte
   884 00:B18A: E6 26              INC   ut2_ph            ; increment destination pointer high byte
   885 00:B18C: CA                 DEX                     ; decrement block count
   886 00:B18D: D0 F2              BNE   LAB_12D8          ; loop until all done
   887                        
   888                                                      ; got new line in buffer and no existing same #
   889                        LAB_12E6
   890 00:B18F: AD 00 05           LDA   Ibuffs            ; get byte from start of input buffer
   891 00:B192: F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
   892                        
   893                                                      ; got new line and it isn't empty line
   894 00:B194: A5 37              LDA   Ememl             ; get end of mem low byte
   895 00:B196: A4 38              LDY   Ememh             ; get end of mem high byte
   896 00:B198: 85 33              STA   Sstorl            ; set bottom of string space low byte
   897 00:B19A: 84 34              STY   Sstorh            ; set bottom of string space high byte
   898 00:B19C: A5 2D              LDA   Svarl             ; get start of vars low byte (end of BASIC)
   899 00:B19E: 85 58              STA   Obendl            ; save old block end low byte
   900 00:B1A0: A4 2E              LDY   Svarh             ; get start of vars high byte (end of BASIC)
   901 00:B1A2: 84 59              STY   Obendh            ; save old block end high byte
   902 00:B1A4: 65 0F              ADC   Ibptr             ; add input buffer pointer (also buffer length)
   903 00:B1A6: 90 01              BCC   LAB_1301          ; branch if no overflow from add
   904 00:B1A8: C8                 INY                     ; else increment high byte
   905                        LAB_1301
   906 00:B1A9: 85 56              STA   Nbendl            ; save new block end low byte (move to, low byte)
   907 00:B1AB: 84 57              STY   Nbendh            ; save new block end high byte
   908 00:B1AD: 20 84 B0           JSR   LAB_11CF          ; open up space in memory
   909                                                      ; old start pointer Ostrtl,Ostrth set by the find line call
   910 00:B1B0: A5 31              LDA   Earryl            ; get array mem end low byte
   911 00:B1B2: A4 32              LDY   Earryh            ; get array mem end high byte
   912 00:B1B4: 85 2D              STA   Svarl             ; save start of vars low byte
   913 00:B1B6: 84 2E              STY   Svarh             ; save start of vars high byte
   914 00:B1B8: A4 0F              LDY   Ibptr             ; get input buffer pointer (also buffer length)
   915 00:B1BA: 88                 DEY                     ; adjust for loop type
   916                        LAB_1311
   917 00:B1BB: B9 FC 04           LDA   Ibuffs-4,Y        ; get byte from crunched line
   918 00:B1BE: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   919 00:B1C0: 88                 DEY                     ; decrement count
   920 00:B1C1: C0 03              CPY   #$03              ; compare with first byte-1
   921 00:B1C3: D0 F6              BNE   LAB_1311          ; continue while count <> 3
   922                        
   923 00:B1C5: A5 0B              LDA   Itemph            ; get line # high byte
   924 00:B1C7: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   925 00:B1C9: 88                 DEY                     ; decrement count
   926 00:B1CA: A5 0A              LDA   Itempl            ; get line # low byte
   927 00:B1CC: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   928 00:B1CE: 88                 DEY                     ; decrement count
   929 00:B1CF: A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
   930                                                      ; byte then a zero already here would stop the chain rebuild
   931                                                      ; as it would think it was the [EOT] marker.
   932 00:B1D1: 91 5C              STA   (Baslnl),Y        ; save it to program memory
   933                        
   934                        LAB_1319
   935 00:B1D3: 20 33 B3           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
   936 00:B1D6: A6 2B              LDX   Smeml             ; get start of mem low byte
   937 00:B1D8: A5 2C              LDA   Smemh             ; get start of mem high byte
   938 00:B1DA: A0 01              LDY   #$01              ; index to high byte of next line pointer
   939                        LAB_1325
  Mon Feb  8 2021  9:20                                                                                                    Page 16


   940 00:B1DC: 86 23              STX   ut1_pl            ; set line start pointer low byte
   941 00:B1DE: 85 24              STA   ut1_ph            ; set line start pointer high byte
   942 00:B1E0: B1 23              LDA   (ut1_pl),Y        ; get it
   943 00:B1E2: F0 18              BEQ   LAB_133E          ; exit if end of program
   944                        
   945                        ; rebuild chaining of Basic lines
   946                        
   947 00:B1E4: A0 04              LDY   #$04              ; point to first code byte of line
   948                                                      ; there is always 1 byte + [EOL] as null entries are deleted
   949                        LAB_1330
   950 00:B1E6: C8                 INY                     ; next code byte
   951 00:B1E7: B1 23              LDA   (ut1_pl),Y        ; get byte
   952 00:B1E9: D0 FB              BNE   LAB_1330          ; loop if not [EOL]
   953                        
   954 00:B1EB: 38                 SEC                     ; set carry for add + 1
   955 00:B1EC: 98                 TYA                     ; copy end index
   956 00:B1ED: 65 23              ADC   ut1_pl            ; add to line start pointer low byte
   957 00:B1EF: AA                 TAX                     ; copy to X
   958 00:B1F0: A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
   959 00:B1F2: 91 23              STA   (ut1_pl),Y        ; set next line pointer low byte
   960 00:B1F4: 98                 TYA                     ; clear A
   961 00:B1F5: 65 24              ADC   ut1_ph            ; add line start pointer high byte + carry
   962 00:B1F7: C8                 INY                     ; increment index to high byte
   963 00:B1F8: 91 23              STA   (ut1_pl),Y        ; save next line pointer low byte
   964 00:B1FA: 80 E0              BRA   LAB_1325          ; go do next line, branch always, carry clear
   965                        
   966                        LAB_133E
   967 00:B1FC: FF C6 03           BBS7  OPXMDM, DO_RDY    ; test to see if LOAD was executed
   968 00:B1FF: 4C 26 B1           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
   969                        DO_RDY
   970 00:B202: 77 C6              RMB7  OPXMDM            ; reset flag bit to zero
   971 00:B204: 4C 1F B1           JMP   LAB_1274          ; print Ready msg and wait for Basic command
   972                        
   973                        ; print "? " and get BASIC input
   974                        
   975                        LAB_INLN
   976 00:B207: 20 8C B8           JSR   LAB_18E3          ; print "?" character
   977 00:B20A: 20 88 B8           JSR   LAB_18E0          ; print " "
   978 00:B20D: 80 06              BRA   LAB_1357          ; call for BASIC input and return
   979                        
   980                        ; receive line from keyboard
   981                        
   982                                                      ; $08 as delete key (BACKSPACE on standard keyboard)
   983                        LAB_134B
   984 00:B20F: 20 8E B8           JSR   LAB_PRNA          ; go print the character
   985 00:B212: CA                 DEX                     ; decrement the buffer counter (delete)
   986 00:B213: 80 02              BRA   LAB_1359          ; branch over next instruction, save 1 clock cycle
   987                        
   988                        ; call for BASIC input (main entry point)
   989                        
   990                        LAB_1357
   991 00:B215: A2 00              LDX   #$00              ; clear BASIC line buffer pointer
   992                        LAB_1359
   993 00:B217: 20 3E D0           JSR   V_INPT            ; call scan input device
   994 00:B21A: 90 FB              BCC   LAB_1359          ; loop if no byte
   995                        
   996 00:B21C: F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
   997                        
   998 00:B21E: C9 07              CMP   #$07              ; compare with [BELL]
   999 00:B220: F0 10              BEQ   LAB_1378          ; branch if [BELL]
  1000                        
  1001 00:B222: C9 0D              CMP   #$0D              ; compare with [CR]
  1002 00:B224: F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
  Mon Feb  8 2021  9:20                                                                                                    Page 17


  1003                        
  1004 00:B226: E0 00              CPX   #$00              ; compare pointer with $00
  1005 00:B228: D0 04              BNE   LAB_1374          ; branch if not empty
  1006                        
  1007                        ; next two lines ignore any non print character and [SPACE] if input buffer empty
  1008                        
  1009 00:B22A: C9 21              CMP   #$21              ; compare with [SP]+1
  1010 00:B22C: 90 E9              BCC   LAB_1359          ; if < ignore character
  1011                        
  1012                        LAB_1374
  1013 00:B22E: C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
  1014 00:B230: F0 DD              BEQ   LAB_134B          ; go delete last character
  1015                        
  1016                        LAB_1378
  1017 00:B232: E0 7E              CPX   #Ibuffe-Ibuffs    ; compare character count with max
  1018 00:B234: B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
  1019                        
  1020 00:B236: 9D 00 05           STA   Ibuffs,X          ; else store in buffer
  1021 00:B239: E8                 INX                     ; increment pointer
  1022                        LAB_137F
  1023 00:B23A: 20 8E B8           JSR   LAB_PRNA          ; go print the character
  1024 00:B23D: 80 D8              BRA   LAB_1359          ; always loop for next character
  1025                        
  1026                        LAB_1384
  1027 00:B23F: 4C 2B B8           JMP   LAB_1866          ; do CR/LF exit to BASIC
  1028                        
  1029                        ; announce buffer full
  1030                        
  1031                        LAB_138E
  1032 00:B242: A9 07              LDA   #$07              ; [BELL] character into A
  1033 00:B244: 80 F4              BRA   LAB_137F          ; go print the [BELL] but ignore input character
  1034                                                      ; branch always
  1035                        
  1036                        ; crunch keywords into Basic tokens
  1037                        ; position independent buffer version ..
  1038                        ; faster, dictionary search version ....
  1039                        
  1040                        LAB_13A6
  1041 00:B246: A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
  1042 00:B248: 38                 SEC                     ; set carry for subtract
  1043 00:B249: A5 6E              LDA   Bpntrl            ; get basic execute pointer low byte
  1044 00:B24B: E9 00              SBC   #<Ibuffs          ; subtract input buffer start pointer
  1045 00:B24D: AA                 TAX                     ; copy result to X (index past line # if any)
  1046 00:B24E: 86 12              STX   Oquote            ; clear open quote/DATA flag
  1047                        LAB_13AC
  1048 00:B250: BD 00 05           LDA   Ibuffs,X          ; get byte from input buffer
  1049 00:B253: F0 51              BEQ   LAB_13EC          ; if null save byte then exit
  1050                        
  1051 00:B255: C9 5F              CMP   #'_'              ; compare with "_"
  1052 00:B257: B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
  1053                        
  1054 00:B259: C9 3C              CMP   #'<'              ; compare with "<"
  1055 00:B25B: B0 0E              BCS   LAB_13CC          ; if >= go crunch now
  1056                        
  1057 00:B25D: C9 30              CMP   #'0'              ; compare with "0"
  1058 00:B25F: B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
  1059                        
  1060 00:B261: 85 0E              STA   Scnquo            ; save buffer byte as search character
  1061 00:B263: C9 22              CMP   #$22              ; is it quote character?
  1062 00:B265: F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
  1063                        
  1064 00:B267: C9 2A              CMP   #'*'              ; compare with "*"
  1065 00:B269: 90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
  Mon Feb  8 2021  9:20                                                                                                    Page 18


  1066                                                      ; else crunch now
  1067                        LAB_13CC
  1068 00:B26B: 24 12              BIT   Oquote            ; get open quote/DATA token flag
  1069 00:B26D: 70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
  1070                                                      ; go save byte then continue crunching
  1071 00:B26F: 86 2A              STX   TempB             ; save buffer read index
  1072 00:B271: 84 6C              STY   csidx             ; copy buffer save index
  1073 00:B273: A0 9A              LDY   #<TAB_1STC        ; get keyword first character table low address
  1074 00:B275: 84 25              STY   ut2_pl            ; save pointer low byte
  1075 00:B277: A0 D2              LDY   #>TAB_1STC        ; get keyword first character table high address
  1076 00:B279: 84 26              STY   ut2_ph            ; save pointer high byte
  1077 00:B27B: A0 00              LDY   #$00              ; clear table pointer
  1078                        
  1079                        LAB_13D0
  1080 00:B27D: D1 25              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
  1081 00:B27F: F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
  1082                        
  1083 00:B281: 90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
  1084                                                      ; Y and save to crunched
  1085                        
  1086 00:B283: C8                 INY                     ; else increment pointer
  1087 00:B284: 80 F7              BRA   LAB_13D0          ; and loop (branch always)
  1088                        
  1089                        ; have matched first character of some keyword
  1090                        
  1091                        LAB_13D1
  1092 00:B286: 98                 TYA                     ; copy matching index
  1093 00:B287: 0A                 ASL                     ; *2 (bytes per pointer)
  1094 00:B288: AA                 TAX                     ; copy to new index
  1095 00:B289: BD B8 D2           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
  1096 00:B28C: 85 25              STA   ut2_pl            ; save pointer low byte
  1097 00:B28E: BD B9 D2           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
  1098 00:B291: 85 26              STA   ut2_ph            ; save pointer high byte
  1099 00:B293: A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
  1100 00:B295: A6 2A              LDX   TempB             ; restore buffer read index
  1101                        
  1102                        LAB_13D6
  1103 00:B297: C8                 INY                     ; next table byte
  1104 00:B298: B1 25              LDA   (ut2_pl),Y        ; get byte from table
  1105                        LAB_13D8
  1106 00:B29A: 30 08              BMI   LAB_13EA          ; all bytes matched so go save token
  1107 00:B29C: E8                 INX                     ; next buffer byte
  1108 00:B29D: DD 00 05           CMP   Ibuffs,X          ; compare with byte from input buffer
  1109 00:B2A0: F0 F5              BEQ   LAB_13D6          ; go compare next if match
  1110 00:B2A2: 80 2B              BRA   LAB_1417          ; branch if >< (not found keyword)
  1111                        
  1112                        LAB_13EA
  1113 00:B2A4: A4 6C              LDY   csidx             ; restore save index
  1114                                                      ; save crunched to output
  1115                        LAB_13EC
  1116 00:B2A6: E8                 INX                     ; increment buffer index (to next input byte)
  1117 00:B2A7: C8                 INY                     ; increment save index (to next output byte)
  1118 00:B2A8: 99 00 05           STA   Ibuffs,Y          ; save byte to output
  1119 00:B2AB: C9 00              CMP   #$00              ; set the flags, set carry
  1120 00:B2AD: F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
  1121                        
  1122                                                      ; A holds token or byte here
  1123 00:B2AF: E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
  1124 00:B2B1: F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
  1125                        
  1126                                                      ; A now holds token-$3A
  1127 00:B2B3: C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
  1128 00:B2B5: D0 02              BNE   LAB_1401          ; branch if not DATA
  Mon Feb  8 2021  9:20                                                                                                    Page 19


  1129                        
  1130                                                      ; token was : or DATA
  1131                        LAB_13FF
  1132 00:B2B7: 85 12              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
  1133                        LAB_1401
  1134 00:B2B9: 49 55              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
  1135 00:B2BB: D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
  1136 00:B2BD: 85 0E              STA   Asrch             ; else was REM so set search for [EOL]
  1137                                                      ; loop for REM, "..." etc.
  1138                        LAB_1408
  1139 00:B2BF: BD 00 05           LDA   Ibuffs,X          ; get byte from input buffer
  1140 00:B2C2: F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
  1141 00:B2C4: C5 0E              CMP   Asrch             ; compare with stored character
  1142 00:B2C6: F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
  1143                                                      ; entry for copy string in quotes, don't crunch
  1144                        LAB_1410
  1145 00:B2C8: C8                 INY                     ; increment buffer save index
  1146 00:B2C9: 99 00 05           STA   Ibuffs,Y          ; save byte to output
  1147 00:B2CC: E8                 INX                     ; increment buffer read index
  1148 00:B2CD: D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
  1149                                                      ; not found keyword this go
  1150                        LAB_1417
  1151 00:B2CF: A6 2A              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
  1152                        
  1153                                                      ; now find the end of this word in the table
  1154                        LAB_141B
  1155 00:B2D1: B1 25              LDA   (ut2_pl),Y        ; get table byte
  1156 00:B2D3: 08                 PHP                     ; save status
  1157 00:B2D4: C8                 INY                     ; increment table index
  1158 00:B2D5: 28                 PLP                     ; restore byte status
  1159 00:B2D6: 10 F9              BPL   LAB_141B          ; if not end of keyword go do next
  1160                        
  1161 00:B2D8: B1 25              LDA   (ut2_pl),Y        ; get byte from keyword table
  1162 00:B2DA: D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
  1163                        
  1164                                                      ; reached end of table with no match
  1165 00:B2DC: BD 00 05           LDA   Ibuffs,X          ; restore byte from input buffer
  1166 00:B2DF: 80 C3              BRA   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
  1167                                                      ; go save byte in output and continue crunching
  1168                                                      ; reached [EOL]
  1169                        LAB_142A
  1170 00:B2E1: C8                 INY                     ; increment pointer
  1171 00:B2E2: C8                 INY                     ; increment pointer (makes it next line pointer high byte)
  1172 00:B2E3: 99 00 05           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
  1173 00:B2E6: C8                 INY                     ; adjust for line copy
  1174 00:B2E7: C8                 INY                     ; adjust for line copy
  1175 00:B2E8: C8                 INY                     ; adjust for line copy
  1176 00:B2E9: A5 6E              LDA   Bpntrl            ; test for $00
  1177 00:B2EB: D0 02              BNE   LAB_142P          ; not $00
  1178 00:B2ED: C6 6F              DEC   Bpntrh            ; allow for increment when $xx00
  1179                        LAB_142P
  1180 00:B2EF: C6 6E              DEC   Bpntrl            ; allow for increment
  1181 00:B2F1: 60                 RTS
  1182                        
  1183                        ; search Basic for temp integer line number from start of mem
  1184                        
  1185                        LAB_SSLN
  1186 00:B2F2: A5 2B              LDA   Smeml             ; get start of mem low byte
  1187 00:B2F4: A6 2C              LDX   Smemh             ; get start of mem high byte
  1188                        
  1189                        ; search Basic for temp integer line number from AX
  1190                        ; returns carry set if found
  1191                        ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
  Mon Feb  8 2021  9:20                                                                                                    Page 20


  1192                        
  1193                        LAB_SHLN
  1194 00:B2F6: A0 01              LDY   #$01              ; set index
  1195 00:B2F8: 85 5C              STA   Baslnl            ; save low byte as current
  1196 00:B2FA: 86 5D              STX   Baslnh            ; save high byte as current
  1197 00:B2FC: B1 5C              LDA   (Baslnl),Y        ; get pointer high byte from addr
  1198 00:B2FE: F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
  1199                        
  1200 00:B300: A0 03              LDY   #$03              ; set index to line # high byte
  1201 00:B302: B1 5C              LDA   (Baslnl),Y        ; get line # high byte
  1202 00:B304: 88                 DEY                     ; decrement index (point to low byte)
  1203 00:B305: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1204 00:B307: D0 04              BNE   LAB_1455          ; if <> skip low byte check
  1205                        
  1206 00:B309: B1 5C              LDA   (Baslnl),Y        ; get line # low byte
  1207 00:B30B: C5 0A              CMP   Itempl            ; compare with temporary integer low byte
  1208                        LAB_1455
  1209 00:B30D: B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
  1210                        
  1211                        LAB_1456
  1212 00:B30F: 88                 DEY                     ; decrement index to next line ptr high byte
  1213 00:B310: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
  1214 00:B312: AA                 TAX                     ; copy to X
  1215 00:B313: 88                 DEY                     ; decrement index to next line ptr low byte
  1216 00:B314: B1 5C              LDA   (Baslnl),Y        ; get next line pointer low byte
  1217 00:B316: 80 DE              BRA   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
  1218                                                      ; (carry always clear)
  1219                        
  1220                        LAB_145E
  1221 00:B318: F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
  1222                        
  1223                        LAB_145F
  1224 00:B31A: 18                 CLC                     ; clear found flag
  1225                        LAB_1460
  1226 00:B31B: 60                 RTS
  1227                        
  1228                        ; perform NEW
  1229                        
  1230                        LAB_NEW
  1231 00:B31C: D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
  1232                        
  1233                        LAB_1463
  1234 00:B31E: A9 00              LDA   #$00              ; clear A
  1235 00:B320: A8                 TAY                     ; clear Y
  1236 00:B321: 91 2B              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
  1237 00:B323: C8                 INY                     ; increment index
  1238 00:B324: 91 2B              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
  1239 00:B326: 18                 CLC                     ; clear carry
  1240 00:B327: A5 2B              LDA   Smeml             ; get start of mem low byte
  1241 00:B329: 69 02              ADC   #$02              ; calculate end of BASIC low byte
  1242 00:B32B: 85 2D              STA   Svarl             ; save start of vars low byte
  1243 00:B32D: A5 2C              LDA   Smemh             ; get start of mem high byte
  1244 00:B32F: 69 00              ADC   #$00              ; add any carry
  1245 00:B331: 85 2E              STA   Svarh             ; save start of vars high byte
  1246                        
  1247                        ; reset execution to start, clear vars and flush stack
  1248                        
  1249                        LAB_1477
  1250 00:B333: 18                 CLC                     ; clear carry
  1251 00:B334: A5 2B              LDA   Smeml             ; get start of mem low byte
  1252 00:B336: 69 FF              ADC   #$FF              ; -1
  1253 00:B338: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1254 00:B33A: A5 2C              LDA   Smemh             ; get start of mem high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 21


  1255 00:B33C: 69 FF              ADC   #$FF              ; -1+carry
  1256 00:B33E: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1257                        
  1258                        ; "CLEAR" command gets here
  1259                        
  1260                        LAB_147A
  1261 00:B340: A5 37              LDA   Ememl             ; get end of mem low byte
  1262 00:B342: A4 38              LDY   Ememh             ; get end of mem high byte
  1263 00:B344: 85 33              STA   Sstorl            ; set bottom of string space low byte
  1264 00:B346: 84 34              STY   Sstorh            ; set bottom of string space high byte
  1265 00:B348: A5 2D              LDA   Svarl             ; get start of vars low byte
  1266 00:B34A: A4 2E              LDY   Svarh             ; get start of vars high byte
  1267 00:B34C: 85 2F              STA   Sarryl            ; save var mem end low byte
  1268 00:B34E: 84 30              STY   Sarryh            ; save var mem end high byte
  1269 00:B350: 85 31              STA   Earryl            ; save array mem end low byte
  1270 00:B352: 84 32              STY   Earryh            ; save array mem end high byte
  1271 00:B354: 20 03 B5           JSR   LAB_161A          ; perform RESTORE command
  1272                        
  1273                        ; flush stack and clear continue flag
  1274                        
  1275                        LAB_1491
  1276 00:B357: A2 1A              LDX   #des_sk           ; set descriptor stack pointer
  1277 00:B359: 86 17              STX   next_s            ; save descriptor stack pointer
  1278 00:B35B: FA                 PLX                     ; pull return address low byte
  1279 00:B35C: 68                 PLA                     ; pull return address high byte
  1280 00:B35D: 8E FE 01           STX   LAB_SKFE          ; save to cleared stack
  1281 00:B360: 8D FF 01           STA   LAB_SKFF          ; save to cleared stack
  1282 00:B363: A2 FD              LDX   #$FD              ; new stack pointer
  1283 00:B365: 9A                 TXS                     ; reset stack
  1284 00:B366: 64 13              STZ   Sufnxf            ; clear subscript/FNX flag
  1285                        LAB_14A6
  1286 00:B368: 60                 RTS
  1287                        
  1288                        ; perform CLEAR
  1289                        
  1290                        LAB_CLEAR
  1291 00:B369: F0 D5              BEQ   LAB_147A          ; if no following token go do "CLEAR"
  1292                                                      ; else there was a following token (go do syntax error)
  1293 00:B36B: 60                 RTS
  1294                        
  1295                        ; perform LIST [n][-m]
  1296                        ; bigger, faster version (a _lot_ faster)
  1297                        
  1298                        LAB_LIST
  1299 00:B36C: 90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
  1300 00:B36E: F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
  1301                        
  1302 00:B370: C9 B3              CMP   #TK_MINUS         ; compare with token for -
  1303 00:B372: D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
  1304                        
  1305                                                      ; LIST [[n][-m]]
  1306                                                      ; this bit sets the n , if present, as the start and end
  1307                        LAB_14BD
  1308 00:B374: 20 00 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1309 00:B377: 20 F2 B2           JSR   LAB_SSLN          ; search BASIC for temp integer line number
  1310                                                      ; (pointer in Baslnl/Baslnh)
  1311 00:B37A: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  1312 00:B37D: F0 0C              BEQ   LAB_14D4          ; branch if no more characters
  1313                        
  1314                                                      ; this bit checks the - is present
  1315 00:B37F: C9 B3              CMP   #TK_MINUS         ; compare with token for -
  1316 00:B381: D0 98              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
  1317                        
  Mon Feb  8 2021  9:20                                                                                                    Page 22


  1318                                                      ; LIST [n]-m
  1319                                                      ; the - was there so set m as the end value
  1320 00:B383: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  1321 00:B386: 20 00 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1322 00:B389: D0 90              BNE   LAB_1460          ; exit if not ok
  1323                        
  1324                        LAB_14D4
  1325 00:B38B: A5 0A              LDA   Itempl            ; get temporary integer low byte
  1326 00:B38D: 05 0B              ORA   Itemph            ; OR temporary integer high byte
  1327 00:B38F: D0 06              BNE   LAB_14E2          ; branch if start set
  1328                        
  1329 00:B391: A9 FF              LDA   #$FF              ; set for -1
  1330 00:B393: 85 0A              STA   Itempl            ; set temporary integer low byte
  1331 00:B395: 85 0B              STA   Itemph            ; set temporary integer high byte
  1332                        LAB_14E2
  1333 00:B397: A0 01              LDY   #$01              ; set index for line
  1334 00:B399: 84 12              STY   Oquote            ; clear open quote flag
  1335 00:B39B: 20 32 B8           JSR   LAB_CRLF          ; print CR/LF
  1336 00:B39E: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
  1337                                                      ; pointer initially set by search at LAB_14BD
  1338 00:B3A0: F0 3E              BEQ   LAB_152B          ; if null all done so exit
  1339 00:B3A2: 20 D9 B4           JSR   LAB_1629          ; do CRTL-C check vector
  1340                        
  1341 00:B3A5: C8                 INY                     ; increment index for line
  1342 00:B3A6: B1 5C              LDA   (Baslnl),Y        ; get line # low byte
  1343 00:B3A8: AA                 TAX                     ; copy to X
  1344 00:B3A9: C8                 INY                     ; increment index
  1345 00:B3AA: B1 5C              LDA   (Baslnl),Y        ; get line # high byte
  1346 00:B3AC: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1347 00:B3AE: D0 04              BNE   LAB_14FF          ; branch if no high byte match
  1348                        
  1349 00:B3B0: E4 0A              CPX   Itempl            ; compare with temporary integer low byte
  1350 00:B3B2: F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
  1351                        
  1352                        LAB_14FF                      ; else ..
  1353 00:B3B4: B0 2A              BCS   LAB_152B          ; if greater all done so exit
  1354                        
  1355                        LAB_1501
  1356 00:B3B6: 84 49              STY   Tidx1             ; save index for line
  1357 00:B3B8: 20 FB C9           JSR   LAB_295E          ; print XA as unsigned integer
  1358 00:B3BB: A9 20              LDA   #$20              ; space is the next character
  1359                        LAB_1508
  1360 00:B3BD: A4 49              LDY   Tidx1             ; get index for line
  1361 00:B3BF: 29 7F              AND   #$7F              ; mask top out bit of character
  1362                        LAB_150C
  1363 00:B3C1: 20 8E B8           JSR   LAB_PRNA          ; go print the character
  1364 00:B3C4: C9 22              CMP   #$22              ; was it " character
  1365 00:B3C6: D0 06              BNE   LAB_1519          ; branch if not
  1366                                                      ; we are either entering or leaving a pair of quotes
  1367 00:B3C8: A5 12              LDA   Oquote            ; get open quote flag
  1368 00:B3CA: 49 FF              EOR   #$FF              ; toggle it
  1369 00:B3CC: 85 12              STA   Oquote            ; save it back
  1370                        LAB_1519
  1371 00:B3CE: C8                 INY                     ; increment index
  1372 00:B3CF: B1 5C              LDA   (Baslnl),Y        ; get next byte
  1373 00:B3D1: D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
  1374 00:B3D3: A8                 TAY                     ; else clear index
  1375 00:B3D4: B1 5C              LDA   (Baslnl),Y        ; get next line pointer low byte
  1376 00:B3D6: AA                 TAX                     ; copy to X
  1377 00:B3D7: C8                 INY                     ; increment index
  1378 00:B3D8: B1 5C              LDA   (Baslnl),Y        ; get next line pointer high byte
  1379 00:B3DA: 86 5C              STX   Baslnl            ; set pointer to line low byte
  1380 00:B3DC: 85 5D              STA   Baslnh            ; set pointer to line high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 23


  1381 00:B3DE: D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
  1382                                                      ; else ..
  1383                        LAB_152B
  1384 00:B3E0: 60                 RTS
  1385                        
  1386                        LAB_152E
  1387 00:B3E1: 10 DE              BPL   LAB_150C          ; just go print it if not token byte
  1388                                                      ; else was token byte so uncrunch it (maybe)
  1389 00:B3E3: 24 12              BIT   Oquote            ; test the open quote flag
  1390 00:B3E5: 30 DA              BMI   LAB_150C          ; just go print character if open quote set
  1391                        
  1392 00:B3E7: A2 D4              LDX   #>LAB_KEYT        ; get table address high byte
  1393 00:B3E9: 0A                 ASL                     ; *2
  1394 00:B3EA: 0A                 ASL                     ; *4
  1395 00:B3EB: 90 02              BCC   LAB_152F          ; branch if no carry
  1396                        
  1397 00:B3ED: E8                 INX                     ; else increment high byte
  1398 00:B3EE: 18                 CLC                     ; clear carry for add
  1399                        LAB_152F
  1400 00:B3EF: 69 8A              ADC   #<LAB_KEYT        ; add low byte
  1401 00:B3F1: 90 01              BCC   LAB_1530          ; branch if no carry
  1402 00:B3F3: E8                 INX                     ; else increment high byte
  1403                        
  1404                        LAB_1530
  1405 00:B3F4: 85 25              STA   ut2_pl            ; save table pointer low byte
  1406 00:B3F6: 86 26              STX   ut2_ph            ; save table pointer high byte
  1407 00:B3F8: 84 49              STY   Tidx1             ; save index for line
  1408 00:B3FA: A0 00              LDY   #$00              ; clear index
  1409 00:B3FC: B1 25              LDA   (ut2_pl),Y        ; get length
  1410 00:B3FE: AA                 TAX                     ; copy length
  1411 00:B3FF: C8                 INY                     ; increment index
  1412 00:B400: B1 25              LDA   (ut2_pl),Y        ; get 1st character
  1413 00:B402: CA                 DEX                     ; decrement length
  1414 00:B403: F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
  1415                        
  1416 00:B405: 20 8E B8           JSR   LAB_PRNA          ; go print the character
  1417 00:B408: C8                 INY                     ; increment index
  1418 00:B409: B1 25              LDA   (ut2_pl),Y        ; get keyword address low byte
  1419 00:B40B: 48                 PHA                     ; save it for now
  1420 00:B40C: C8                 INY                     ; increment index
  1421 00:B40D: B1 25              LDA   (ut2_pl),Y        ; get keyword address high byte
  1422 00:B40F: A0 00              LDY   #$00
  1423 00:B411: 85 26              STA   ut2_ph            ; save keyword pointer high byte
  1424 00:B413: 68                 PLA                     ; pull low byte
  1425 00:B414: 85 25              STA   ut2_pl            ; save keyword pointer low byte
  1426                        LAB_1540
  1427 00:B416: B1 25              LDA   (ut2_pl),Y        ; get character
  1428 00:B418: CA                 DEX                     ; decrement character count
  1429 00:B419: F0 A2              BEQ   LAB_1508          ; if last character exit and print
  1430                        
  1431 00:B41B: 20 8E B8           JSR   LAB_PRNA          ; go print the character
  1432 00:B41E: C8                 INY                     ; increment index
  1433 00:B41F: D0 F5              BNE   LAB_1540          ; loop for next character
  1434                        
  1435                        ; perform FOR
  1436                        
  1437                        LAB_FOR
  1438 00:B421: F7 13              SMB7  Sufnxf            ; set Subscript/FNx flag
  1439                        ;      LDA   #$80              ; set FNX
  1440                        ;      STA   Sufnxf            ; set subscript/FNX flag
  1441 00:B423: 20 5E B7           JSR   LAB_LET           ; go do LET
  1442 00:B426: 68                 PLA                     ; pull return address
  1443 00:B427: 68                 PLA                     ; pull return address
  Mon Feb  8 2021  9:20                                                                                                    Page 24


  1444 00:B428: A9 10              LDA   #$10              ; we need 16d bytes !
  1445 00:B42A: 20 C6 B0           JSR   LAB_1212          ; check room on stack for A bytes
  1446 00:B42D: 20 54 B6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  1447 00:B430: 18                 CLC                     ; clear carry for add
  1448 00:B431: 98                 TYA                     ; copy index to A
  1449 00:B432: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1450 00:B434: 48                 PHA                     ; push onto stack
  1451 00:B435: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1452 00:B437: 69 00              ADC   #$00              ; add carry
  1453 00:B439: 48                 PHA                     ; push onto stack
  1454 00:B43A: A5 3A              LDA   Clineh            ; get current line high byte
  1455 00:B43C: 48                 PHA                     ; push onto stack
  1456 00:B43D: A5 39              LDA   Clinel            ; get current line low byte
  1457 00:B43F: 48                 PHA                     ; push onto stack
  1458 00:B440: A9 AA              LDA   #TK_TO            ; get "TO" token
  1459 00:B442: 20 8D BB           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
  1460 00:B445: 20 6A BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  1461 00:B448: 20 67 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  1462                                                      ; else do type mismatch
  1463                        
  1464 00:B44B: 20 5E C8           JSR   LAB_27BA          ; round FAC1 First (patch 2.22p5)
  1465                        
  1466 00:B44E: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  1467 00:B450: 09 7F              ORA   #$7F              ; set all non sign bits
  1468 00:B452: 25 5F              AND   FAC1_1            ; and FAC1 mantissa1
  1469 00:B454: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  1470 00:B456: A9 61              LDA   #<LAB_159F        ; set return address low byte
  1471 00:B458: A0 B4              LDY   #>LAB_159F        ; set return address high byte
  1472 00:B45A: 85 23              STA   ut1_pl            ; save return address low byte
  1473 00:B45C: 84 24              STY   ut1_ph            ; save return address high byte
  1474 00:B45E: 4C 23 BB           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
  1475                        
  1476                        LAB_159F
  1477 00:B461: A9 70              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
  1478 00:B463: A0 D1              LDY   #>LAB_259C        ; set 1 pointer high addr
  1479 00:B465: 20 02 C8           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  1480 00:B468: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  1481 00:B46B: C9 AF              CMP   #TK_STEP          ; compare with STEP token
  1482 00:B46D: D0 06              BNE   LAB_15B3          ; jump if not "STEP"
  1483                        
  1484                                                      ; was step so ..
  1485 00:B46F: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  1486 00:B472: 20 67 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  1487                                                      ; else do type mismatch
  1488                        LAB_15B3
  1489 00:B475: 20 6E C8           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
  1490 00:B478: 85 62              STA   FAC1_s            ; set FAC1 sign (b7)
  1491                                                      ; this is +1 for +ve step and -1 for -ve step, in NEXT we
  1492                                                      ; compare the FOR value and the TO value and return +1 if
  1493                                                      ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
  1494                                                      ; here (+/-1) is then compared to that result and if they
  1495                                                      ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
  1496                                                      ; the loop is done
  1497 00:B47A: 20 11 BB           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
  1498 00:B47D: A5 4A              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
  1499 00:B47F: 48                 PHA                     ; push on stack
  1500 00:B480: A5 49              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
  1501 00:B482: 48                 PHA                     ; push on stack
  1502 00:B483: A9 81              LDA   #TK_FOR           ; get FOR token
  1503 00:B485: 48                 PHA                     ; push on stack
  1504                        
  1505                        ; interpreter inner loop
  1506                        
  Mon Feb  8 2021  9:20                                                                                                    Page 25


  1507                        LAB_15C2
  1508 00:B486: 20 D9 B4           JSR   LAB_1629          ; do CRTL-C check vector
  1509 00:B489: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1510 00:B48B: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  1511 00:B48D: A6 3A              LDX   Clineh            ; continue line is $FFxx for immediate mode
  1512                                                      ; ($00xx for RUN from immediate mode)
  1513 00:B48F: E8                 INX                     ; increment it (now $00 if immediate mode)
  1514 00:B490: 85 3D              STA   Cpntrl            ; save continue pointer low byte
  1515 00:B492: 84 3E              STY   Cpntrh            ; save continue pointer high byte
  1516                        LAB_15D1
  1517 00:B494: B2 6E              LDA   (Bpntrl)          ; get next byte
  1518 00:B496: F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
  1519                        
  1520 00:B498: C9 3A              CMP   #':'              ; compare with ":"
  1521 00:B49A: F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
  1522                        
  1523                        LAB_15D9
  1524 00:B49C: 4C 9C BB           JMP   LAB_SNER          ; else syntax error then warm start
  1525                                                      ; have reached [EOL]
  1526                        LAB_15DC
  1527 00:B49F: A0 02              LDY   #$02              ; set index
  1528 00:B4A1: B1 6E              LDA   (Bpntrl),Y        ; get next line pointer high byte
  1529 00:B4A3: 18                 CLC                     ; clear carry for no "BREAK" message
  1530 00:B4A4: F0 4F              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
  1531                                                      ; marker)
  1532 00:B4A6: C8                 INY                     ; increment index
  1533 00:B4A7: B1 6E              LDA   (Bpntrl),Y        ; get line # low byte
  1534 00:B4A9: 85 39              STA   Clinel            ; save current line low byte
  1535 00:B4AB: C8                 INY                     ; increment index
  1536 00:B4AC: B1 6E              LDA   (Bpntrl),Y        ; get line # high byte
  1537 00:B4AE: 85 3A              STA   Clineh            ; save current line high byte
  1538 00:B4B0: 98                 TYA                     ; A now = 4
  1539 00:B4B1: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1540 00:B4B3: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1541 00:B4B5: 90 02              BCC   LAB_15F6          ; branch if no overflow
  1542                        
  1543 00:B4B7: E6 6F              INC   Bpntrh            ; else increment BASIC execute pointer high byte
  1544                        LAB_15F6
  1545 00:B4B9: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  1546                        
  1547                        LAB_15F9
  1548 00:B4BC: 20 C1 B4           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
  1549                        
  1550                        LAB_15FC
  1551 00:B4BF: 80 C5              BRA   LAB_15C2          ; loop
  1552                        
  1553                        ; interpret BASIC code from (Bpntrl)
  1554                        
  1555                        LAB_15FF
  1556 00:B4C1: F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
  1557                        
  1558                        LAB_1602
  1559 00:B4C3: 0A                 ASL                     ; *2 bytes per vector and normalise token
  1560 00:B4C4: B0 03              BCS   LAB_1609          ; branch if was token
  1561 00:B4C6: 4C 5E B7           JMP   LAB_LET           ; else go do implied LET
  1562                        
  1563                        LAB_1609
  1564 00:B4C9: C9 50              CMP   #(TK_TAB-$80)*2   ; compare normalised token * 2 with TAB
  1565 00:B4CB: B0 CF              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
  1566                                                      ; only tokens before TAB can start a line
  1567 00:B4CD: A8                 TAY                     ; copy to index
  1568 00:B4CE: B9 98 D1           LDA   LAB_CTBL+1,Y      ; get vector high byte
  1569 00:B4D1: 48                 PHA                     ; onto stack
  Mon Feb  8 2021  9:20                                                                                                    Page 26


  1570 00:B4D2: B9 97 D1           LDA   LAB_CTBL,Y        ; get vector low byte
  1571 00:B4D5: 48                 PHA                     ; onto stack
  1572 00:B4D6: 4C B5 CF           JMP   LAB_IGBY          ; jump to increment and scan memory
  1573                                                      ; then "return" to vector
  1574                        
  1575                        ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
  1576                        ; key press is detected.
  1577                        
  1578                        LAB_1629
  1579 00:B4D9: 6C 82 05           JMP   (VEC_CC)          ; ctrl-c check vector
  1580                        
  1581                        ; if there was a key press it gets back here ..
  1582                        
  1583                        LAB_1636
  1584 00:B4DC: C9 03              CMP   #$03              ; compare with CTRL-C
  1585                        
  1586                        ; perform STOP
  1587                        
  1588                        LAB_STOP
  1589 00:B4DE: B0 01              BCS   LAB_163B          ; branch if token follows STOP
  1590                                                      ; else just END
  1591                        ; END
  1592                        
  1593                        LAB_END
  1594 00:B4E0: 18                 CLC                     ; clear the carry, indicate a normal program end
  1595                        LAB_163B
  1596 00:B4E1: D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
  1597                        
  1598 00:B4E3: A5 6F              LDA   Bpntrh            ; get the BASIC execute pointer high byte
  1599 00:B4E5: A4 6E              LDY   Bpntrl            ; get BASIC execute pointer low byte
  1600 00:B4E7: 84 3D              STY   Cpntrl            ; save continue pointer low byte
  1601 00:B4E9: 85 3E              STA   Cpntrh            ; save continue pointer high byte
  1602                        LAB_1647
  1603 00:B4EB: A5 39              LDA   Clinel            ; get current line low byte
  1604 00:B4ED: A4 3A              LDY   Clineh            ; get current line high byte
  1605 00:B4EF: 85 3B              STA   Blinel            ; save break line low byte
  1606 00:B4F1: 84 3C              STY   Blineh            ; save break line high byte
  1607                        LAB_164F
  1608 00:B4F3: 68                 PLA                     ; pull return address low
  1609 00:B4F4: 68                 PLA                     ; pull return address high
  1610                        LAB_1651
  1611 00:B4F5: 90 07              BCC   LAB_165E          ; if was program end just do warm start
  1612                                                      ; else ..
  1613 00:B4F7: A9 47              LDA   #<LAB_BMSG        ; point to "Break" low byte
  1614 00:B4F9: A0 D7              LDY   #>LAB_BMSG        ; point to "Break" high byte
  1615 00:B4FB: 4C 14 B1           JMP   LAB_1269          ; print "Break" and do warm start
  1616                        
  1617                        LAB_165E
  1618 00:B4FE: 4C 1F B1           JMP   LAB_1274          ; go do warm start
  1619                        
  1620                        ; perform RESTORE
  1621                        
  1622                        LAB_RESTORE
  1623 00:B501: D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
  1624                        
  1625                        LAB_161A
  1626 00:B503: 38                 SEC                     ; set carry for subtract
  1627 00:B504: A5 2B              LDA   Smeml             ; get start of mem low byte
  1628 00:B506: E9 01              SBC   #$01              ; -1
  1629 00:B508: A4 2C              LDY   Smemh             ; get start of mem high byte
  1630 00:B50A: B0 01              BCS   LAB_1624          ; branch if no underflow
  1631                        
  1632                        LAB_uflow
  Mon Feb  8 2021  9:20                                                                                                    Page 27


  1633 00:B50C: 88                 DEY                     ; else decrement high byte
  1634                        LAB_1624
  1635 00:B50D: 85 41              STA   Dptrl             ; save DATA pointer low byte
  1636 00:B50F: 84 42              STY   Dptrh             ; save DATA pointer high byte
  1637                        LAB_1628
  1638 00:B511: 60                 RTS
  1639                                                      ; is RESTORE n
  1640                        LAB_RESTOREn
  1641 00:B512: 20 00 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1642 00:B515: 20 58 B6           JSR   LAB_SNBL          ; scan for next BASIC line
  1643 00:B518: A5 3A              LDA   Clineh            ; get current line high byte
  1644 00:B51A: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1645 00:B51C: B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
  1646                        
  1647 00:B51E: 98                 TYA                     ; else copy line index to A
  1648 00:B51F: 38                 SEC                     ; set carry (+1)
  1649 00:B520: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1650 00:B522: A6 6F              LDX   Bpntrh            ; get BASIC execute pointer high byte
  1651 00:B524: 90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
  1652                        
  1653 00:B526: E8                 INX                     ; increment high byte
  1654 00:B527: 80 04              BRA   LAB_go_search     ; branch always (can never be carry clear)
  1655                        
  1656                        ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1657                        
  1658                        LAB_reset_search
  1659 00:B529: A5 2B              LDA   Smeml             ; get start of mem low byte
  1660 00:B52B: A6 2C              LDX   Smemh             ; get start of mem high byte
  1661                        
  1662                        ; search for line # in temp (Itempl/Itemph) from (AX)
  1663                        
  1664                        LAB_go_search
  1665                        
  1666 00:B52D: 20 F6 B2           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
  1667 00:B530: B0 03              BCS   LAB_line_found    ; if carry set go set pointer
  1668                        
  1669 00:B532: 4C 29 B6           JMP   LAB_16F7          ; else go do "Undefined statement" error
  1670                        
  1671                        LAB_line_found
  1672                                                      ; carry already set for subtract
  1673 00:B535: A5 5C              LDA   Baslnl            ; get pointer low byte
  1674 00:B537: E9 01              SBC   #$01              ; -1
  1675 00:B539: A4 5D              LDY   Baslnh            ; get pointer high byte
  1676 00:B53B: B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
  1677 00:B53D: 80 CD              BRA   LAB_uflow         ; else decrement high byte then save DATA pointer and
  1678                                                      ; return (branch always)
  1679                        ; perform NULL
  1680                        
  1681                        LAB_NULL
  1682 00:B53F: 20 21 C4           JSR   LAB_GTBY          ; get byte parameter
  1683 00:B542: 86 06              STX   Nullct            ; save new NULL count
  1684                        LAB_167A
  1685 00:B544: 60                 RTS
  1686                        
  1687                        ; perform CONT
  1688                        
  1689                        LAB_CONT
  1690 00:B545: D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
  1691                        
  1692 00:B547: A4 3E              LDY   Cpntrh            ; get continue pointer high byte
  1693 00:B549: C0 05              CPY   #>Ibuffs          ; *** fix p2: test direct mode
  1694 00:B54B: D0 05              BNE   LAB_166C          ; go do continue if we can
  1695                        
  Mon Feb  8 2021  9:20                                                                                                    Page 28


  1696 00:B54D: A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
  1697 00:B54F: 4C 01 B1           JMP   LAB_XERR          ; do error #X, then warm start
  1698                                                      ; we can continue so ..
  1699                        LAB_166C
  1700 00:B552: 84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
  1701 00:B554: A5 3D              LDA   Cpntrl            ; get continue pointer low byte
  1702 00:B556: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1703 00:B558: A5 3B              LDA   Blinel            ; get break line low byte
  1704 00:B55A: A4 3C              LDY   Blineh            ; get break line high byte
  1705 00:B55C: 85 39              STA   Clinel            ; set current line low byte
  1706 00:B55E: 84 3A              STY   Clineh            ; set current line high byte
  1707 00:B560: 60                 RTS
  1708                        
  1709                        ; perform RUN
  1710                        
  1711                        LAB_RUN
  1712 00:B561: D0 03              BNE   LAB_1696          ; branch if RUN n
  1713 00:B563: 4C 33 B3           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack, return
  1714                        
  1715                        ; does RUN n
  1716                        
  1717                        LAB_1696
  1718 00:B566: 20 40 B3           JSR   LAB_147A          ; go do "CLEAR"
  1719 00:B569: 80 2E              BRA   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
  1720                        
  1721                        ; perform DO
  1722                        
  1723                        LAB_DO
  1724 00:B56B: A9 05              LDA   #$05              ; need 5 bytes for DO
  1725 00:B56D: 20 C6 B0           JSR   LAB_1212          ; check room on stack for A bytes
  1726 00:B570: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1727 00:B572: 48                 PHA                     ; push on stack
  1728 00:B573: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1729 00:B575: 48                 PHA                     ; push on stack
  1730 00:B576: A5 3A              LDA   Clineh            ; get current line high byte
  1731 00:B578: 48                 PHA                     ; push on stack
  1732 00:B579: A5 39              LDA   Clinel            ; get current line low byte
  1733 00:B57B: 48                 PHA                     ; push on stack
  1734 00:B57C: A9 9B              LDA   #TK_DO            ; token for DO
  1735 00:B57E: 48                 PHA                     ; push on stack
  1736 00:B57F: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  1737 00:B582: 4C 86 B4           JMP   LAB_15C2          ; go do interpreter inner loop
  1738                        
  1739                        ; perform GOSUB
  1740                        
  1741                        LAB_GOSUB
  1742 00:B585: A9 05              LDA   #$05              ; need 5 bytes for GOSUB
  1743 00:B587: 20 C6 B0           JSR   LAB_1212          ; check room on stack for A bytes
  1744 00:B58A: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1745 00:B58C: 48                 PHA                     ; push on stack
  1746 00:B58D: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1747 00:B58F: 48                 PHA                     ; push on stack
  1748 00:B590: A5 3A              LDA   Clineh            ; get current line high byte
  1749 00:B592: 48                 PHA                     ; push on stack
  1750 00:B593: A5 39              LDA   Clinel            ; get current line low byte
  1751 00:B595: 48                 PHA                     ; push on stack
  1752 00:B596: A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
  1753 00:B598: 48                 PHA                     ; push on stack
  1754                        LAB_16B0
  1755 00:B599: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  1756 00:B59C: 20 A2 B5           JSR   LAB_GOTO          ; perform GOTO n
  1757 00:B59F: 4C 86 B4           JMP   LAB_15C2          ; go do interpreter inner loop, return
  1758                        
  Mon Feb  8 2021  9:20                                                                                                    Page 29


  1759                        ; perform GOTO
  1760                        
  1761                        LAB_GOTO
  1762 00:B5A2: 20 00 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1763 00:B5A5: 20 58 B6           JSR   LAB_SNBL          ; scan for next BASIC line
  1764 00:B5A8: A5 3A              LDA   Clineh            ; get current line high byte
  1765 00:B5AA: C5 0B              CMP   Itemph            ; compare with temporary integer high byte
  1766 00:B5AC: B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
  1767                        
  1768 00:B5AE: 98                 TYA                     ; else copy line index to A
  1769 00:B5AF: 38                 SEC                     ; set carry (+1)
  1770 00:B5B0: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1771 00:B5B2: A6 6F              LDX   Bpntrh            ; get BASIC execute pointer high byte
  1772 00:B5B4: 90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
  1773                        
  1774 00:B5B6: E8                 INX                     ; increment high byte
  1775 00:B5B7: 80 04              BRA   LAB_16D4          ; branch always (can never be carry)
  1776                        
  1777                        ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1778                        
  1779                        LAB_16D0
  1780 00:B5B9: A5 2B              LDA   Smeml             ; get start of mem low byte
  1781 00:B5BB: A6 2C              LDX   Smemh             ; get start of mem high byte
  1782                        
  1783                        ; search for line # in temp (Itempl/Itemph) from (AX)
  1784                        
  1785                        LAB_16D4
  1786 00:B5BD: 20 F6 B2           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
  1787 00:B5C0: 90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
  1788                                                      ; (unspecified statement)
  1789                                                      ; carry already set for subtract
  1790 00:B5C2: A5 5C              LDA   Baslnl            ; get pointer low byte
  1791 00:B5C4: E9 01              SBC   #$01              ; -1
  1792 00:B5C6: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1793 00:B5C8: A5 5D              LDA   Baslnh            ; get pointer high byte
  1794 00:B5CA: E9 00              SBC   #$00              ; subtract carry
  1795 00:B5CC: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1796                        LAB_16E5
  1797 00:B5CE: 60                 RTS
  1798                        
  1799                        LAB_DONOK
  1800 00:B5CF: A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
  1801 00:B5D1: 4C 01 B1           JMP   LAB_XERR          ; do error #X, then warm start
  1802                        
  1803                        ; perform LOOP
  1804                        
  1805                        LAB_LOOP
  1806 00:B5D4: A8                 TAY                     ; save following token
  1807 00:B5D5: BA                 TSX                     ; copy stack pointer
  1808 00:B5D6: BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
  1809 00:B5D9: C9 9B              CMP   #TK_DO            ; compare with DO token
  1810 00:B5DB: D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
  1811                        
  1812 00:B5DD: E8                 INX                     ; dump calling routine return address
  1813 00:B5DE: E8                 INX                     ; dump calling routine return address
  1814 00:B5DF: 9A                 TXS                     ; correct stack
  1815 00:B5E0: 98                 TYA                     ; get saved following token back
  1816 00:B5E1: F0 20              BEQ   LoopAlways        ; if no following token loop forever
  1817                                                      ; (stack pointer in X)
  1818                        
  1819 00:B5E3: C9 3A              CMP   #':'              ; could be ':'
  1820 00:B5E5: F0 1C              BEQ   LoopAlways        ; if :... loop forever
  1821                        
  Mon Feb  8 2021  9:20                                                                                                    Page 30


  1822 00:B5E7: E9 B0              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
  1823 00:B5E9: AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
  1824 00:B5EA: F0 04              BEQ   DoRest            ; branch if was UNTIL
  1825                        
  1826 00:B5EC: CA                 DEX                     ; decrement result
  1827 00:B5ED: D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
  1828                                                      ; only if the token was WHILE will this fail
  1829                        
  1830 00:B5EF: CA                 DEX                     ; set invert result byte
  1831                        DoRest
  1832 00:B5F0: 86 4A              STX   Frnxth            ; save invert result byte
  1833 00:B5F2: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  1834 00:B5F5: 20 7C BA           JSR   LAB_EVEX          ; evaluate expression
  1835 00:B5F8: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  1836 00:B5FA: F0 02              BEQ   DoCmp             ; if =0 go do straight compare
  1837                        
  1838 00:B5FC: A9 FF              LDA   #$FF              ; else set all bits
  1839                        DoCmp
  1840 00:B5FE: BA                 TSX                     ; copy stack pointer
  1841 00:B5FF: 45 4A              EOR   Frnxth            ; EOR with invert byte
  1842 00:B601: D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
  1843                                                      ; loop condition wasn't met so do it again
  1844                        LoopAlways
  1845 00:B603: BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
  1846 00:B606: 85 39              STA   Clinel            ; save current line low byte
  1847 00:B608: BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
  1848 00:B60B: 85 3A              STA   Clineh            ; save current line high byte
  1849 00:B60D: BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
  1850 00:B610: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1851 00:B612: BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
  1852 00:B615: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1853 00:B617: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  1854 00:B61A: 4C 86 B4           JMP   LAB_15C2          ; go do interpreter inner loop
  1855                        
  1856                                                      ; clear stack and back to interpreter loop
  1857                        LoopDone
  1858 00:B61D: E8                 INX                     ; dump DO token
  1859 00:B61E: E8                 INX                     ; dump current line low byte
  1860 00:B61F: E8                 INX                     ; dump current line high byte
  1861 00:B620: E8                 INX                     ; dump BASIC execute pointer low byte
  1862 00:B621: E8                 INX                     ; dump BASIC execute pointer high byte
  1863 00:B622: 9A                 TXS                     ; correct stack
  1864 00:B623: 80 1E              BRA   LAB_DATA          ; go perform DATA (find : or [EOL])
  1865                        
  1866                        ; do the return without gosub error
  1867                        
  1868                        LAB_16F4
  1869 00:B625: A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
  1870 00:B627: 80 02              BRA   LAB_16F7b         ; branch around next instruction, save one clock cycle
  1871                        
  1872                        LAB_16F7                      ; do undefined statement error
  1873 00:B629: A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
  1874                        LAB_16F7b
  1875 00:B62B: 4C 01 B1           JMP   LAB_XERR          ; do error #X, then warm start
  1876                        
  1877                        ; perform RETURN
  1878                        
  1879                        LAB_RETURN
  1880 00:B62E: D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
  1881                        
  1882                        LAB_16E8
  1883 00:B630: 68                 PLA                     ; dump calling routine return address
  1884 00:B631: 68                 PLA                     ; dump calling routine return address
  Mon Feb  8 2021  9:20                                                                                                    Page 31


  1885 00:B632: 68                 PLA                     ; pull token
  1886 00:B633: C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
  1887 00:B635: D0 EE              BNE   LAB_16F4          ; branch if no matching GOSUB
  1888                        
  1889                        LAB_16FF
  1890 00:B637: 68                 PLA                     ; pull current line low byte
  1891 00:B638: 85 39              STA   Clinel            ; save current line low byte
  1892 00:B63A: 68                 PLA                     ; pull current line high byte
  1893 00:B63B: 85 3A              STA   Clineh            ; save current line high byte
  1894 00:B63D: 68                 PLA                     ; pull BASIC execute pointer low byte
  1895 00:B63E: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1896 00:B640: 68                 PLA                     ; pull BASIC execute pointer high byte
  1897 00:B641: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  1898                        
  1899                                                      ; now do the DATA statement as we could be returning into
  1900                                                      ; the middle of an ON <var> GOSUB n,m,p,q line
  1901                                                      ; (the return address used by the DATA statement is the one
  1902                                                      ; pushed before the GOSUB was executed!)
  1903                        
  1904                        ; perform DATA
  1905                        
  1906                        LAB_DATA
  1907 00:B643: 20 54 B6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  1908                        
  1909                                                      ; set BASIC execute pointer
  1910                        LAB_170F
  1911 00:B646: 98                 TYA                     ; copy index to A
  1912 00:B647: 18                 CLC                     ; clear carry for add
  1913 00:B648: 65 6E              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1914 00:B64A: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  1915 00:B64C: 90 02              BCC   LAB_1719          ; skip next if no carry
  1916                        
  1917 00:B64E: E6 6F              INC   Bpntrh            ; else increment BASIC execute pointer high byte
  1918                        LAB_1719
  1919 00:B650: 60                 RTS
  1920                        
  1921                        LAB_16FC
  1922 00:B651: 4C 9C BB           JMP   LAB_SNER          ; do syntax error then warm start
  1923                        
  1924                        ; scan for next BASIC statement ([:] or [EOL])
  1925                        ; returns Y as index to [:] or [EOL]
  1926                        
  1927                        LAB_SNBS
  1928 00:B654: A2 3A              LDX   #':'              ; set look for character = ":"
  1929 00:B656: 80 02              BRA   LAB_SNBLb         ; branch around next instruction, save one clock cycle
  1930                        
  1931                        ; scan for next BASIC line
  1932                        ; returns Y as index to [EOL]
  1933                        
  1934                        LAB_SNBL
  1935 00:B658: A2 00              LDX   #$00              ; set alt search character = [EOL]
  1936                        LAB_SNBLb
  1937 00:B65A: A0 00              LDY   #$00              ; set search character = [EOL]
  1938 00:B65C: 84 0E              STY   Asrch             ; store search character
  1939                        LAB_1725
  1940 00:B65E: 8A                 TXA                     ; get alt search character
  1941 00:B65F: 45 0E              EOR   Asrch             ; toggle search character, effectively swap with $00
  1942 00:B661: 85 0E              STA   Asrch             ; save swapped search character
  1943                        LAB_172D
  1944 00:B663: B1 6E              LDA   (Bpntrl),Y        ; get next byte
  1945 00:B665: F0 E9              BEQ   LAB_1719          ; exit if null [EOL]
  1946                        
  1947 00:B667: C5 0E              CMP   Asrch             ; compare with search character
  Mon Feb  8 2021  9:20                                                                                                    Page 32


  1948 00:B669: F0 E5              BEQ   LAB_1719          ; exit if found
  1949                        
  1950 00:B66B: C8                 INY                     ; increment index
  1951 00:B66C: C9 22              CMP   #$22              ; compare current character with open quote
  1952 00:B66E: D0 F3              BNE   LAB_172D          ; if not open quote go get next character
  1953 00:B670: 80 EC              BRA   LAB_1725          ; if found go swap search character for alt search character
  1954                        
  1955                        ; perform IF
  1956                        
  1957                        LAB_IF
  1958 00:B672: 20 7C BA           JSR   LAB_EVEX          ; evaluate the expression
  1959 00:B675: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  1960 00:B678: C9 AD              CMP   #TK_THEN          ; compare with THEN token
  1961 00:B67A: F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
  1962                        
  1963                                                      ; wasn't IF .. THEN so must be IF .. GOTO
  1964 00:B67C: C9 89              CMP   #TK_GOTO          ; compare with GOTO token
  1965 00:B67E: D0 D1              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
  1966                        
  1967 00:B680: A6 6E              LDX   Bpntrl            ; save the basic pointer low byte
  1968 00:B682: A4 6F              LDY   Bpntrh            ; save the basic pointer high byte
  1969 00:B684: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  1970 00:B687: B0 C8              BCS   LAB_16FC          ; if not numeric go do syntax error
  1971                        
  1972 00:B689: 86 6E              STX   Bpntrl            ; restore the basic pointer low byte
  1973 00:B68B: 84 6F              STY   Bpntrh            ; restore the basic pointer high byte
  1974                        LAB_174B
  1975 00:B68D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  1976 00:B68F: F0 1C              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
  1977                        
  1978 00:B691: 20 B5 CF           JSR   LAB_IGBY          ; else increment and scan memory
  1979 00:B694: B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
  1980                        
  1981                        LAB_174C
  1982 00:B696: 4C A2 B5           JMP   LAB_GOTO          ; else was numeric so do GOTO n
  1983                        
  1984                                                      ; is var or keyword
  1985                        LAB_174D
  1986 00:B699: 68                 PLA                     ; discard interpreter loop return address
  1987 00:B69A: 68                 PLA                     ; so data structures are at the correct stack offset
  1988 00:B69B: 20 BB CF           JSR   LAB_GBYT          ; restore token or variable
  1989 00:B69E: 20 C1 B4           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
  1990                        
  1991                        ; the IF was executed and there may be a following ELSE so the code needs to return
  1992                        ; here to check and ignore the ELSE if present
  1993                        
  1994 00:B6A1: B2 6E              LDA   (Bpntrl)          ; get the next BASIC byte
  1995 00:B6A3: C9 A9              CMP   #TK_ELSE          ; compare it with the token for ELSE
  1996 00:B6A5: D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
  1997 00:B6A7: 20 43 B6           JSR   LAB_DATA          ; yes - skip the rest of the line
  1998                        
  1999                        ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  2000                        ; following ELSE will, correctly, cause a syntax error
  2001                        
  2002                        LAB_no_ELSE
  2003 00:B6AA: 4C 86 B4           JMP LAB_15C2            ; return to the interpreter inner loop
  2004                        
  2005                        ; perform ELSE after IF
  2006                        
  2007                        LAB_174E
  2008 00:B6AD: A0 00              LDY   #$00              ; clear the BASIC byte index
  2009 00:B6AF: A2 01              LDX   #$01              ; clear the nesting depth
  2010                        LAB_1750
  Mon Feb  8 2021  9:20                                                                                                    Page 33


  2011 00:B6B1: C8                 INY                     ; increment the BASIC byte index
  2012 00:B6B2: B1 6E              LDA   (Bpntrl),Y        ; get the next BASIC byte
  2013 00:B6B4: F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
  2014                        
  2015 00:B6B6: C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
  2016 00:B6B8: D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
  2017                        
  2018 00:B6BA: E8                 INX                     ; else increment the nesting depth,
  2019 00:B6BB: D0 F4              BNE   LAB_1750          ; and continue looking
  2020                        
  2021                        LAB_1752
  2022 00:B6BD: C9 A9              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
  2023 00:B6BF: D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
  2024                        
  2025 00:B6C1: CA                 DEX                     ; was ELSE so decrement the nesting depth
  2026 00:B6C2: D0 ED              BNE   LAB_1750          ; loop if still nested
  2027                        
  2028 00:B6C4: C8                 INY                     ; increment the BASIC byte index past the ELSE
  2029                        
  2030                        ; found the matching ELSE, now do <{n|statement}>
  2031                        
  2032                        LAB_1753
  2033 00:B6C5: 98                 TYA                     ; else copy line index to A
  2034 00:B6C6: 18                 CLC                     ; clear carry for add
  2035 00:B6C7: 65 6E              ADC   Bpntrl            ; add the BASIC execute pointer low byte
  2036 00:B6C9: 85 6E              STA   Bpntrl            ; save the BASIC execute pointer low byte
  2037 00:B6CB: 90 02              BCC   LAB_1754          ; branch if no overflow to high byte
  2038                        
  2039 00:B6CD: E6 6F              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
  2040                        LAB_1754
  2041 00:B6CF: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  2042 00:B6D2: 90 C2              BCC   LAB_174C          ; if numeric do GOTO n
  2043                                                      ; the code will return to the interpreter loop at the
  2044                                                      ; tail end of the GOTO <n>
  2045                        
  2046 00:B6D4: 4C C1 B4           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
  2047                                                      ; the code will return to the interpreter loop at the
  2048                                                      ; tail end of the <statement>
  2049                        
  2050                        ; perform REM, skip (rest of) line
  2051                        
  2052                        LAB_REM
  2053 00:B6D7: 20 58 B6           JSR   LAB_SNBL          ; scan for next BASIC line
  2054 00:B6DA: 4C 46 B6           JMP   LAB_170F          ; go set BASIC execute pointer and return
  2055                        
  2056                        LAB_16FD
  2057 00:B6DD: 4C 9C BB           JMP   LAB_SNER          ; do syntax error then warm start
  2058                        
  2059                        ; perform ON
  2060                        
  2061                        LAB_ON
  2062 00:B6E0: 20 21 C4           JSR   LAB_GTBY          ; get byte parameter
  2063 00:B6E3: 48                 PHA                     ; push GOTO/GOSUB token
  2064 00:B6E4: C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
  2065 00:B6E6: F0 04              BEQ   LAB_176B          ; branch if GOSUB
  2066                        
  2067 00:B6E8: C9 89              CMP   #TK_GOTO          ; compare with GOTO token
  2068                        LAB_1767
  2069 00:B6EA: D0 F1              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
  2070                        
  2071                        ; next character was GOTO or GOSUB
  2072                        
  2073                        LAB_176B
  Mon Feb  8 2021  9:20                                                                                                    Page 34


  2074 00:B6EC: C6 61              DEC   FAC1_3            ; decrement index (byte value)
  2075 00:B6EE: D0 04              BNE   LAB_1773          ; branch if not zero
  2076                        
  2077 00:B6F0: 68                 PLA                     ; pull GOTO/GOSUB token
  2078 00:B6F1: 4C C3 B4           JMP   LAB_1602          ; go execute it
  2079                        
  2080                        LAB_1773
  2081 00:B6F4: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2082 00:B6F7: 20 00 B7           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
  2083                                                      ; (we could LDX #',' and JSR LAB_SNBL+2, then we
  2084                                                      ; just BNE LAB_176B for the loop. should be quicker ..
  2085                                                      ; no we can't, what if we meet a colon or [EOL]?)
  2086 00:B6FA: C9 2C              CMP   #$2C              ; compare next character with ","
  2087 00:B6FC: F0 EE              BEQ   LAB_176B          ; loop if ","
  2088                        
  2089                        LAB_177E
  2090 00:B6FE: 68                 PLA                     ; else pull keyword token (run out of options)
  2091                                                      ; also dump +/-1 pointer low byte and exit
  2092                        LAB_177F
  2093 00:B6FF: 60                 RTS
  2094                        
  2095                        ; takes n * 106 + 11 cycles where n is the number of digits
  2096                        
  2097                        ; get fixed-point number into temp integer
  2098                        
  2099                        LAB_GFPN
  2100 00:B700: A2 00              LDX   #$00              ; clear reg
  2101 00:B702: 86 0A              STX   Itempl            ; clear temporary integer low byte
  2102                        LAB_1785
  2103 00:B704: 86 0B              STX   Itemph            ; save temporary integer high byte
  2104 00:B706: B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
  2105                                                      ; not 0-9
  2106                        
  2107 00:B708: E0 19              CPX   #$19              ; compare high byte with $19
  2108 00:B70A: A8                 TAY                     ; ensure Zb = 0 if the branch is taken
  2109 00:B70B: B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
  2110                                                      ; bit does *$0A, = 64000, compare at target will fail
  2111                                                      ; and do syntax error
  2112                        
  2113 00:B70D: E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
  2114 00:B70F: A8                 TAY                     ; copy binary digit
  2115 00:B710: A5 0A              LDA   Itempl            ; get temporary integer low byte
  2116 00:B712: 0A                 ASL                     ; *2 low byte
  2117 00:B713: 26 0B              ROL   Itemph            ; *2 high byte
  2118 00:B715: 0A                 ASL                     ; *2 low byte
  2119 00:B716: 26 0B              ROL   Itemph            ; *2 high byte, *4
  2120 00:B718: 65 0A              ADC   Itempl            ; + low byte, *5
  2121 00:B71A: 85 0A              STA   Itempl            ; save it
  2122 00:B71C: 8A                 TXA                     ; get high byte copy to A
  2123 00:B71D: 65 0B              ADC   Itemph            ; + high byte, *5
  2124 00:B71F: 06 0A              ASL   Itempl            ; *2 low byte, *10d
  2125 00:B721: 2A                 ROL                     ; *2 high byte, *10d
  2126 00:B722: AA                 TAX                     ; copy high byte back to X
  2127 00:B723: 98                 TYA                     ; get binary digit back
  2128 00:B724: 65 0A              ADC   Itempl            ; add number low byte
  2129 00:B726: 85 0A              STA   Itempl            ; save number low byte
  2130 00:B728: 90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
  2131                        
  2132 00:B72A: E8                 INX                     ; else increment high byte
  2133                        LAB_17B3
  2134 00:B72B: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2135 00:B72E: 80 D4              BRA   LAB_1785          ; loop for next character
  2136                        
  Mon Feb  8 2021  9:20                                                                                                    Page 35


  2137                        ; perform DEC
  2138                        
  2139                        LAB_DEC
  2140 00:B730: A9 74              LDA   #<LAB_2AFD        ; set -1 pointer low byte
  2141 00:B732: 80 02              BRA   LAB_17B5          ; branch around next instruction, saves one clock cycle
  2142                        
  2143                        ; perform INC
  2144                        
  2145                        LAB_INC
  2146 00:B734: A9 70              LDA   #<LAB_259C        ; set 1 pointer low byte
  2147                        LAB_17B5
  2148 00:B736: 48                 PHA                     ; save +/-1 pointer low byte
  2149                        LAB_17B7
  2150 00:B737: 20 4C BD           JSR   LAB_GVAR          ; get var address
  2151 00:B73A: A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2152 00:B73C: 30 1D              BMI   IncrErr           ; exit if string
  2153                        
  2154 00:B73E: 85 49              STA   Lvarpl            ; save var address low byte
  2155 00:B740: 84 4A              STY   Lvarph            ; save var address high byte
  2156 00:B742: 20 02 C8           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  2157 00:B745: 68                 PLA                     ; get +/-1 pointer low byte
  2158 00:B746: 48                 PHA                     ; save +/-1 pointer low byte
  2159 00:B747: A0 D1              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
  2160 00:B749: 20 4A C5           JSR   LAB_246C          ; add (AY) to FAC1
  2161 00:B74C: 20 28 C8           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
  2162                        
  2163 00:B74F: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  2164 00:B752: C9 2C              CMP   #','              ; compare with ","
  2165 00:B754: D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
  2166                        
  2167                                                      ; was "," so another INCR variable to do
  2168 00:B756: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2169 00:B759: 80 DC              BRA   LAB_17B7          ; go do next var
  2170                        
  2171                        IncrErr
  2172 00:B75B: 4C 77 BA           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
  2173                        
  2174                        ; perform LET
  2175                        
  2176                        LAB_LET
  2177 00:B75E: 20 4C BD           JSR   LAB_GVAR          ; get var address
  2178 00:B761: 85 49              STA   Lvarpl            ; save var address low byte
  2179 00:B763: 84 4A              STY   Lvarph            ; save var address high byte
  2180 00:B765: A9 BD              LDA   #TK_EQUAL         ; get = token
  2181 00:B767: 20 8D BB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  2182 00:B76A: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2183 00:B76C: 48                 PHA                     ; push data type flag
  2184 00:B76D: 20 7C BA           JSR   LAB_EVEX          ; evaluate expression
  2185 00:B770: 68                 PLA                     ; pop data type flag
  2186 00:B771: 2A                 ROL                     ; set carry if type = string
  2187 00:B772: 20 6E BA           JSR   LAB_CKTM          ; type match check, set C for string
  2188 00:B775: B0 03              BCS   LAB_17D5          ; branch if string
  2189 00:B777: 4C 28 C8           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
  2190                        
  2191                        ; string LET
  2192                        
  2193                        LAB_17D5
  2194 00:B77A: A0 02              LDY   #$02              ; set index to pointer high byte
  2195 00:B77C: B1 60              LDA   (des_pl),Y        ; get string pointer high byte
  2196 00:B77E: C5 34              CMP   Sstorh            ; compare bottom of string space high byte
  2197 00:B780: 90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
  2198                        
  2199 00:B782: D0 07              BNE   LAB_17E6          ; branch if >
  Mon Feb  8 2021  9:20                                                                                                    Page 36


  2200                                                      ; else was equal so compare low bytes
  2201 00:B784: 88                 DEY                     ; decrement index
  2202 00:B785: B1 60              LDA   (des_pl),Y        ; get pointer low byte
  2203 00:B787: C5 33              CMP   Sstorl            ; compare bottom of string space low byte
  2204 00:B789: 90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
  2205                        
  2206                                                      ; pointer was >= to bottom of string space pointer
  2207                        LAB_17E6
  2208 00:B78B: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  2209 00:B78D: C4 2E              CPY   Svarh             ; compare start of vars high byte
  2210 00:B78F: 90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
  2211 00:B791: D0 0C              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
  2212                                                      ; else high bytes were equal so ..
  2213 00:B793: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  2214 00:B795: C5 2D              CMP   Svarl             ; compare start of vars low byte
  2215 00:B797: B0 06              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
  2216                        
  2217                        LAB_17F4
  2218 00:B799: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  2219 00:B79B: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  2220 00:B79D: 80 14              BRA   LAB_1811          ; clean stack, copy descriptor to variable and return
  2221                        
  2222                                                      ; make space and copy string
  2223                        LAB_17FB
  2224 00:B79F: B2 60              LDA   (des_pl)          ; get string length
  2225 00:B7A1: 20 CD C0           JSR   LAB_209C          ; copy string
  2226 00:B7A4: A5 50              LDA   des_2l            ; get descriptor pointer low byte
  2227 00:B7A6: A4 51              LDY   des_2h            ; get descriptor pointer high byte
  2228 00:B7A8: 85 6A              STA   ssptr_l           ; save descriptor pointer low byte
  2229 00:B7AA: 84 6B              STY   ssptr_h           ; save descriptor pointer high byte
  2230 00:B7AC: 20 AD C2           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
  2231 00:B7AF: A9 5E              LDA   #<FAC1_e          ; set descriptor pointer low byte
  2232 00:B7B1: A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
  2233                        
  2234                                                      ; clean stack and assign value to string variable
  2235                        LAB_1811
  2236 00:B7B3: 85 50              STA   des_2l            ; save descriptor_2 pointer low byte
  2237 00:B7B5: 84 51              STY   des_2h            ; save descriptor_2 pointer high byte
  2238 00:B7B7: 20 0F C3           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
  2239 00:B7BA: A0 00              LDY   #$00              ; index to length
  2240 00:B7BC: B1 50              LDA   (des_2l),Y        ; get string length
  2241 00:B7BE: 91 49              STA   (Lvarpl),Y        ; copy to let string variable
  2242 00:B7C0: C8                 INY                     ; index to string pointer low byte
  2243 00:B7C1: B1 50              LDA   (des_2l),Y        ; get string pointer low byte
  2244 00:B7C3: 91 49              STA   (Lvarpl),Y        ; copy to let string variable
  2245 00:B7C5: C8                 INY                     ; index to string pointer high byte
  2246 00:B7C6: B1 50              LDA   (des_2l),Y        ; get string pointer high byte
  2247 00:B7C8: 91 49              STA   (Lvarpl),Y        ; copy to let string variable
  2248 00:B7CA: 60                 RTS
  2249                        
  2250                        ; perform GET
  2251                        
  2252                        LAB_GET
  2253 00:B7CB: 20 4C BD           JSR   LAB_GVAR          ; get var address
  2254 00:B7CE: 85 49              STA   Lvarpl            ; save var address low byte
  2255 00:B7D0: 84 4A              STY   Lvarph            ; save var address high byte
  2256 00:B7D2: 20 38 CE           JSR   INGET             ; get input byte
  2257 00:B7D5: A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2258 00:B7D7: 30 07              BMI   LAB_GETS          ; go get string character
  2259                                                      ; was numeric get
  2260 00:B7D9: A8                 TAY                     ; copy character to Y
  2261 00:B7DA: 20 05 C0           JSR   LAB_1FD0          ; convert Y to byte in FAC1
  2262 00:B7DD: 4C 28 C8           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
  Mon Feb  8 2021  9:20                                                                                                    Page 37


  2263                        
  2264                        LAB_GETS
  2265 00:B7E0: 48                 PHA                     ; save character
  2266 00:B7E1: A9 01              LDA   #$01              ; string is single byte
  2267 00:B7E3: B0 01              BCS   LAB_IsByte        ; branch if byte received
  2268                        
  2269 00:B7E5: 68                 PLA                     ; string is null
  2270                        LAB_IsByte
  2271 00:B7E6: 20 D5 C0           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  2272                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  2273 00:B7E9: F0 03              BEQ   LAB_NoSt          ; skip store if null string
  2274                        
  2275 00:B7EB: 68                 PLA                     ; get character back
  2276 00:B7EC: 92 5F              STA   (str_pl)          ; save byte in string (byte IS string!)
  2277                        LAB_NoSt
  2278 00:B7EE: 20 22 C1           JSR   LAB_RTST          ; check for space on descriptor stack then put address
  2279                                                      ; and length on descriptor stack and update stack pointers
  2280 00:B7F1: 80 87              BRA   LAB_17D5          ; do string LET and return
  2281                        
  2282                        ; perform PRINT
  2283                        
  2284                        LAB_1829
  2285 00:B7F3: 20 76 B8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2286                        LAB_182C
  2287 00:B7F6: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  2288                        
  2289                        ; PRINT
  2290                        
  2291                        LAB_PRINT
  2292 00:B7F9: F0 37              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
  2293                        
  2294                        LAB_1831
  2295 00:B7FB: C9 A8              CMP   #TK_TAB           ; compare with TAB( token
  2296 00:B7FD: F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
  2297                        
  2298 00:B7FF: C9 AC              CMP   #TK_SPC           ; compare with SPC( token
  2299 00:B801: F0 4E              BEQ   LAB_18A2          ; go do TAB/SPC
  2300                        
  2301 00:B803: C9 2C              CMP   #','              ; compare with ","
  2302 00:B805: F0 34              BEQ   LAB_188B          ; go do move to next TAB mark
  2303                        
  2304 00:B807: C9 3B              CMP   #';'              ; compare with ";"
  2305 00:B809: F0 62              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
  2306                        
  2307 00:B80B: 20 7C BA           JSR   LAB_EVEX          ; evaluate expression
  2308 00:B80E: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2309 00:B810: 30 E1              BMI   LAB_1829          ; branch if string
  2310                        
  2311 00:B812: 20 0E CA           JSR   LAB_296E          ; convert FAC1 to string
  2312 00:B815: 20 DF C0           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  2313                        
  2314                        ; don't check fit if terminal width byte is zero
  2315                        
  2316 00:B818: A5 08              LDA   TWidth            ; get terminal width byte
  2317 00:B81A: F0 0A              BEQ   LAB_185E          ; skip check if zero
  2318                        
  2319 00:B81C: 38                 SEC                     ; set carry for subtract
  2320 00:B81D: E5 07              SBC   TPos              ; subtract terminal position
  2321 00:B81F: F2 60              SBC   (des_pl)          ; subtract string length
  2322 00:B821: B0 03              BCS   LAB_185E          ; branch if less than terminal width
  2323                        
  2324 00:B823: 20 32 B8           JSR   LAB_CRLF          ; else print CR/LF
  2325                        LAB_185E
  Mon Feb  8 2021  9:20                                                                                                    Page 38


  2326 00:B826: 20 76 B8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2327 00:B829: 80 CB              BRA   LAB_182C          ; always go continue processing line
  2328                        
  2329                        ; CR/LF return to BASIC from BASIC input handler
  2330                        
  2331                        LAB_1866
  2332 00:B82B: 9E 00 05           STZ   Ibuffs,X          ; null terminate input
  2333 00:B82E: A2 00              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
  2334 00:B830: A0 05              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
  2335                        
  2336                        ; print CR/LF
  2337                        
  2338                        LAB_CRLF
  2339 00:B832: A9 0D              LDA   #$0D              ; load [CR]
  2340 00:B834: 20 8E B8           JSR   LAB_PRNA          ; go print the character
  2341 00:B837: A9 0A              LDA   #$0A              ; load [LF]
  2342 00:B839: 80 53              BRA   LAB_PRNA          ; go print the character and return, branch always
  2343                        
  2344                        LAB_188B
  2345 00:B83B: A5 07              LDA   TPos              ; get terminal position
  2346 00:B83D: C5 09              CMP   Iclim             ; compare with input column limit
  2347 00:B83F: 90 05              BCC   LAB_1897          ; branch if less
  2348                        
  2349 00:B841: 20 32 B8           JSR   LAB_CRLF          ; else print CR/LF (next line)
  2350 00:B844: 80 27              BRA   LAB_18BD          ; continue with PRINT processing (branch always)
  2351                        
  2352                        LAB_1897
  2353 00:B846: 38                 SEC                     ; set carry for subtract
  2354                        LAB_1898
  2355 00:B847: E5 16              SBC   TabSiz            ; subtract TAB size
  2356 00:B849: B0 FC              BCS   LAB_1898          ; loop if result was +ve
  2357                        
  2358 00:B84B: 49 FF              EOR   #$FF              ; complement it
  2359 00:B84D: 69 01              ADC   #$01              ; +1 (twos complement)
  2360 00:B84F: 80 12              BRA   LAB_18B6          ; always print A spaces (result is never $00)
  2361                        
  2362                                                      ; do TAB/SPC
  2363                        LAB_18A2
  2364 00:B851: 48                 PHA                     ; save token
  2365 00:B852: 20 1E C4           JSR   LAB_SGBY          ; scan and get byte parameter
  2366 00:B855: C9 29              CMP   #$29              ; is next character )
  2367 00:B857: D0 7B              BNE   LAB_1910          ; if not do syntax error then warm start
  2368                        
  2369 00:B859: 68                 PLA                     ; get token back
  2370 00:B85A: C9 A8              CMP   #TK_TAB           ; was it TAB ?
  2371 00:B85C: D0 06              BNE   LAB_18B7          ; if not go do SPC
  2372                        
  2373                                                      ; calculate TAB offset
  2374 00:B85E: 8A                 TXA                     ; copy integer value to A
  2375 00:B85F: E5 07              SBC   TPos              ; subtract terminal position
  2376 00:B861: 90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
  2377                        
  2378                                                      ; print A spaces
  2379                        LAB_18B6
  2380 00:B863: AA                 TAX                     ; copy result to X
  2381                        LAB_18B7
  2382 00:B864: 8A                 TXA                     ; set flags on size for SPC
  2383 00:B865: F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
  2384                        
  2385                                                      ; print X spaces
  2386                        LAB_18BA
  2387 00:B867: 20 88 B8           JSR   LAB_18E0          ; print " "
  2388 00:B86A: CA                 DEX                     ; decrement count
  Mon Feb  8 2021  9:20                                                                                                    Page 39


  2389 00:B86B: D0 FA              BNE   LAB_18BA          ; loop if not all done
  2390                        
  2391                                                      ; continue with PRINT processing
  2392                        LAB_18BD
  2393 00:B86D: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2394 00:B870: D0 89              BNE   LAB_1831          ; if more to print go do it
  2395                        
  2396 00:B872: 60                 RTS
  2397                        
  2398                        ; print null terminated string from memory
  2399                        
  2400                        LAB_18C3
  2401 00:B873: 20 DF C0           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  2402                        
  2403                        ; print string from Sutill/Sutilh
  2404                        
  2405                        LAB_18C6
  2406 00:B876: 20 DA C2           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  2407                                                      ; space returns with A = length, X=$71=pointer low byte,
  2408                                                      ; Y=$72=pointer high byte
  2409 00:B879: A0 00              LDY   #$00              ; reset index
  2410 00:B87B: AA                 TAX                     ; copy length to X
  2411 00:B87C: F0 4A              BEQ   LAB_188C          ; exit (RTS) if null string
  2412                        
  2413                        LAB_18CD
  2414                        
  2415 00:B87E: B1 23              LDA   (ut1_pl),Y        ; get next byte
  2416 00:B880: 20 8E B8           JSR   LAB_PRNA          ; go print the character
  2417 00:B883: C8                 INY                     ; increment index
  2418 00:B884: CA                 DEX                     ; decrement count
  2419 00:B885: D0 F7              BNE   LAB_18CD          ; loop if not done yet
  2420 00:B887: 60                 RTS
  2421                        
  2422                                                      ; Print single format character
  2423                        ; print " "
  2424                        
  2425                        LAB_18E0
  2426 00:B888: A9 20              LDA   #$20              ; load " "
  2427 00:B88A: 80 02              BRA   LAB_PRNA          ; branch around next instruction, saves one clock cycle
  2428                        
  2429                        ; print "?" character
  2430                        
  2431                        LAB_18E3
  2432 00:B88C: A9 3F              LDA   #$3F              ; load "?" character
  2433                        
  2434                        ; print character in A
  2435                        ; now includes the null handler
  2436                        ; also includes infinite line length code
  2437                        ; note! some routines expect this one to exit with Zb=0
  2438                        
  2439                        LAB_PRNA
  2440 00:B88E: C9 20              CMP   #' '              ; compare with " "
  2441 00:B890: 90 19              BCC   LAB_18F9          ; branch if less (non printing)
  2442                        
  2443                                                      ; else printable character
  2444 00:B892: 48                 PHA                     ; save the character
  2445                        
  2446                        ; don't check fit if terminal width byte is zero
  2447                        
  2448 00:B893: A5 08              LDA   TWidth            ; get terminal width
  2449 00:B895: D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
  2450                        
  2451                        ; is "infinite line" so check TAB position
  Mon Feb  8 2021  9:20                                                                                                    Page 40


  2452                        
  2453 00:B897: A5 07              LDA   TPos              ; get position
  2454 00:B899: E5 16              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
  2455 00:B89B: D0 0B              BNE   LAB_18F7          ; skip reset if different
  2456                        
  2457 00:B89D: 85 07              STA   TPos              ; else reset position
  2458 00:B89F: F0 07              BEQ   LAB_18F7          ; go print character
  2459                        
  2460                        LAB_18F0
  2461 00:B8A1: C5 07              CMP   TPos              ; compare with terminal character position
  2462 00:B8A3: D0 03              BNE   LAB_18F7          ; branch if not at end of line
  2463                        
  2464 00:B8A5: 20 32 B8           JSR   LAB_CRLF          ; else print CR/LF
  2465                        LAB_18F7
  2466 00:B8A8: E6 07              INC   TPos              ; increment terminal position
  2467 00:B8AA: 68                 PLA                     ; get character back
  2468                        LAB_18F9
  2469 00:B8AB: 20 41 D0           JSR   V_OUTP            ; output byte via output vector
  2470 00:B8AE: C9 0D              CMP   #$0D              ; compare with [CR]
  2471 00:B8B0: D0 14              BNE   LAB_188A          ; branch if not [CR]
  2472                        
  2473                                                      ; else print nullct nulls after the [CR]
  2474 00:B8B2: 86 2A              STX   TempB             ; save buffer index
  2475 00:B8B4: A6 06              LDX   Nullct            ; get null count
  2476 00:B8B6: F0 0A              BEQ   LAB_1886          ; branch if no nulls
  2477                        
  2478 00:B8B8: A9 00              LDA   #$00              ; load [NULL]
  2479                        LAB_1880
  2480 00:B8BA: 20 8E B8           JSR   LAB_PRNA          ; go print the character
  2481 00:B8BD: CA                 DEX                     ; decrement count
  2482 00:B8BE: D0 FA              BNE   LAB_1880          ; loop if not all done
  2483                        
  2484 00:B8C0: A9 0D              LDA   #$0D              ; restore the character (and set the flags)
  2485                        LAB_1886
  2486 00:B8C2: 86 07              STX   TPos              ; clear terminal position (X always = zero when we get here)
  2487 00:B8C4: A6 2A              LDX   TempB             ; restore buffer index
  2488                        LAB_188A
  2489 00:B8C6: 29 FF              AND   #$FF              ; set the flags
  2490                        LAB_188C
  2491 00:B8C8: 60                 RTS
  2492                        
  2493                        ; handle bad input data
  2494                        
  2495                        LAB_1904
  2496 00:B8C9: 7F 14 0B           BBR7  Imode,LAB_1913    ; Check input mode, branch if INPUT ($00)
  2497                        ;      LDA   Imode             ; get input mode flag, $00=INPUT, $80=READ
  2498                        ;      BPL   LAB_1913          ; branch if INPUT (go do redo)
  2499                        
  2500 00:B8CC: A5 3F              LDA   Dlinel            ; get current DATA line low byte
  2501 00:B8CE: A4 40              LDY   Dlineh            ; get current DATA line high byte
  2502 00:B8D0: 85 39              STA   Clinel            ; save current line low byte
  2503 00:B8D2: 84 3A              STY   Clineh            ; save current line high byte
  2504                        LAB_1910
  2505 00:B8D4: 4C 9C BB           JMP   LAB_SNER          ; do syntax error then warm start
  2506                        
  2507                                                      ; mode was INPUT
  2508                        LAB_1913
  2509 00:B8D7: A9 7B              LDA   #<LAB_REDO        ; point to redo message (low addr)
  2510 00:B8D9: A0 D7              LDY   #>LAB_REDO        ; point to redo message (high addr)
  2511 00:B8DB: 20 73 B8           JSR   LAB_18C3          ; print null terminated string from memory
  2512 00:B8DE: A5 3D              LDA   Cpntrl            ; get continue pointer low byte
  2513 00:B8E0: A4 3E              LDY   Cpntrh            ; get continue pointer high byte
  2514 00:B8E2: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  Mon Feb  8 2021  9:20                                                                                                    Page 41


  2515 00:B8E4: 84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
  2516 00:B8E6: 60                 RTS
  2517                        
  2518                        ; perform INPUT
  2519                        
  2520                        LAB_INPUT
  2521 00:B8E7: C9 22              CMP   #$22              ; compare next byte with open quote
  2522 00:B8E9: D0 0B              BNE   LAB_1934          ; branch if no prompt string
  2523                        
  2524 00:B8EB: 20 5A BB           JSR   LAB_1BC1          ; print "..." string
  2525 00:B8EE: A9 3B              LDA   #$3B              ; load A with ";"
  2526 00:B8F0: 20 8D BB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  2527 00:B8F3: 20 76 B8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2528                        
  2529                                                      ; done with prompt, now get data
  2530                        LAB_1934
  2531 00:B8F6: 20 09 C0           JSR   LAB_CKRN          ; check not Direct, back here if ok
  2532 00:B8F9: 20 07 B2           JSR   LAB_INLN          ; print "? " and get BASIC input
  2533 00:B8FC: A9 00              LDA   #$00              ; set mode = INPUT
  2534 00:B8FE: CD 00 05           CMP   Ibuffs            ; test first byte in buffer
  2535 00:B901: D0 09              BNE   LAB_1953          ; branch if not null input
  2536 00:B903: 4C EB B4           JMP   LAB_1647          ; go do BREAK exit
  2537                        
  2538                        ; perform READ
  2539                        
  2540                        LAB_READ
  2541 00:B906: A6 41              LDX   Dptrl             ; get DATA pointer low byte
  2542 00:B908: A4 42              LDY   Dptrh             ; get DATA pointer high byte
  2543 00:B90A: A9 80              LDA   #$80              ; set mode = READ
  2544                        
  2545                        LAB_1953
  2546 00:B90C: 85 14              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
  2547 00:B90E: 86 43              STX   Rdptrl            ; save READ pointer low byte
  2548 00:B910: 84 44              STY   Rdptrh            ; save READ pointer high byte
  2549                        
  2550                                                      ; READ or INPUT next variable from list
  2551                        LAB_195B
  2552 00:B912: 20 4C BD           JSR   LAB_GVAR          ; get (var) address
  2553 00:B915: 85 49              STA   Lvarpl            ; save address low byte
  2554 00:B917: 84 4A              STY   Lvarph            ; save address high byte
  2555 00:B919: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  2556 00:B91B: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  2557 00:B91D: 85 0A              STA   Itempl            ; save as temporary integer low byte
  2558 00:B91F: 84 0B              STY   Itemph            ; save as temporary integer high byte
  2559 00:B921: A6 43              LDX   Rdptrl            ; get READ pointer low byte
  2560 00:B923: A4 44              LDY   Rdptrh            ; get READ pointer high byte
  2561 00:B925: 86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
  2562 00:B927: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
  2563 00:B929: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  2564 00:B92C: D0 10              BNE   LAB_1988          ; branch if not null
  2565                        
  2566                                                      ; pointer was to null entry
  2567 00:B92E: FF 14 64           BBS7  Imode,LAB_19DD    ; test Input mode, branch if $80=READ
  2568                        ;      BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
  2569                        ;      BMI   LAB_19DD          ; branch if READ
  2570                        
  2571                                                      ; mode was INPUT
  2572 00:B931: 20 8C B8           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
  2573 00:B934: 20 07 B2           JSR   LAB_INLN          ; print "? " and get BASIC input
  2574 00:B937: 86 6E              STX   Bpntrl            ; set BASIC execute pointer low byte
  2575 00:B939: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
  2576                        LAB_1985
  2577 00:B93B: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  Mon Feb  8 2021  9:20                                                                                                    Page 42


  2578                        LAB_1988
  2579 00:B93E: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2580 00:B940: 10 23              BPL   LAB_19B0          ; branch if numeric
  2581                        
  2582                                                      ; else get string
  2583 00:B942: 85 0D              STA   Srchc             ; save search character
  2584 00:B944: C9 22              CMP   #$22              ; was it " ?
  2585 00:B946: F0 07              BEQ   LAB_1999          ; branch if so
  2586                        
  2587 00:B948: A9 3A              LDA   #':'              ; else search character is ":"
  2588 00:B94A: 85 0D              STA   Srchc             ; set new search character
  2589 00:B94C: A9 2C              LDA   #','              ; other search character is ","
  2590 00:B94E: 18                 CLC                     ; clear carry for add
  2591                        LAB_1999
  2592 00:B94F: 85 0E              STA   Asrch             ; set second search character
  2593 00:B951: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  2594 00:B953: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  2595                        
  2596 00:B955: 69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
  2597 00:B957: 90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
  2598                        
  2599 00:B959: C8                 INY                     ; else increment high byte
  2600                        LAB_19A4
  2601 00:B95A: 20 E5 C0           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
  2602 00:B95D: 20 5C C4           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
  2603 00:B960: 20 7A B7           JSR   LAB_17D5          ; go do string LET
  2604 00:B963: 80 06              BRA   LAB_19B6          ; go check string terminator
  2605                        
  2606                                                      ; get numeric INPUT
  2607                        LAB_19B0
  2608 00:B965: 20 26 C9           JSR   LAB_2887          ; get FAC1 from string
  2609 00:B968: 20 28 C8           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
  2610                        LAB_19B6
  2611 00:B96B: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  2612 00:B96E: F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
  2613                        
  2614 00:B970: C9 2C              CMP   #','              ; else compare with ","
  2615 00:B972: F0 03              BEQ   LAB_19C2          ; branch if ","
  2616                        
  2617 00:B974: 4C C9 B8           JMP   LAB_1904          ; else go handle bad input data
  2618                        
  2619                                                      ; got good input data
  2620                        LAB_19C2
  2621 00:B977: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2622                        LAB_19C5
  2623 00:B97A: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
  2624 00:B97C: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
  2625 00:B97E: 85 43              STA   Rdptrl            ; save for now
  2626 00:B980: 84 44              STY   Rdptrh            ; save for now
  2627 00:B982: A5 0A              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
  2628 00:B984: A4 0B              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
  2629 00:B986: 85 6E              STA   Bpntrl            ; set BASIC execute pointer low byte
  2630 00:B988: 84 6F              STY   Bpntrh            ; set BASIC execute pointer high byte
  2631 00:B98A: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  2632 00:B98D: F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
  2633                        
  2634 00:B98F: 20 98 BB           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
  2635 00:B992: 4C 12 B9           JMP   LAB_195B          ; go INPUT next variable from list
  2636                        
  2637                                                      ; find next DATA statement or do "Out of DATA" error
  2638                        LAB_19DD
  2639 00:B995: 20 54 B6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  2640 00:B998: C8                 INY                     ; increment index
  Mon Feb  8 2021  9:20                                                                                                    Page 43


  2641 00:B999: AA                 TAX                     ; copy character ([:] or [EOL])
  2642 00:B99A: D0 12              BNE   LAB_19F6          ; branch if [:]
  2643                        
  2644 00:B99C: A2 06              LDX   #$06              ; set for "Out of DATA" error
  2645 00:B99E: C8                 INY                     ; increment index, now points to next line pointer high byte
  2646 00:B99F: B1 6E              LDA   (Bpntrl),Y        ; get next line pointer high byte
  2647 00:B9A1: F0 70              BEQ   LAB_1A54          ; branch if end (eventually does error X)
  2648                        
  2649 00:B9A3: C8                 INY                     ; increment index
  2650 00:B9A4: B1 6E              LDA   (Bpntrl),Y        ; get next line # low byte
  2651 00:B9A6: 85 3F              STA   Dlinel            ; save current DATA line low byte
  2652 00:B9A8: C8                 INY                     ; increment index
  2653 00:B9A9: B1 6E              LDA   (Bpntrl),Y        ; get next line # high byte
  2654 00:B9AB: C8                 INY                     ; increment index
  2655 00:B9AC: 85 40              STA   Dlineh            ; save current DATA line high byte
  2656                        LAB_19F6
  2657 00:B9AE: B1 6E              LDA   (Bpntrl),Y        ; get byte
  2658 00:B9B0: C8                 INY                     ; increment index
  2659 00:B9B1: AA                 TAX                     ; copy to X
  2660 00:B9B2: 20 46 B6           JSR   LAB_170F          ; set BASIC execute pointer
  2661 00:B9B5: E0 83              CPX   #TK_DATA          ; compare with "DATA" token
  2662 00:B9B7: F0 82              BEQ   LAB_1985          ; was "DATA" so go do next READ
  2663 00:B9B9: 80 DA              BRA   LAB_19DD          ; go find next statement if not "DATA"
  2664                        
  2665                        ; end of INPUT/READ routine
  2666                        
  2667                        LAB_1A03
  2668 00:B9BB: A5 43              LDA   Rdptrl            ; get temp READ pointer low byte
  2669 00:B9BD: A4 44              LDY   Rdptrh            ; get temp READ pointer high byte
  2670 00:B9BF: 7F 14 03           BBR7  Imode,LAB_1A0E    ; test input mode, branch if $00=INPUT
  2671                        ;      LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
  2672                        ;      BPL   LAB_1A0E          ; branch if INPUT
  2673 00:B9C2: 4C 0D B5           JMP   LAB_1624          ; save AY as DATA pointer and return
  2674                        
  2675                                                      ; we were getting INPUT
  2676                        LAB_1A0E
  2677 00:B9C5: B2 43              LDA   (Rdptrl)          ; get next byte
  2678 00:B9C7: D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
  2679 00:B9C9: 60                 RTS
  2680                        
  2681                                                      ; user typed too much
  2682                        LAB_1A1B
  2683 00:B9CA: A9 6A              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
  2684 00:B9CC: A0 D7              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
  2685 00:B9CE: 4C 73 B8           JMP   LAB_18C3          ; print null terminated string from memory and return
  2686                        
  2687                        ; search the stack for FOR activity
  2688                        ; exit with z=1 if FOR else exit with z=0
  2689                        
  2690                        LAB_11A1
  2691 00:B9D1: BA                 TSX                     ; copy stack pointer
  2692 00:B9D2: E8                 INX                     ; +1 pass return address
  2693 00:B9D3: E8                 INX                     ; +2 pass return address
  2694 00:B9D4: E8                 INX                     ; +3 pass calling routine return address
  2695 00:B9D5: E8                 INX                     ; +4 pass calling routine return address
  2696                        LAB_11A6
  2697 00:B9D6: BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
  2698 00:B9D9: C9 81              CMP   #TK_FOR           ; is it FOR token
  2699 00:B9DB: D0 21              BNE   LAB_11CE          ; exit if not FOR token
  2700                        
  2701                                                      ; was FOR token
  2702 00:B9DD: A5 4A              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
  2703 00:B9DF: D0 0A              BNE   LAB_11BB          ; branch if not null
  Mon Feb  8 2021  9:20                                                                                                    Page 44


  2704                        
  2705 00:B9E1: BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
  2706 00:B9E4: 85 49              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
  2707 00:B9E6: BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
  2708 00:B9E9: 85 4A              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
  2709                        LAB_11BB
  2710 00:B9EB: DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
  2711 00:B9EE: D0 07              BNE   LAB_11C7          ; branch if no match
  2712                        
  2713 00:B9F0: A5 49              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
  2714 00:B9F2: DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
  2715 00:B9F5: F0 07              BEQ   LAB_11CE          ; exit if match found
  2716                        
  2717                        LAB_11C7
  2718 00:B9F7: 8A                 TXA                     ; copy index
  2719 00:B9F8: 18                 CLC                     ; clear carry for add
  2720 00:B9F9: 69 10              ADC   #$10              ; add FOR stack use size
  2721 00:B9FB: AA                 TAX                     ; copy back to index
  2722 00:B9FC: D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
  2723                        
  2724                        LAB_11CE
  2725 00:B9FE: 60                 RTS
  2726                        
  2727                        ; perform NEXT
  2728                        
  2729                        LAB_NEXT
  2730 00:B9FF: D0 04              BNE   LAB_1A46          ; branch if NEXT var
  2731                        
  2732 00:BA01: A0 00              LDY   #$00              ; else clear Y
  2733 00:BA03: 80 03              BRA   LAB_1A49          ; branch always (no variable to search for)
  2734                        
  2735                        ; NEXT var
  2736                        
  2737                        LAB_1A46
  2738 00:BA05: 20 4C BD           JSR   LAB_GVAR          ; get variable address
  2739                        LAB_1A49
  2740 00:BA08: 85 49              STA   Frnxtl            ; store variable pointer low byte
  2741 00:BA0A: 84 4A              STY   Frnxth            ; store variable pointer high byte
  2742                                                      ; (both cleared if no variable defined)
  2743 00:BA0C: 20 D1 B9           JSR   LAB_11A1          ; search the stack for FOR activity
  2744 00:BA0F: F0 04              BEQ   LAB_1A56          ; branch if found
  2745                        
  2746 00:BA11: A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
  2747                        LAB_1A54
  2748 00:BA13: F0 64              BEQ   LAB_1ABE          ; do error #X, then warm start
  2749                        
  2750                        LAB_1A56
  2751 00:BA15: 9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
  2752                        
  2753 00:BA16: 8A                 TXA                     ; copy stack pointer
  2754 00:BA17: 38                 SEC                     ; set carry for subtract
  2755 00:BA18: E9 F7              SBC   #$F7              ; point to TO var
  2756 00:BA1A: 85 25              STA   ut2_pl            ; save pointer to TO var for compare
  2757 00:BA1C: 69 FB              ADC   #$FB              ; point to STEP var
  2758                        
  2759 00:BA1E: A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
  2760 00:BA20: 20 02 C8           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
  2761 00:BA23: BA                 TSX                     ; get stack pointer back
  2762 00:BA24: BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
  2763 00:BA27: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  2764 00:BA29: A5 49              LDA   Frnxtl            ; get FOR variable pointer low byte
  2765 00:BA2B: A4 4A              LDY   Frnxth            ; get FOR variable pointer high byte
  2766 00:BA2D: 20 4A C5           JSR   LAB_246C          ; add (FOR variable) to FAC1
  Mon Feb  8 2021  9:20                                                                                                    Page 45


  2767 00:BA30: 20 28 C8           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
  2768 00:BA33: A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
  2769 00:BA35: 20 9A C8           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
  2770 00:BA38: BA                 TSX                     ; get stack pointer back
  2771 00:BA39: DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
  2772 00:BA3C: F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
  2773                        
  2774                                                      ; loop back and do it all again
  2775 00:BA3E: BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
  2776 00:BA41: 85 39              STA   Clinel            ; save current line low byte
  2777 00:BA43: BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
  2778 00:BA46: 85 3A              STA   Clineh            ; save current line high byte
  2779 00:BA48: BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
  2780 00:BA4B: 85 6E              STA   Bpntrl            ; save BASIC execute pointer low byte
  2781 00:BA4D: BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
  2782 00:BA50: 85 6F              STA   Bpntrh            ; save BASIC execute pointer high byte
  2783                        LAB_1A98
  2784 00:BA52: 4C 86 B4           JMP   LAB_15C2          ; go do interpreter inner loop
  2785                        
  2786                                                      ; loop complete so carry on
  2787                        LAB_1A9B
  2788 00:BA55: 8A                 TXA                     ; stack copy to A
  2789 00:BA56: 69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
  2790 00:BA58: AA                 TAX                     ; copy back to index
  2791 00:BA59: 9A                 TXS                     ; copy to stack pointer
  2792 00:BA5A: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  2793 00:BA5D: C9 2C              CMP   #','              ; compare with ","
  2794 00:BA5F: D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
  2795                        
  2796                                                      ; was "," so another NEXT variable to do
  2797 00:BA61: 20 B5 CF           JSR   LAB_IGBY          ; else increment and scan memory
  2798 00:BA64: 20 05 BA           JSR   LAB_1A46          ; do NEXT (var)
  2799                        
  2800                        ; evaluate expression and check is numeric, else do type mismatch
  2801                        
  2802                        LAB_EVNM
  2803 00:BA67: 20 7C BA           JSR   LAB_EVEX          ; evaluate expression
  2804                        
  2805                        ; check if source is numeric, else do type mismatch
  2806                        
  2807                        LAB_CTNM
  2808 00:BA6A: 18                 CLC                     ; destination is numeric
  2809 00:BA6B: 80 01              BRA   LAB_CKTM          ; branch around SEC
  2810                        
  2811                        ; check if source is string, else do type mismatch
  2812                        
  2813                        LAB_CTST
  2814 00:BA6D: 38                 SEC                     ; required type is string
  2815                        
  2816                        ; type match check, set C for string, clear C for numeric
  2817                        
  2818                        LAB_CKTM
  2819 00:BA6E: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2820 00:BA70: 30 03              BMI   LAB_1ABA          ; branch if data type is string
  2821                                                      ; else data type was numeric
  2822 00:BA72: B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
  2823                        LAB_1AB9
  2824 00:BA74: 60                 RTS
  2825                        
  2826                                                      ; data type was string, now check required type
  2827                        LAB_1ABA
  2828 00:BA75: B0 FD              BCS   LAB_1AB9          ; exit if required type is string
  2829                        
  Mon Feb  8 2021  9:20                                                                                                    Page 46


  2830                                                      ; else do type mismatch error
  2831                        LAB_1ABC
  2832 00:BA77: A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
  2833                        LAB_1ABE
  2834 00:BA79: 4C 01 B1           JMP   LAB_XERR          ; do error #X, then warm start
  2835                        
  2836                        ; evaluate expression
  2837                        
  2838                        LAB_EVEX
  2839 00:BA7C: A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
  2840 00:BA7E: D0 02              BNE   LAB_1AC7          ; skip next if not zero
  2841                        
  2842 00:BA80: C6 6F              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
  2843                        LAB_1AC7
  2844 00:BA82: C6 6E              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
  2845                        
  2846                        LAB_EVEZ
  2847 00:BA84: A9 00              LDA   #$00              ; set null precedence (flag done)
  2848                        LAB_1ACC
  2849 00:BA86: 48                 PHA                     ; push precedence byte
  2850 00:BA87: A9 02              LDA   #$02              ; 2 bytes
  2851 00:BA89: 20 C6 B0           JSR   LAB_1212          ; check room on stack for A bytes
  2852 00:BA8C: 20 69 BB           JSR   LAB_GVAL          ; get value from line
  2853 00:BA8F: 64 4D              STZ   comp_f            ; clear compare function flag
  2854                        LAB_1ADB
  2855 00:BA91: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  2856                        LAB_1ADE
  2857 00:BA94: 38                 SEC                     ; set carry for subtract
  2858 00:BA95: E9 BC              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
  2859 00:BA97: 90 16              BCC   LAB_1AFA          ; branch if < TK_GT
  2860                        
  2861 00:BA99: C9 03              CMP   #$03              ; compare with ">" to "<" tokens
  2862 00:BA9B: B0 12              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
  2863                        
  2864                                                      ; was token for > = or < (A = 0, 1 or 2)
  2865 00:BA9D: C9 01              CMP   #$01              ; compare with token for =
  2866 00:BA9F: 2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
  2867                                                      ; (A = 0, 3 or 5)
  2868 00:BAA0: 49 01              EOR   #$01              ; toggle b0
  2869                                                      ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
  2870 00:BAA2: 45 4D              EOR   comp_f            ; EOR with compare function flag bits
  2871 00:BAA4: C5 4D              CMP   comp_f            ; compare with compare function flag
  2872 00:BAA6: 90 66              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
  2873                                                      ; was more than one <, = or >)
  2874                        
  2875 00:BAA8: 85 4D              STA   comp_f            ; save new compare function flag
  2876 00:BAAA: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  2877 00:BAAD: 80 E5              BRA   LAB_1ADE          ; go do next character
  2878                        
  2879                                                      ; token is < ">" or > "<" tokens
  2880                        LAB_1AFA
  2881 00:BAAF: A6 4D              LDX   comp_f            ; get compare function flag
  2882 00:BAB1: D0 2C              BNE   LAB_1B2A          ; branch if compare function
  2883 00:BAB3: B0 7D              BCS   LAB_1B78          ; go do functions
  2884                        
  2885                                                      ; else was <  TK_GT so is operator or lower
  2886 00:BAB5: 69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
  2887 00:BAB7: 90 79              BCC   LAB_1B78          ; branch if < + operator
  2888                                                      ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
  2889 00:BAB9: D0 07              BNE   LAB_1B0B          ; branch if not + token
  2890                        
  2891 00:BABB: 24 11              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2892 00:BABD: 10 03              BPL   LAB_1B0B          ; branch if not string
  Mon Feb  8 2021  9:20                                                                                                    Page 47


  2893                        
  2894                                                      ; will only be $00 if type is string and token was +
  2895 00:BABF: 4C 72 C2           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
  2896                                                      ; is in line, and return
  2897                        
  2898                        LAB_1B0B
  2899 00:BAC2: 85 23              STA   ut1_pl            ; save it
  2900 00:BAC4: 0A                 ASL                     ; *2
  2901 00:BAC5: 65 23              ADC   ut1_pl            ; *3
  2902 00:BAC7: A8                 TAY                     ; copy to index
  2903                        LAB_1B13
  2904 00:BAC8: 68                 PLA                     ; pull previous precedence
  2905 00:BAC9: D9 73 D2           CMP   LAB_OPPT,Y        ; compare with precedence byte
  2906 00:BACC: B0 69              BCS   LAB_1B7D          ; branch if A >=
  2907                        
  2908 00:BACE: 20 6A BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  2909                        LAB_1B1C
  2910 00:BAD1: 48                 PHA                     ; save precedence
  2911                        LAB_1B1D
  2912 00:BAD2: 20 FA BA           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
  2913 00:BAD5: 68                 PLA                     ; restore precedence
  2914 00:BAD6: A4 4B              LDY   prstk             ; get precedence stacked flag
  2915 00:BAD8: 10 19              BPL   LAB_1B3C          ; branch if stacked values
  2916                        
  2917 00:BADA: AA                 TAX                     ; copy precedence (set flags)
  2918 00:BADB: F0 7A              BEQ   LAB_1B9D          ; exit if done
  2919 00:BADD: 80 61              BRA   LAB_1B86          ; else pop FAC2 and return, branch always
  2920                        
  2921                        LAB_1B2A
  2922 00:BADF: 26 11              ROL   Dtypef            ; shift data type flag into Cb
  2923 00:BAE1: 8A                 TXA                     ; copy compare function flag
  2924 00:BAE2: 85 11              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
  2925 00:BAE4: 2A                 ROL                     ; shift data type into compare function byte b0
  2926 00:BAE5: A6 6E              LDX   Bpntrl            ; get BASIC execute pointer low byte
  2927 00:BAE7: D0 02              BNE   LAB_1B34          ; branch if no underflow
  2928                        
  2929 00:BAE9: C6 6F              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
  2930                        LAB_1B34
  2931 00:BAEB: C6 6E              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
  2932             0000000C   TK_LT_PLUS  .EQU TK_LT-TK_PLUS
  2933 00:BAED: A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
  2934 00:BAEF: 85 4D              STA   comp_f            ; save new compare function flag
  2935 00:BAF1: 80 D5              BRA   LAB_1B13          ; branch always
  2936                        
  2937                        LAB_1B3C
  2938 00:BAF3: D9 73 D2           CMP   LAB_OPPT,Y        ; compare with stacked function precedence
  2939 00:BAF6: B0 48              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
  2940 00:BAF8: 80 D7              BRA   LAB_1B1C          ; branch always
  2941                        
  2942                        ;.get vector, execute function then continue evaluation
  2943                        
  2944                        LAB_1B43
  2945 00:BAFA: B9 75 D2           LDA   LAB_OPPT+2,Y      ; get function vector high byte
  2946 00:BAFD: 48                 PHA                     ; onto stack
  2947 00:BAFE: B9 74 D2           LDA   LAB_OPPT+1,Y      ; get function vector low byte
  2948 00:BB01: 48                 PHA                     ; onto stack
  2949                                                      ; now push sign, round FAC1 and put on stack
  2950 00:BB02: 20 11 BB           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
  2951                                                      ; the function
  2952 00:BB05: A5 4D              LDA   comp_f            ; get compare function flag
  2953 00:BB07: 48                 PHA                     ; push compare evaluation byte
  2954 00:BB08: B9 73 D2           LDA   LAB_OPPT,Y        ; get precedence byte
  2955 00:BB0B: 4C 86 BA           JMP   LAB_1ACC          ; continue evaluating expression
  Mon Feb  8 2021  9:20                                                                                                    Page 48


  2956                        
  2957                        LAB_1B53
  2958 00:BB0E: 4C 9C BB           JMP   LAB_SNER          ; do syntax error then warm start
  2959                        
  2960                        ; push sign, round FAC1 and put on stack
  2961                        
  2962                        ; patched routine - Klaus fixed in 2.22p5 by adding NOP if needed
  2963                        ; this fix corrects the RTS increment by one and handles high byte if needed
  2964                        
  2965                        LAB_1B5B
  2966 00:BB11: 68                 PLA                     ; get return addr low byte
  2967 00:BB12: 85 23              STA   ut1_pl            ; save it
  2968 00:BB14: 68                 PLA                     ; get return addr high byte
  2969 00:BB15: 85 24              STA   ut1_ph            ; save it
  2970                        
  2971 00:BB17: E6 23              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
  2972 00:BB19: D0 02              BNE   LAB_1B5B2         ; skip high byte increment if no low byte rollover to $00
  2973 00:BB1B: E6 24              INC   ut1_ph            ; else increment high byte
  2974                        LAB_1B5B2
  2975 00:BB1D: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  2976 00:BB1F: 48                 PHA                     ; push sign
  2977                        
  2978                        ; round FAC1 and put on stack
  2979                        
  2980                        ; LAB_1B66 moved to after JSR LAB_27BA (patch 2.22p5)
  2981                        
  2982 00:BB20: 20 5E C8           JSR   LAB_27BA          ; round FAC1
  2983                        LAB_1B66
  2984 00:BB23: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  2985 00:BB25: 48                 PHA                     ; push on stack
  2986 00:BB26: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  2987 00:BB28: 48                 PHA                     ; push on stack
  2988 00:BB29: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  2989 00:BB2B: 48                 PHA                     ; push on stack
  2990 00:BB2C: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  2991 00:BB2E: 48                 PHA                     ; push on stack
  2992 00:BB2F: 6C 23 00           JMP   (ut1_pl)          ; return, sort of
  2993                        
  2994                        ; do functions
  2995                        
  2996                        LAB_1B78
  2997 00:BB32: A0 FF              LDY   #$FF              ; flag function
  2998 00:BB34: 68                 PLA                     ; pull precedence byte
  2999                        LAB_1B7B
  3000 00:BB35: F0 20              BEQ   LAB_1B9D          ; exit if done
  3001                        
  3002                        LAB_1B7D
  3003 00:BB37: C9 64              CMP   #$64              ; compare previous precedence with $64
  3004 00:BB39: F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
  3005                        
  3006 00:BB3B: 20 6A BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  3007                        LAB_1B84
  3008 00:BB3E: 84 4B              STY   prstk             ; save precedence stacked flag
  3009                        
  3010                                                      ; pop FAC2 and return
  3011                        LAB_1B86
  3012 00:BB40: 68                 PLA                     ; pop byte
  3013 00:BB41: 4A                 LSR                     ; shift out comparison evaluation lowest bit
  3014 00:BB42: 85 15              STA   Cflag             ; save comparison evaluation flag
  3015 00:BB44: 68                 PLA                     ; pop exponent
  3016 00:BB45: 85 65              STA   FAC2_e            ; save FAC2 exponent
  3017 00:BB47: 68                 PLA                     ; pop mantissa1
  3018 00:BB48: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  Mon Feb  8 2021  9:20                                                                                                    Page 49


  3019 00:BB4A: 68                 PLA                     ; pop mantissa2
  3020 00:BB4B: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  3021 00:BB4D: 68                 PLA                     ; pop mantissa3
  3022 00:BB4E: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  3023 00:BB50: 68                 PLA                     ; pop sign
  3024 00:BB51: 85 69              STA   FAC2_s            ; save FAC2 sign (b7)
  3025 00:BB53: 45 62              EOR   FAC1_s            ; EOR FAC1 sign (b7)
  3026 00:BB55: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  3027                        LAB_1B9D
  3028 00:BB57: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  3029 00:BB59: 60                 RTS
  3030                        
  3031                        ; print "..." string to string util area
  3032                        
  3033                        LAB_1BC1
  3034 00:BB5A: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  3035 00:BB5C: A4 6F              LDY   Bpntrh            ; get BASIC execute pointer high byte
  3036 00:BB5E: 69 00              ADC   #$00              ; add carry to low byte
  3037 00:BB60: 90 01              BCC   LAB_1BCA          ; branch if no overflow
  3038                        
  3039 00:BB62: C8                 INY                     ; increment high byte
  3040                        LAB_1BCA
  3041 00:BB63: 20 DF C0           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  3042 00:BB66: 4C 5C C4           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
  3043                        
  3044                        ; get value from line
  3045                        
  3046                        LAB_GVAL
  3047 00:BB69: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  3048 00:BB6C: B0 03              BCS   LAB_1BAC          ; branch if not numeric character
  3049                        
  3050                                                      ; else numeric string found (e.g. 123)
  3051                        LAB_1BA9
  3052 00:BB6E: 4C 26 C9           JMP   LAB_2887          ; get FAC1 from string and return
  3053                        
  3054                        ; get value from line .. continued
  3055                        
  3056                                                      ; wasn't a number so ..
  3057                        LAB_1BAC
  3058 00:BB71: AA                 TAX                     ; set the flags
  3059 00:BB72: 30 2D              BMI   LAB_1BD0          ; if -ve go test token values
  3060                        
  3061                                                      ; else it is either a string, number, variable or (<expr>)
  3062 00:BB74: C9 24              CMP   #'$'              ; compare with "$"
  3063 00:BB76: F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
  3064                        
  3065 00:BB78: C9 25              CMP   #'%'              ; else compare with "%"
  3066 00:BB7A: F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
  3067                        
  3068 00:BB7C: C9 2E              CMP   #'.'              ; compare with "."
  3069 00:BB7E: F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
  3070                        
  3071                                                      ; it wasn't any sort of number so ..
  3072 00:BB80: C9 22              CMP   #$22              ; compare with "
  3073 00:BB82: F0 D6              BEQ   LAB_1BC1          ; branch if open quote
  3074                        
  3075                                                      ; wasn't any sort of number so ..
  3076                        
  3077                        ; evaluate expression within parentheses
  3078                        
  3079 00:BB84: C9 28              CMP   #'('              ; compare with "("
  3080 00:BB86: D0 58              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
  3081                        
  Mon Feb  8 2021  9:20                                                                                                    Page 50


  3082                        LAB_1BF7
  3083 00:BB88: 20 84 BA           JSR   LAB_EVEZ          ; evaluate expression, no decrement
  3084                        
  3085                        ; all the 'scan for' routines return the character after the sought character
  3086                        
  3087                        ; scan for ")" , else do syntax error then warm start
  3088                        
  3089                        LAB_1BFB
  3090 00:BB8B: A9 29              LDA   #$29              ; load A with ")"
  3091                        
  3092                        ; scan for CHR$(A) , else do syntax error then warm start
  3093                        
  3094                        LAB_SCCA
  3095 00:BB8D: D2 6E              CMP   (Bpntrl)          ; check next byte is = A
  3096 00:BB8F: D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
  3097                        
  3098 00:BB91: 4C B5 CF           JMP   LAB_IGBY          ; increment and scan memory then return
  3099                        
  3100                        ; scan for "(" , else do syntax error then warm start
  3101                        
  3102                        LAB_1BFE
  3103 00:BB94: A9 28              LDA   #$28              ; load A with "("
  3104 00:BB96: 80 F5              BRA   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  3105                        
  3106                        ; scan for "," , else do syntax error then warm start
  3107                        
  3108                        LAB_1C01
  3109 00:BB98: A9 2C              LDA   #$2C              ; load A with ","
  3110 00:BB9A: 80 F1              BRA   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  3111                        
  3112                        ; syntax error then warm start
  3113                        
  3114                        LAB_SNER
  3115 00:BB9C: A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
  3116 00:BB9E: 4C 01 B1           JMP   LAB_XERR          ; do error #X, then warm start
  3117                        
  3118                        ; get value from line .. continued
  3119                        ; do tokens
  3120                        
  3121                        LAB_1BD0
  3122 00:BBA1: C9 B3              CMP   #TK_MINUS         ; compare with token for -
  3123 00:BBA3: F0 28              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
  3124                        
  3125                                                      ; wasn't -n so ..
  3126 00:BBA5: C9 B2              CMP   #TK_PLUS          ; compare with token for +
  3127 00:BBA7: F0 C0              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
  3128                        
  3129 00:BBA9: C9 AE              CMP   #TK_NOT           ; compare with token for NOT
  3130 00:BBAB: D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
  3131                        
  3132                                                      ; was NOT token
  3133             0000000B   TK_EQUAL_PLUS     .EQU TK_EQUAL-TK_PLUS
  3134 00:BBAD: A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
  3135 00:BBAF: 80 1E              BRA   LAB_1C13          ; do set-up for function then execute (branch always)
  3136                        
  3137                        ; do = compare
  3138                        
  3139                        LAB_EQUAL
  3140 00:BBB1: 20 46 BE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3141 00:BBB4: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  3142 00:BBB6: 49 FF              EOR   #$FF              ; invert it
  3143 00:BBB8: A8                 TAY                     ; copy it
  3144 00:BBB9: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  Mon Feb  8 2021  9:20                                                                                                    Page 51


  3145 00:BBBB: 49 FF              EOR   #$FF              ; invert it
  3146 00:BBBD: 4C F8 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3147                        
  3148                        ; get value from line .. continued
  3149                        
  3150                                                      ; wasn't +, -, or NOT so ..
  3151                        LAB_1BE7
  3152 00:BBC0: C9 AB              CMP   #TK_FN            ; compare with token for FN
  3153 00:BBC2: D0 03              BNE   LAB_1BEE          ; branch if not token for FN
  3154                        
  3155 00:BBC4: 4C 50 C0           JMP   LAB_201E          ; go evaluate FNx
  3156                        
  3157                        ; get value from line .. continued
  3158                        
  3159                                                      ; wasn't +, -, NOT or FN so ..
  3160                        LAB_1BEE
  3161 00:BBC7: E9 BF              SBC   #TK_SGN           ; subtract with token for SGN
  3162 00:BBC9: B0 26              BCS   LAB_1C27          ; if a function token go do it
  3163 00:BBCB: 80 CF              BRA   LAB_SNER          ; else do syntax error
  3164                        
  3165                        ; set-up for functions
  3166                        
  3167                        LAB_1C11
  3168             0000000A   TK_GT_PLUS  .EQU TK_GT-TK_PLUS
  3169 00:BBCD: A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
  3170                        LAB_1C13
  3171 00:BBCF: 68                 PLA                     ; dump return address low byte
  3172                        
  3173                                                      ; patch 2.22p5
  3174                        
  3175 00:BBD0: AA                 TAX                     ; save to trap concatenate
  3176 00:BBD1: 68                 PLA                     ; dump return address high byte
  3177 00:BBD2: E0 7A              CPX   #<LAB_224Da+2   ; from concatenate low return address?
  3178 00:BBD4: D0 04              BNE   LAB_1C13b         ; No - continue!
  3179 00:BBD6: C9 C2              CMP   #>LAB_224Da+2   ; from concatenate high return address?
  3180 00:BBD8: F0 03              BEQ   LAB_1C13a         ; Yes - error!
  3181                        LAB_1C13b
  3182 00:BBDA: 4C D2 BA           JMP   LAB_1B1D          ; execute function then continue evaluation
  3183                        LAB_1C13a
  3184 00:BBDD: 4C 77 BA           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start
  3185                        
  3186                        ;      PLA                     ; dump return address high byte
  3187                        ;      JMP   LAB_1B1D          ; execute function then continue evaluation
  3188                        
  3189                                                       ; patch 2.22p5
  3190                        
  3191                        ; variable name set-up
  3192                        ; get (var), return value in FAC_1 and $ flag
  3193                        
  3194                        LAB_1C18
  3195 00:BBE0: 20 4C BD           JSR   LAB_GVAR          ; get (var) address
  3196 00:BBE3: 85 60              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
  3197 00:BBE5: 84 61              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
  3198 00:BBE7: A6 11              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  3199 00:BBE9: 30 03              BMI   LAB_1C25          ; if string then return (does RTS)
  3200                        
  3201                        LAB_1C24
  3202 00:BBEB: 4C 02 C8           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
  3203                        
  3204                        LAB_1C25
  3205                        
  3206 00:BBEE: 46 6B              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
  3207 00:BBF0: 60                 RTS
  Mon Feb  8 2021  9:20                                                                                                    Page 52


  3208                        
  3209                        ; get value from line .. continued
  3210                        ; only functions left so ..
  3211                        
  3212                        ; set up function references
  3213                        
  3214                        ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
  3215                        ; to process function calls. now the function vector is computed and pushed on the stack
  3216                        ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
  3217                        ; is calculated and the routine called, if not this routine just does RTS. whichever
  3218                        ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
  3219                        ; the function code
  3220                        
  3221                        ; this also removes some less than elegant code that was used to bypass type checking
  3222                        ; for functions that returned strings
  3223                        
  3224                        LAB_1C27
  3225 00:BBF1: 0A                 ASL                     ; *2 (2 bytes per function address)
  3226 00:BBF2: A8                 TAY                     ; copy to index
  3227                        
  3228 00:BBF3: B9 2E D2           LDA   LAB_FTBM,Y        ; get function jump vector high byte
  3229 00:BBF6: 48                 PHA                     ; push functions jump vector high byte
  3230 00:BBF7: B9 2D D2           LDA   LAB_FTBL,Y        ; get function jump vector low byte
  3231 00:BBFA: 48                 PHA                     ; push functions jump vector low byte
  3232                        
  3233 00:BBFB: B9 E8 D1           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
  3234 00:BBFE: F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
  3235                        
  3236 00:BC00: 48                 PHA                     ; push functions pre process vector high byte
  3237 00:BC01: B9 E7 D1           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
  3238 00:BC04: 48                 PHA                     ; push functions pre process vector low byte
  3239                        
  3240                        LAB_1C56
  3241 00:BC05: 60                 RTS                     ; do function, or pre process, call
  3242                        
  3243                        ; process string expression in parenthesis
  3244                        
  3245                        LAB_PPFS
  3246 00:BC06: 20 88 BB           JSR   LAB_1BF7          ; process expression in parenthesis
  3247 00:BC09: 4C 6D BA           JMP   LAB_CTST          ; check if source is string then do function,
  3248                                                      ; else do type mismatch
  3249                        
  3250                        ; process numeric expression in parenthesis
  3251                        
  3252                        LAB_PPFN
  3253 00:BC0C: 20 88 BB           JSR   LAB_1BF7          ; process expression in parenthesis
  3254 00:BC0F: 4C 6A BA           JMP   LAB_CTNM          ; check if source is numeric then do function,
  3255                                                      ; else do type mismatch
  3256                        
  3257                        ; set numeric data type and increment BASIC execute pointer
  3258                        
  3259                        LAB_PPBI
  3260 00:BC12: 46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3261 00:BC14: 4C B5 CF           JMP   LAB_IGBY          ; increment and scan memory then do function
  3262                        
  3263                        ; process string for LEFT$, RIGHT$ or MID$
  3264                        
  3265                        LAB_LRMS
  3266 00:BC17: 20 84 BA           JSR   LAB_EVEZ          ; evaluate (should be string) expression
  3267 00:BC1A: 20 98 BB           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
  3268 00:BC1D: 20 6D BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  3269 00:BC20: FA                 PLX                     ; get function jump vector low byte
  3270 00:BC21: 7A                 PLY                     ; get function jump vector high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 53


  3271 00:BC22: A5 61              LDA   des_ph            ; get descriptor pointer high byte
  3272 00:BC24: 48                 PHA                     ; push string pointer high byte
  3273 00:BC25: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  3274 00:BC27: 48                 PHA                     ; push string pointer low byte
  3275 00:BC28: 5A                 PHY                     ; save function jump vector high byte
  3276 00:BC29: DA                 PHX                     ; save function jump vector low byte
  3277 00:BC2A: 20 21 C4           JSR   LAB_GTBY          ; get byte parameter
  3278 00:BC2D: 8A                 TXA                     ; copy byte parameter to A
  3279 00:BC2E: 60                 RTS                     ; go do function
  3280                        
  3281                        ; process numeric expression(s) for BIN$ or HEX$
  3282                        
  3283                        LAB_BHSS
  3284 00:BC2F: 20 84 BA           JSR   LAB_EVEZ          ; process expression
  3285 00:BC32: 20 6A BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  3286 00:BC35: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  3287 00:BC37: C9 98              CMP   #$98              ; compare with exponent = 2^24
  3288 00:BC39: B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
  3289                        
  3290 00:BC3B: 20 D0 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  3291 00:BC3E: A2 02              LDX   #$02              ; 3 bytes to do
  3292                        LAB_CFAC
  3293 00:BC40: B5 5F              LDA   FAC1_1,X          ; get byte from FAC1
  3294 00:BC42: 95 0A              STA   nums_1,X          ; save byte to temp
  3295 00:BC44: CA                 DEX                     ; decrement index
  3296 00:BC45: 10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
  3297                        
  3298 00:BC47: 20 BB CF           JSR   LAB_GBYT          ; get next BASIC byte
  3299 00:BC4A: A2 00              LDX   #$00              ; set default to no leading "0"s
  3300 00:BC4C: C9 29              CMP   #')'              ; compare with close bracket
  3301 00:BC4E: F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
  3302                        
  3303 00:BC50: 20 6B C4           JSR   LAB_SCGB          ; scan for "," and get byte
  3304 00:BC53: 20 BB CF           JSR   LAB_GBYT          ; get last byte back
  3305 00:BC56: C9 29              CMP   #')'              ; is next character )
  3306 00:BC58: D0 01              BNE   LAB_BHER          ; if not ")" go do error
  3307                        
  3308                        LAB_1C54
  3309 00:BC5A: 60                 RTS                     ; else do function
  3310                        
  3311                        LAB_BHER
  3312 00:BC5B: 4C C8 BE           JMP   LAB_FCER          ; do function call error then warm start
  3313                        
  3314                        ; perform EOR
  3315                        
  3316                        ; added operator format is the same as AND or OR, precedence is the same as OR
  3317                        
  3318                        ; this bit worked first time but it took a while to sort out the operator table
  3319                        ; pointers and offsets afterwards!
  3320                        
  3321                        LAB_EOR
  3322 00:BC5E: 20 85 BC           JSR   GetFirst          ; get first integer expression (no sign check)
  3323 00:BC61: 45 0D              EOR   XOAw_l            ; EOR with expression 1 low byte
  3324 00:BC63: A8                 TAY                     ; save in Y
  3325 00:BC64: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3326 00:BC66: 45 0E              EOR   XOAw_h            ; EOR with expression 1 high byte
  3327 00:BC68: 4C F8 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3328                        
  3329                        ; perform OR
  3330                        
  3331                        LAB_OR
  3332 00:BC6B: 20 85 BC           JSR   GetFirst          ; get first integer expression (no sign check)
  3333 00:BC6E: 05 0D              ORA   XOAw_l            ; OR with expression 1 low byte
  Mon Feb  8 2021  9:20                                                                                                    Page 54


  3334 00:BC70: A8                 TAY                     ; save in Y
  3335 00:BC71: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3336 00:BC73: 05 0E              ORA   XOAw_h            ; OR with expression 1 high byte
  3337 00:BC75: 4C F8 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3338                        
  3339                        ; perform AND
  3340                        
  3341                        LAB_AND
  3342 00:BC78: 20 85 BC           JSR   GetFirst          ; get first integer expression (no sign check)
  3343 00:BC7B: 25 0D              AND   XOAw_l            ; AND with expression 1 low byte
  3344 00:BC7D: A8                 TAY                     ; save in Y
  3345 00:BC7E: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3346 00:BC80: 25 0E              AND   XOAw_h            ; AND with expression 1 high byte
  3347 00:BC82: 4C F8 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3348                        
  3349                        ; get first value for OR, AND or EOR
  3350                        
  3351                        GetFirst
  3352 00:BC85: 20 46 BE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3353 00:BC88: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  3354 00:BC8A: 85 0E              STA   XOAw_h            ; save it
  3355 00:BC8C: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  3356 00:BC8E: 85 0D              STA   XOAw_l            ; save it
  3357 00:BC90: 20 4F C5           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
  3358 00:BC93: 20 46 BE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3359 00:BC96: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  3360                        LAB_1C95
  3361 00:BC98: 60                 RTS
  3362                        
  3363                        ; perform comparisons
  3364                        
  3365                        ; do < compare
  3366                        
  3367                        LAB_LTHAN
  3368 00:BC99: 20 6E BA           JSR   LAB_CKTM          ; type match check, set C for string
  3369 00:BC9C: B0 12              BCS   LAB_1CAE          ; branch if string
  3370                        
  3371                                                      ; do numeric < compare
  3372 00:BC9E: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  3373 00:BCA0: 09 7F              ORA   #$7F              ; set all non sign bits
  3374 00:BCA2: 25 66              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
  3375 00:BCA4: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  3376 00:BCA6: A9 65              LDA   #<FAC2_e          ; set pointer low byte to FAC2
  3377 00:BCA8: A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
  3378 00:BCAA: 20 98 C8           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
  3379 00:BCAD: AA                 TAX                     ; copy result
  3380 00:BCAE: 80 31              BRA   LAB_1CE1          ; go evaluate result
  3381                        
  3382                                                      ; do string < compare
  3383                        LAB_1CAE
  3384 00:BCB0: 46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3385 00:BCB2: C6 4D              DEC   comp_f            ; clear < bit in compare function flag
  3386 00:BCB4: 20 DA C2           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  3387                                                      ; space returns with A = length, X=pointer low byte,
  3388                                                      ; Y=pointer high byte
  3389 00:BCB7: 85 5E              STA   str_ln            ; save length
  3390 00:BCB9: 86 5F              STX   str_pl            ; save string pointer low byte
  3391 00:BCBB: 84 60              STY   str_ph            ; save string pointer high byte
  3392 00:BCBD: A5 67              LDA   FAC2_2            ; get descriptor pointer low byte
  3393 00:BCBF: A4 68              LDY   FAC2_3            ; get descriptor pointer high byte
  3394 00:BCC1: 20 DE C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  3395                                                      ; returns with A = length, X=pointer low byte,
  3396                                                      ; Y=pointer high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 55


  3397 00:BCC4: 86 67              STX   FAC2_2            ; save string pointer low byte
  3398 00:BCC6: 84 68              STY   FAC2_3            ; save string pointer high byte
  3399 00:BCC8: AA                 TAX                     ; copy length
  3400 00:BCC9: 38                 SEC                     ; set carry for subtract
  3401 00:BCCA: E5 5E              SBC   str_ln            ; subtract string 1 length
  3402 00:BCCC: F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
  3403                        
  3404 00:BCCE: A9 01              LDA   #$01              ; set str 1 length > string 2 length
  3405 00:BCD0: 90 04              BCC   LAB_1CD6          ; branch if so
  3406                        
  3407 00:BCD2: A6 5E              LDX   str_ln            ; get string 1 length
  3408 00:BCD4: A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
  3409                        LAB_1CD6
  3410 00:BCD6: 85 62              STA   FAC1_s            ; save length compare
  3411 00:BCD8: A0 FF              LDY   #$FF              ; set index
  3412 00:BCDA: E8                 INX                     ; adjust for loop
  3413                        LAB_1CDB
  3414 00:BCDB: C8                 INY                     ; increment index
  3415 00:BCDC: CA                 DEX                     ; decrement count
  3416 00:BCDD: D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
  3417                        
  3418 00:BCDF: A6 62              LDX   FAC1_s            ; get length compare back
  3419                        LAB_1CE1
  3420 00:BCE1: 30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
  3421                        
  3422 00:BCE3: 18                 CLC                     ; flag str 1 <= str 2
  3423 00:BCE4: 90 0C              BCC   LAB_1CF2          ; go evaluate result
  3424                        
  3425                        LAB_1CE6
  3426 00:BCE6: B1 67              LDA   (FAC2_2),Y        ; get string 2 byte
  3427 00:BCE8: D1 5F              CMP   (FAC1_1),Y        ; compare with string 1 byte
  3428 00:BCEA: F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
  3429                        
  3430 00:BCEC: A2 FF              LDX   #$FF              ; set str 1 < string 2
  3431 00:BCEE: B0 02              BCS   LAB_1CF2          ; branch if so
  3432                        
  3433 00:BCF0: A2 01              LDX   #$01              ; set str 1 > string 2
  3434                        LAB_1CF2
  3435 00:BCF2: E8                 INX                     ; x = 0, 1 or 2
  3436 00:BCF3: 8A                 TXA                     ; copy to A
  3437 00:BCF4: 2A                 ROL                     ; *2 (1, 2 or 4)
  3438 00:BCF5: 25 15              AND   Cflag             ; AND with comparison evaluation flag
  3439 00:BCF7: F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
  3440                        
  3441 00:BCF9: A9 FF              LDA   #$FF              ; else set result true
  3442                        LAB_1CFB
  3443 00:BCFB: 4C 7F C8           JMP   LAB_27DB          ; save A as integer byte and return
  3444                        
  3445                        LAB_1CFE
  3446 00:BCFE: 20 98 BB           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
  3447                        
  3448                        ; perform DIM
  3449                        
  3450                        LAB_DIM
  3451 00:BD01: AA                 TAX                     ; copy "DIM" flag to X
  3452 00:BD02: 20 51 BD           JSR   LAB_1D10          ; search for variable
  3453 00:BD05: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  3454 00:BD08: D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
  3455 00:BD0A: 60                 RTS
  3456                        
  3457                        ; perform << (left shift)
  3458                        
  3459                        LAB_LSHIFT
  Mon Feb  8 2021  9:20                                                                                                    Page 56


  3460 00:BD0B: 20 41 BD           JSR   GetPair           ; get integer expression and byte (no sign check)
  3461 00:BD0E: A5 60              LDA   FAC1_2            ; get expression high byte
  3462 00:BD10: A6 2A              LDX   TempB             ; get shift count
  3463 00:BD12: F0 22              BEQ   NoShift           ; branch if zero
  3464                        
  3465 00:BD14: E0 10              CPX   #$10              ; compare bit count with 16d
  3466 00:BD16: B0 23              BCS   TooBig            ; branch if >=
  3467                        
  3468                        Ls_loop
  3469 00:BD18: 06 61              ASL   FAC1_3            ; shift low byte
  3470 00:BD1A: 2A                 ROL                     ; shift high byte
  3471 00:BD1B: CA                 DEX                     ; decrement bit count
  3472 00:BD1C: D0 FA              BNE   Ls_loop           ; loop if shift not complete
  3473                        
  3474 00:BD1E: A4 61              LDY   FAC1_3            ; get expression low byte
  3475 00:BD20: 4C F8 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3476                        
  3477                        ; perform >> (right shift)
  3478                        
  3479                        LAB_RSHIFT
  3480 00:BD23: 20 41 BD           JSR   GetPair           ; get integer expression and byte (no sign check)
  3481 00:BD26: A5 60              LDA   FAC1_2            ; get expression high byte
  3482 00:BD28: A6 2A              LDX   TempB             ; get shift count
  3483 00:BD2A: F0 0A              BEQ   NoShift           ; branch if zero
  3484                        
  3485 00:BD2C: E0 10              CPX   #$10              ; compare bit count with 16d
  3486 00:BD2E: B0 0B              BCS   TooBig            ; branch if >=
  3487                        
  3488                        Rs_loop
  3489 00:BD30: 4A                 LSR                     ; shift high byte
  3490 00:BD31: 66 61              ROR   FAC1_3            ; shift low byte
  3491 00:BD33: CA                 DEX                     ; decrement bit count
  3492 00:BD34: D0 FA              BNE   Rs_loop           ; loop if shift not complete
  3493                        
  3494                        NoShift
  3495 00:BD36: A4 61              LDY   FAC1_3            ; get expression low byte
  3496 00:BD38: 4C F8 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3497                        
  3498                        TooBig
  3499 00:BD3B: A9 00              LDA   #$00              ; clear high byte
  3500 00:BD3D: A8                 TAY                     ; copy to low byte
  3501 00:BD3E: 4C F8 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3502                        
  3503                        GetPair
  3504 00:BD41: 20 24 C4           JSR   LAB_EVBY          ; evaluate byte expression, result in X
  3505 00:BD44: 86 2A              STX   TempB             ; save it
  3506 00:BD46: 20 4F C5           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
  3507 00:BD49: 4C 46 BE           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
  3508                        
  3509                        ; search for variable
  3510                        
  3511                        ; return pointer to variable in Cvaral/Cvarah
  3512                        
  3513                        LAB_GVAR
  3514 00:BD4C: A2 00              LDX   #$00              ; set DIM flag = $00
  3515 00:BD4E: 20 BB CF           JSR   LAB_GBYT          ; scan memory (1st character)
  3516                        LAB_1D10
  3517 00:BD51: 86 10              STX   Defdim            ; save DIM flag
  3518                        LAB_1D12
  3519 00:BD53: 85 45              STA   Varnm1            ; save 1st character
  3520 00:BD55: 29 7F              AND   #$7F              ; clear FN flag bit
  3521 00:BD57: 20 BE BD           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3522 00:BD5A: B0 03              BCS   LAB_1D1F          ; branch if ok
  Mon Feb  8 2021  9:20                                                                                                    Page 57


  3523                        
  3524 00:BD5C: 4C 9C BB           JMP   LAB_SNER          ; else syntax error then warm start
  3525                        
  3526                                                      ; was variable name so ..
  3527                        LAB_1D1F
  3528 00:BD5F: A2 00              LDX   #$00              ; set DIM flag = $00
  3529 00:BD61: 86 11              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3530 00:BD63: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
  3531 00:BD66: 90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
  3532                        
  3533                                                      ; 2nd character wasn't "0" to "9" so ..
  3534 00:BD68: 20 BE BD           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3535 00:BD6B: 90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
  3536                        
  3537                        LAB_1D2D
  3538 00:BD6D: AA                 TAX                     ; copy 2nd character
  3539                        
  3540                                                      ; ignore further (valid) characters in the variable name
  3541                        LAB_1D2E
  3542 00:BD6E: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
  3543 00:BD71: 90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
  3544                        
  3545 00:BD73: 20 BE BD           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3546 00:BD76: B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
  3547                        
  3548                                                      ; check if string variable
  3549                        LAB_1D38
  3550 00:BD78: C9 24              CMP   #'$'              ; compare with "$"
  3551 00:BD7A: D0 0B              BNE   LAB_1D47          ; branch if not string
  3552                        
  3553                        ; to introduce a new variable type (% suffix for integers say) then this branch
  3554                        ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
  3555                        
  3556                                                      ; type is string
  3557 00:BD7C: A9 FF              LDA   #$FF              ; set data type = string
  3558 00:BD7E: 85 11              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
  3559 00:BD80: 8A                 TXA                     ; get 2nd character back
  3560 00:BD81: 09 80              ORA   #$80              ; set top bit (indicate string var)
  3561 00:BD83: AA                 TAX                     ; copy back to 2nd character temp
  3562 00:BD84: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  3563                        
  3564                        ; after we have determined the variable type we need to come back here to determine
  3565                        ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
  3566                        
  3567                        LAB_1D47                      ; gets here with character after var name in A
  3568 00:BD87: 86 46              STX   Varnm2            ; save 2nd character
  3569 00:BD89: 05 13              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
  3570 00:BD8B: C9 28              CMP   #'('              ; compare with "("
  3571 00:BD8D: D0 03              BNE   LAB_1D53          ; branch if not "("
  3572 00:BD8F: 4C 58 BE           JMP   LAB_1E17          ; go find, or make, array
  3573                        
  3574                        ; either find or create var
  3575                        ; var name (1st two characters only!) is in Varnm1,Varnm2
  3576                        
  3577                                                      ; variable name wasn't var(... so look for plain var
  3578                        LAB_1D53
  3579 00:BD92: 64 13              STZ   Sufnxf            ; clear subscript/FNX flag
  3580 00:BD94: A5 2D              LDA   Svarl             ; get start of vars low byte
  3581 00:BD96: A6 2E              LDX   Svarh             ; get start of vars high byte
  3582 00:BD98: A0 00              LDY   #$00              ; clear index
  3583                        LAB_1D5D
  3584 00:BD9A: 86 5D              STX   Vrschh            ; save search address high byte
  3585                        LAB_1D5F
  Mon Feb  8 2021  9:20                                                                                                    Page 58


  3586 00:BD9C: 85 5C              STA   Vrschl            ; save search address low byte
  3587 00:BD9E: E4 30              CPX   Sarryh            ; compare high address with var space end
  3588 00:BDA0: D0 04              BNE   LAB_1D69          ; skip next compare if <>
  3589                        
  3590                                                      ; high addresses were = so compare low addresses
  3591 00:BDA2: C5 2F              CMP   Sarryl            ; compare low address with var space end
  3592 00:BDA4: F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
  3593                        
  3594                        LAB_1D69
  3595 00:BDA6: A5 45              LDA   Varnm1            ; get 1st character of var to find
  3596 00:BDA8: D1 5C              CMP   (Vrschl),Y        ; compare with variable name 1st character
  3597 00:BDAA: D0 08              BNE   LAB_1D77          ; branch if no match
  3598                        
  3599                                                      ; 1st characters match so compare 2nd characters
  3600 00:BDAC: A5 46              LDA   Varnm2            ; get 2nd character of var to find
  3601 00:BDAE: C8                 INY                     ; index to point to variable name 2nd character
  3602 00:BDAF: D1 5C              CMP   (Vrschl),Y        ; compare with variable name 2nd character
  3603 00:BDB1: F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
  3604                        
  3605 00:BDB3: 88                 DEY                     ; else decrement index (now = $00)
  3606                        LAB_1D77
  3607 00:BDB4: 18                 CLC                     ; clear carry for add
  3608 00:BDB5: A5 5C              LDA   Vrschl            ; get search address low byte
  3609 00:BDB7: 69 06              ADC   #$06              ; +6 (offset to next var name)
  3610 00:BDB9: 90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
  3611                        
  3612 00:BDBB: E8                 INX                     ; else increment high byte
  3613 00:BDBC: 80 DC              BRA   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
  3614                        
  3615                        ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
  3616                        
  3617                        LAB_CASC
  3618 00:BDBE: C9 61              CMP   #'a'              ; compare with "a"
  3619 00:BDC0: B0 0A              BCS   LAB_1D83          ; go check <"z"+1
  3620                        
  3621                        ; check byte, return C=0 if<"A" or >"Z"
  3622                        
  3623                        LAB_1D82
  3624 00:BDC2: C9 41              CMP   #'A'              ; compare with "A"
  3625 00:BDC4: 90 05              BCC   LAB_1D8A          ; exit if less
  3626                        
  3627                                                      ; carry is set
  3628 00:BDC6: E9 5B              SBC   #$5B              ; subtract "Z"+1
  3629 00:BDC8: 38                 SEC                     ; set carry
  3630 00:BDC9: E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
  3631                                                      ; carry clear if byte>$5A
  3632                        LAB_1D8A
  3633 00:BDCB: 60                 RTS
  3634                        
  3635                        LAB_1D83
  3636 00:BDCC: E9 7B              SBC   #$7B              ; subtract "z"+1
  3637 00:BDCE: 38                 SEC                     ; set carry
  3638 00:BDCF: E9 85              SBC   #$85              ; subtract $85 (restore byte)
  3639                                                      ; carry clear if byte>$7A
  3640 00:BDD1: 60                 RTS
  3641                        
  3642                                                      ; reached end of variable mem without match
  3643                                                      ; .. so create new variable
  3644                        LAB_1D8B
  3645 00:BDD2: 68                 PLA                     ; pop return address low byte
  3646 00:BDD3: 48                 PHA                     ; push return address low byte
  3647             0000BBE2   LAB_1C18p2  .EQU LAB_1C18+2
  3648 00:BDD4: C9 E2              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
  Mon Feb  8 2021  9:20                                                                                                    Page 59


  3649 00:BDD6: D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
  3650                        
  3651                        ; This will only drop through if the call was from LAB_1C18 and is only called
  3652                        ; from there if it is searching for a variable from the RHS of a LET a=b statement
  3653                        ; it prevents the creation of variables not assigned a value.
  3654                        
  3655                        ; value returned by this is either numeric zero (exponent byte is $00) or null string
  3656                        ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
  3657                        
  3658                        ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
  3659                        
  3660                        ; this is where you would put the undefined variable error call e.g.
  3661                        
  3662                        ;                             ; variable doesn't exist so flag error
  3663                        ;     LDX   #$24              ; error code $24 ("undefined variable" error)
  3664                        ;     JMP   LAB_XERR          ; do error #X then warm start
  3665                        
  3666                        ; the above code has been tested and works a treat! (it replaces the three code lines
  3667                        ; below)
  3668                        
  3669                                                      ; else return dummy null value
  3670 00:BDD8: A9 71              LDA   #<LAB_1D96        ; low byte point to $00,$00
  3671                                                      ; (uses part of misc constants table)
  3672 00:BDDA: A0 D1              LDY   #>LAB_1D96        ; high byte point to $00,$00
  3673 00:BDDC: 60                 RTS
  3674                        
  3675                                                      ; create new numeric variable
  3676                        LAB_1D98
  3677 00:BDDD: A5 2F              LDA   Sarryl            ; get var mem end low byte
  3678 00:BDDF: A4 30              LDY   Sarryh            ; get var mem end high byte
  3679 00:BDE1: 85 5C              STA   Ostrtl            ; save old block start low byte
  3680 00:BDE3: 84 5D              STY   Ostrth            ; save old block start high byte
  3681 00:BDE5: A5 31              LDA   Earryl            ; get array mem end low byte
  3682 00:BDE7: A4 32              LDY   Earryh            ; get array mem end high byte
  3683 00:BDE9: 85 58              STA   Obendl            ; save old block end low byte
  3684 00:BDEB: 84 59              STY   Obendh            ; save old block end high byte
  3685 00:BDED: 18                 CLC                     ; clear carry for add
  3686 00:BDEE: 69 06              ADC   #$06              ; +6 (space for one var)
  3687 00:BDF0: 90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
  3688                        
  3689 00:BDF2: C8                 INY                     ; else increment high byte
  3690                        LAB_1DAE
  3691 00:BDF3: 85 56              STA   Nbendl            ; set new block end low byte
  3692 00:BDF5: 84 57              STY   Nbendh            ; set new block end high byte
  3693 00:BDF7: 20 84 B0           JSR   LAB_11CF          ; open up space in memory
  3694 00:BDFA: A5 56              LDA   Nbendl            ; get new start low byte
  3695 00:BDFC: A4 57              LDY   Nbendh            ; get new start high byte (-$100)
  3696 00:BDFE: C8                 INY                     ; correct high byte
  3697 00:BDFF: 85 2F              STA   Sarryl            ; save new var mem end low byte
  3698 00:BE01: 84 30              STY   Sarryh            ; save new var mem end high byte
  3699 00:BE03: A0 00              LDY   #$00              ; clear index
  3700 00:BE05: A5 45              LDA   Varnm1            ; get var name 1st character
  3701 00:BE07: 91 5C              STA   (Vrschl),Y        ; save var name 1st character
  3702 00:BE09: C8                 INY                     ; increment index
  3703 00:BE0A: A5 46              LDA   Varnm2            ; get var name 2nd character
  3704 00:BE0C: 91 5C              STA   (Vrschl),Y        ; save var name 2nd character
  3705 00:BE0E: A9 00              LDA   #$00              ; clear A
  3706 00:BE10: C8                 INY                     ; increment index
  3707 00:BE11: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3708 00:BE13: C8                 INY                     ; increment index
  3709 00:BE14: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3710 00:BE16: C8                 INY                     ; increment index
  3711 00:BE17: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  Mon Feb  8 2021  9:20                                                                                                    Page 60


  3712 00:BE19: C8                 INY                     ; increment index
  3713 00:BE1A: 91 5C              STA   (Vrschl),Y        ; initialise var byte
  3714                        
  3715                                                      ; found a match for var ((Vrschl) = ptr)
  3716                        LAB_1DD7
  3717 00:BE1C: A5 5C              LDA   Vrschl            ; get var address low byte
  3718 00:BE1E: 18                 CLC                     ; clear carry for add
  3719 00:BE1F: 69 02              ADC   #$02              ; +2 (offset past var name bytes)
  3720 00:BE21: A4 5D              LDY   Vrschh            ; get var address high byte
  3721 00:BE23: 90 01              BCC   LAB_1DE1          ; branch if no overflow from add
  3722                        
  3723 00:BE25: C8                 INY                     ; else increment high byte
  3724                        LAB_1DE1
  3725 00:BE26: 85 47              STA   Cvaral            ; save current var address low byte
  3726 00:BE28: 84 48              STY   Cvarah            ; save current var address high byte
  3727 00:BE2A: 60                 RTS
  3728                        
  3729                        ; set-up array pointer (Adatal/h) to first element in array
  3730                        ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
  3731                        
  3732                        LAB_1DE6
  3733 00:BE2B: A5 0F              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
  3734 00:BE2D: 0A                 ASL                     ; *2 (also clears the carry !)
  3735 00:BE2E: 69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
  3736 00:BE30: 65 5C              ADC   Astrtl            ; add array start pointer low byte
  3737 00:BE32: A4 5D              LDY   Astrth            ; get array pointer high byte
  3738 00:BE34: 90 01              BCC   LAB_1DF2          ; branch if no overflow
  3739                        
  3740 00:BE36: C8                 INY                     ; else increment high byte
  3741                        LAB_1DF2
  3742 00:BE37: 85 56              STA   Adatal            ; save array data pointer low byte
  3743 00:BE39: 84 57              STY   Adatah            ; save array data pointer high byte
  3744 00:BE3B: 60                 RTS
  3745                        
  3746                        ; evaluate integer expression
  3747                        
  3748                        LAB_EVIN
  3749 00:BE3C: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  3750 00:BE3F: 20 67 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  3751                                                      ; else do type mismatch
  3752                        
  3753                        ; evaluate integer expression (no check)
  3754                        
  3755                        LAB_EVPI
  3756 00:BE42: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  3757 00:BE44: 30 0D              BMI   LAB_1E12          ; do function call error if -ve
  3758                        
  3759                        ; evaluate integer expression (no sign check)
  3760                        
  3761                        LAB_EVIR
  3762 00:BE46: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  3763 00:BE48: C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
  3764 00:BE4A: 90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
  3765                        
  3766 00:BE4C: A9 78              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
  3767 00:BE4E: A0 D1              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
  3768 00:BE50: 20 98 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  3769                        LAB_1E12
  3770 00:BE53: D0 73              BNE   LAB_FCER          ; if <> do function call error then warm start
  3771                        
  3772                        LAB_1E14
  3773 00:BE55: 4C D0 C8           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
  3774                        
  Mon Feb  8 2021  9:20                                                                                                    Page 61


  3775                        ; find or make array
  3776                        
  3777                        LAB_1E17
  3778 00:BE58: A5 10              LDA   Defdim            ; get DIM flag
  3779 00:BE5A: 48                 PHA                     ; push it
  3780 00:BE5B: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  3781 00:BE5D: 48                 PHA                     ; push it
  3782 00:BE5E: A0 00              LDY   #$00              ; clear dimensions count
  3783                        
  3784                        ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
  3785                        
  3786                        LAB_1E1F
  3787 00:BE60: 5A                 PHY                     ; save dimensions count
  3788 00:BE61: A5 46              LDA   Varnm2            ; get array name 2nd byte
  3789 00:BE63: 48                 PHA                     ; save it
  3790 00:BE64: A5 45              LDA   Varnm1            ; get array name 1st byte
  3791 00:BE66: 48                 PHA                     ; save it
  3792 00:BE67: 20 3C BE           JSR   LAB_EVIN          ; evaluate integer expression
  3793 00:BE6A: 68                 PLA                     ; pull array name 1st byte
  3794 00:BE6B: 85 45              STA   Varnm1            ; restore array name 1st byte
  3795 00:BE6D: 68                 PLA                     ; pull array name 2nd byte
  3796 00:BE6E: 85 46              STA   Varnm2            ; restore array name 2nd byte
  3797 00:BE70: 7A                 PLY                     ; restore dimensions count
  3798 00:BE71: BA                 TSX                     ; copy stack pointer
  3799 00:BE72: BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
  3800 00:BE75: 48                 PHA                     ; push it
  3801 00:BE76: BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
  3802 00:BE79: 48                 PHA                     ; push it
  3803 00:BE7A: A5 60              LDA   FAC1_2            ; get this dimension size high byte
  3804 00:BE7C: 9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
  3805 00:BE7F: A5 61              LDA   FAC1_3            ; get this dimension size low byte
  3806 00:BE81: 9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
  3807 00:BE84: C8                 INY                     ; increment dimensions count
  3808 00:BE85: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  3809 00:BE88: C9 2C              CMP   #','              ; compare with ","
  3810 00:BE8A: F0 D4              BEQ   LAB_1E1F          ; if found go do next dimension
  3811                        
  3812 00:BE8C: 84 0F              STY   Dimcnt            ; store dimensions count
  3813 00:BE8E: 20 8B BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  3814 00:BE91: 68                 PLA                     ; pull data type flag
  3815 00:BE92: 85 11              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
  3816 00:BE94: 68                 PLA                     ; pull DIM flag
  3817 00:BE95: 85 10              STA   Defdim            ; restore DIM flag
  3818 00:BE97: A6 2F              LDX   Sarryl            ; get array mem start low byte
  3819 00:BE99: A5 30              LDA   Sarryh            ; get array mem start high byte
  3820                        
  3821                        ; now check to see if we are at the end of array memory (we would be if there were
  3822                        ; no arrays).
  3823                        
  3824                        LAB_1E5C
  3825 00:BE9B: 86 5C              STX   Astrtl            ; save as array start pointer low byte
  3826 00:BE9D: 85 5D              STA   Astrth            ; save as array start pointer high byte
  3827 00:BE9F: C5 32              CMP   Earryh            ; compare with array mem end high byte
  3828 00:BEA1: D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
  3829                        
  3830 00:BEA3: E4 31              CPX   Earryl            ; else compare with array mem end low byte
  3831 00:BEA5: F0 3A              BEQ   LAB_1EA1          ; go build array if not found
  3832                        
  3833                                                      ; search for array
  3834                        LAB_1E68
  3835 00:BEA7: A0 00              LDY   #$00              ; clear index
  3836 00:BEA9: B1 5C              LDA   (Astrtl),Y        ; get array name first byte
  3837 00:BEAB: C8                 INY                     ; increment index to second name byte
  Mon Feb  8 2021  9:20                                                                                                    Page 62


  3838 00:BEAC: C5 45              CMP   Varnm1            ; compare with this array name first byte
  3839 00:BEAE: D0 06              BNE   LAB_1E77          ; branch if no match
  3840                        
  3841 00:BEB0: A5 46              LDA   Varnm2            ; else get this array name second byte
  3842 00:BEB2: D1 5C              CMP   (Astrtl),Y        ; compare with array name second byte
  3843 00:BEB4: F0 17              BEQ   LAB_1E8D          ; array found so branch
  3844                        
  3845                                                      ; no match
  3846                        LAB_1E77
  3847 00:BEB6: C8                 INY                     ; increment index
  3848 00:BEB7: B1 5C              LDA   (Astrtl),Y        ; get array size low byte
  3849 00:BEB9: 18                 CLC                     ; clear carry for add
  3850 00:BEBA: 65 5C              ADC   Astrtl            ; add array start pointer low byte
  3851 00:BEBC: AA                 TAX                     ; copy low byte to X
  3852 00:BEBD: C8                 INY                     ; increment index
  3853 00:BEBE: B1 5C              LDA   (Astrtl),Y        ; get array size high byte
  3854 00:BEC0: 65 5D              ADC   Astrth            ; add array mem pointer high byte
  3855 00:BEC2: 90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
  3856                        
  3857                        ; do array bounds error
  3858                        
  3859                        LAB_1E85
  3860 00:BEC4: A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
  3861 00:BEC6: 80 02              BRA   LAB_1E8A          ; branch around next instruction, saves on clock cycle
  3862                        
  3863                        ; do function call error
  3864                        
  3865                        LAB_FCER
  3866 00:BEC8: A2 08              LDX   #$08              ; error code $08 ("Function call" error)
  3867                        LAB_1E8A
  3868 00:BECA: 4C 01 B1           JMP   LAB_XERR          ; do error #X, then warm start
  3869                        
  3870                                                      ; found array, are we trying to dimension it?
  3871                        LAB_1E8D
  3872 00:BECD: A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
  3873 00:BECF: A5 10              LDA   Defdim            ; get DIM flag
  3874 00:BED1: D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
  3875                                                      ; start
  3876                        
  3877                        ; found the array and we're not dimensioning it so we must find an element in it
  3878                        
  3879 00:BED3: 20 2B BE           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
  3880                                                      ; (Astrtl,Astrth points to start of array)
  3881 00:BED6: A5 0F              LDA   Dimcnt            ; get dimensions count
  3882 00:BED8: A0 04              LDY   #$04              ; set index to array's # of dimensions
  3883 00:BEDA: D1 5C              CMP   (Astrtl),Y        ; compare with no of dimensions
  3884 00:BEDC: D0 E6              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
  3885                                                      ; dimensions" error here .. if we want a different
  3886                                                      ; error message
  3887                        
  3888 00:BEDE: 4C 64 BF           JMP   LAB_1F28          ; found array so go get element
  3889                                                      ; (could jump to LAB_1F28 as all LAB_1F24 does is take
  3890                                                      ; Dimcnt and save it at (Astrtl),Y which is already the
  3891                                                      ; same or we would have taken the BNE)
  3892                        
  3893                                                      ; array not found, so build it
  3894                        LAB_1EA1
  3895 00:BEE1: 20 2B BE           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
  3896                                                      ; (Astrtl,Astrth points to start of array)
  3897 00:BEE4: 20 D1 B0           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
  3898                                                      ; addr to check is in AY (low/high)
  3899 00:BEE7: A0 00              LDY   #$00              ; clear Y (don't need to clear A)
  3900 00:BEE9: 84 6D              STY   Aspth             ; clear array data size high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 63


  3901 00:BEEB: A5 45              LDA   Varnm1            ; get variable name 1st byte
  3902 00:BEED: 91 5C              STA   (Astrtl),Y        ; save array name 1st byte
  3903 00:BEEF: C8                 INY                     ; increment index
  3904 00:BEF0: A5 46              LDA   Varnm2            ; get variable name 2nd byte
  3905 00:BEF2: 91 5C              STA   (Astrtl),Y        ; save array name 2nd byte
  3906 00:BEF4: A5 0F              LDA   Dimcnt            ; get dimensions count
  3907 00:BEF6: A0 04              LDY   #$04              ; index to dimension count
  3908 00:BEF8: 84 6C              STY   Asptl             ; set array data size low byte (four bytes per element)
  3909 00:BEFA: 91 5C              STA   (Astrtl),Y        ; set array's dimensions count
  3910                        
  3911                                                      ; now calculate the size of the data space for the array
  3912 00:BEFC: 18                 CLC                     ; clear carry for add (clear on subsequent loops)
  3913                        LAB_1EC0
  3914 00:BEFD: A2 0B              LDX   #$0B              ; set default dimension value low byte
  3915 00:BEFF: A9 00              LDA   #$00              ; set default dimension value high byte
  3916 00:BF01: 24 10              BIT   Defdim            ; test default DIM flag
  3917 00:BF03: 50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
  3918                        
  3919 00:BF05: 68                 PLA                     ; else pull dimension value low byte
  3920 00:BF06: 69 01              ADC   #$01              ; +1 (allow for zeroeth element)
  3921 00:BF08: AA                 TAX                     ; copy low byte to X
  3922 00:BF09: 68                 PLA                     ; pull dimension value high byte
  3923 00:BF0A: 69 00              ADC   #$00              ; add carry from low byte
  3924                        
  3925                        LAB_1ED0
  3926 00:BF0C: C8                 INY                     ; index to dimension value high byte
  3927 00:BF0D: 91 5C              STA   (Astrtl),Y        ; save dimension value high byte
  3928 00:BF0F: C8                 INY                     ; index to dimension value high byte
  3929 00:BF10: 8A                 TXA                     ; get dimension value low byte
  3930 00:BF11: 91 5C              STA   (Astrtl),Y        ; save dimension value low byte
  3931 00:BF13: 20 B3 BF           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
  3932 00:BF16: 86 6C              STX   Asptl             ; save array data size low byte
  3933 00:BF18: 85 6D              STA   Aspth             ; save array data size high byte
  3934 00:BF1A: A4 23              LDY   ut1_pl            ; restore index (saved by subroutine)
  3935 00:BF1C: C6 0F              DEC   Dimcnt            ; decrement dimensions count
  3936 00:BF1E: D0 DD              BNE   LAB_1EC0          ; loop while not = 0
  3937                        
  3938 00:BF20: 65 57              ADC   Adatah            ; add size high byte to first element high byte
  3939                                                      ; (carry is always clear here)
  3940 00:BF22: B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  3941                        
  3942 00:BF24: 85 57              STA   Adatah            ; save end of array high byte
  3943 00:BF26: A8                 TAY                     ; copy end high byte to Y
  3944 00:BF27: 8A                 TXA                     ; get array size low byte
  3945 00:BF28: 65 56              ADC   Adatal            ; add array start low byte
  3946 00:BF2A: 90 03              BCC   LAB_1EF3          ; branch if no carry
  3947                        
  3948 00:BF2C: C8                 INY                     ; else increment end of array high byte
  3949 00:BF2D: F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
  3950                        
  3951                                                      ; set-up mostly complete, now zero the array
  3952                        LAB_1EF3
  3953 00:BF2F: 20 D1 B0           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
  3954                                                      ; addr to check is in AY (low/high)
  3955 00:BF32: 85 31              STA   Earryl            ; save array mem end low byte
  3956 00:BF34: 84 32              STY   Earryh            ; save array mem end high byte
  3957 00:BF36: A9 00              LDA   #$00              ; clear byte for array clear
  3958 00:BF38: E6 6D              INC   Aspth             ; increment array size high byte (now block count)
  3959 00:BF3A: A4 6C              LDY   Asptl             ; get array size low byte (now index to block)
  3960 00:BF3C: F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
  3961                        
  3962                        LAB_1F02
  3963 00:BF3E: 88                 DEY                     ; decrement index (do 0 to n-1)
  Mon Feb  8 2021  9:20                                                                                                    Page 64


  3964 00:BF3F: 91 56              STA   (Adatal),Y        ; zero byte
  3965 00:BF41: D0 FB              BNE   LAB_1F02          ; loop until this block done
  3966                        
  3967                        LAB_1F07
  3968 00:BF43: C6 57              DEC   Adatah            ; decrement array pointer high byte
  3969 00:BF45: C6 6D              DEC   Aspth             ; decrement block count high byte
  3970 00:BF47: D0 F5              BNE   LAB_1F02          ; loop until all blocks done
  3971                        
  3972 00:BF49: E6 57              INC   Adatah            ; correct for last loop
  3973 00:BF4B: 38                 SEC                     ; set carry for subtract
  3974 00:BF4C: A0 02              LDY   #$02              ; index to array size low byte
  3975 00:BF4E: A5 31              LDA   Earryl            ; get array mem end low byte
  3976 00:BF50: E5 5C              SBC   Astrtl            ; subtract array start low byte
  3977 00:BF52: 91 5C              STA   (Astrtl),Y        ; save array size low byte
  3978 00:BF54: C8                 INY                     ; index to array size high byte
  3979 00:BF55: A5 32              LDA   Earryh            ; get array mem end high byte
  3980 00:BF57: E5 5D              SBC   Astrth            ; subtract array start high byte
  3981 00:BF59: 91 5C              STA   (Astrtl),Y        ; save array size high byte
  3982 00:BF5B: A5 10              LDA   Defdim            ; get default DIM flag
  3983 00:BF5D: D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
  3984                        
  3985                                                      ; else, find element
  3986 00:BF5F: C8                 INY                     ; index to # of dimensions
  3987                        
  3988                        LAB_1F24
  3989 00:BF60: B1 5C              LDA   (Astrtl),Y        ; get array's dimension count
  3990 00:BF62: 85 0F              STA   Dimcnt            ; save it
  3991                        
  3992                        ; we have found, or built, the array. now we need to find the element
  3993                        
  3994                        LAB_1F28
  3995 00:BF64: A9 00              LDA   #$00              ; clear byte
  3996 00:BF66: 85 6C              STA   Asptl             ; clear array data pointer low byte
  3997                        LAB_1F2C
  3998 00:BF68: 85 6D              STA   Aspth             ; save array data pointer high byte
  3999 00:BF6A: C8                 INY                     ; increment index (point to array bound high byte)
  4000 00:BF6B: 68                 PLA                     ; pull array index low byte
  4001 00:BF6C: AA                 TAX                     ; copy to X
  4002 00:BF6D: 85 60              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
  4003 00:BF6F: 68                 PLA                     ; pull array index high byte
  4004 00:BF70: 85 61              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
  4005 00:BF72: D1 5C              CMP   (Astrtl),Y        ; compare with array bound high byte
  4006 00:BF74: 90 0E              BCC   LAB_1F48          ; branch if within bounds
  4007 00:BF76: D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
  4008                        
  4009                                                      ; else high byte was = so test low bytes
  4010 00:BF78: C8                 INY                     ; index to array bound low byte
  4011 00:BF79: 8A                 TXA                     ; get array index low byte
  4012 00:BF7A: D1 5C              CMP   (Astrtl),Y        ; compare with array bound low byte
  4013 00:BF7C: 90 07              BCC   LAB_1F49          ; branch if within bounds
  4014                        
  4015                        LAB_1F42
  4016 00:BF7E: 4C C4 BE           JMP   LAB_1E85          ; else do array bounds error
  4017                        
  4018                        LAB_1F45
  4019 00:BF81: 4C FF B0           JMP   LAB_OMER          ; do "Out of memory" error then warm start
  4020                        
  4021                        LAB_1F48
  4022 00:BF84: C8                 INY                     ; index to array bound low byte
  4023                        LAB_1F49
  4024 00:BF85: A5 6D              LDA   Aspth             ; get array data pointer high byte
  4025 00:BF87: 05 6C              ORA   Asptl             ; OR with array data pointer low byte
  4026 00:BF89: F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
  Mon Feb  8 2021  9:20                                                                                                    Page 65


  4027                        
  4028 00:BF8B: 20 B3 BF           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
  4029 00:BF8E: 8A                 TXA                     ; get result low byte
  4030 00:BF8F: 65 60              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
  4031 00:BF91: AA                 TAX                     ; save result low byte
  4032 00:BF92: 98                 TYA                     ; get result high byte
  4033 00:BF93: A4 23              LDY   ut1_pl            ; restore index
  4034                        LAB_1F5A
  4035 00:BF95: 65 61              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
  4036 00:BF97: 86 6C              STX   Asptl             ; save array data pointer low byte
  4037 00:BF99: C6 0F              DEC   Dimcnt            ; decrement dimensions count
  4038 00:BF9B: D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
  4039                        
  4040 00:BF9D: 06 6C              ASL   Asptl             ; array data pointer low byte * 2
  4041 00:BF9F: 2A                 ROL                     ; array data pointer high byte * 2
  4042 00:BFA0: 06 6C              ASL   Asptl             ; array data pointer low byte * 4
  4043 00:BFA2: 2A                 ROL                     ; array data pointer high byte * 4
  4044 00:BFA3: A8                 TAY                     ; copy high byte
  4045 00:BFA4: A5 6C              LDA   Asptl             ; get low byte
  4046 00:BFA6: 65 56              ADC   Adatal            ; add array data start pointer low byte
  4047 00:BFA8: 85 47              STA   Cvaral            ; save as current var address low byte
  4048 00:BFAA: 98                 TYA                     ; get high byte back
  4049 00:BFAB: 65 57              ADC   Adatah            ; add array data start pointer high byte
  4050 00:BFAD: 85 48              STA   Cvarah            ; save as current var address high byte
  4051 00:BFAF: A8                 TAY                     ; copy high byte to Y
  4052 00:BFB0: A5 47              LDA   Cvaral            ; get current var address low byte
  4053                        LAB_1F7B
  4054 00:BFB2: 60                 RTS
  4055                        
  4056                        ; does XY = (Astrtl),Y * (Asptl)
  4057                        
  4058                        LAB_1F7C
  4059 00:BFB3: 84 23              STY   ut1_pl            ; save index
  4060 00:BFB5: B1 5C              LDA   (Astrtl),Y        ; get dimension size low byte
  4061 00:BFB7: 85 28              STA   dims_l            ; save dimension size low byte
  4062 00:BFB9: 88                 DEY                     ; decrement index
  4063 00:BFBA: B1 5C              LDA   (Astrtl),Y        ; get dimension size high byte
  4064 00:BFBC: 85 29              STA   dims_h            ; save dimension size high byte
  4065                        
  4066 00:BFBE: A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
  4067 00:BFC0: 85 5A              STA   numbit            ; save bit count
  4068 00:BFC2: A2 00              LDX   #$00              ; clear result low byte
  4069 00:BFC4: A0 00              LDY   #$00              ; clear result high byte
  4070                        LAB_1F8F
  4071 00:BFC6: 8A                 TXA                     ; get result low byte
  4072 00:BFC7: 0A                 ASL                     ; *2
  4073 00:BFC8: AA                 TAX                     ; save result low byte
  4074 00:BFC9: 98                 TYA                     ; get result high byte
  4075 00:BFCA: 2A                 ROL                     ; *2
  4076 00:BFCB: A8                 TAY                     ; save result high byte
  4077 00:BFCC: B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  4078                        
  4079 00:BFCE: 06 6C              ASL   Asptl             ; shift multiplier low byte
  4080 00:BFD0: 26 6D              ROL   Aspth             ; shift multiplier high byte
  4081 00:BFD2: 90 0B              BCC   LAB_1FA8          ; skip add if no carry
  4082                        
  4083 00:BFD4: 18                 CLC                     ; else clear carry for add
  4084 00:BFD5: 8A                 TXA                     ; get result low byte
  4085 00:BFD6: 65 28              ADC   dims_l            ; add dimension size low byte
  4086 00:BFD8: AA                 TAX                     ; save result low byte
  4087 00:BFD9: 98                 TYA                     ; get result high byte
  4088 00:BFDA: 65 29              ADC   dims_h            ; add dimension size high byte
  4089 00:BFDC: A8                 TAY                     ; save result high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 66


  4090 00:BFDD: B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  4091                        
  4092                        LAB_1FA8
  4093 00:BFDF: C6 5A              DEC   numbit            ; decrement bit count
  4094 00:BFE1: D0 E3              BNE   LAB_1F8F          ; loop until all done
  4095 00:BFE3: 60                 RTS
  4096                        
  4097                        ; perform FRE()
  4098                        
  4099                        LAB_FRE
  4100 00:BFE4: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  4101 00:BFE6: 10 03              BPL   LAB_1FB4          ; branch if numeric
  4102                        
  4103 00:BFE8: 20 DA C2           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  4104                                                      ; space returns with A = length, X=$71=pointer low byte,
  4105                                                      ; Y=$72=pointer high byte
  4106                        
  4107                                                      ; FRE(n) was numeric so do this
  4108                        LAB_1FB4
  4109 00:BFEB: 20 7B C1           JSR   LAB_GARB          ; go do garbage collection
  4110 00:BFEE: 38                 SEC                     ; set carry for subtract
  4111 00:BFEF: A5 33              LDA   Sstorl            ; get bottom of string space low byte
  4112 00:BFF1: E5 31              SBC   Earryl            ; subtract array mem end low byte
  4113 00:BFF3: A8                 TAY                     ; copy result to Y
  4114 00:BFF4: A5 34              LDA   Sstorh            ; get bottom of string space high byte
  4115 00:BFF6: E5 32              SBC   Earryh            ; subtract array mem end high byte
  4116                        
  4117                        ; save and convert integer AY to FAC1
  4118                        
  4119                        LAB_AYFC
  4120 00:BFF8: 46 11              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  4121 00:BFFA: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  4122 00:BFFC: 84 60              STY   FAC1_2            ; save FAC1 mantissa2
  4123 00:BFFE: A2 90              LDX   #$90              ; set exponent=2^16 (integer)
  4124 00:C000: 4C 85 C8           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
  4125                        
  4126                        ; perform POS()
  4127                        
  4128                        LAB_POS
  4129 00:C003: A4 07              LDY   TPos              ; get terminal position
  4130                        
  4131                        ; convert Y to byte in FAC1
  4132                        
  4133                        LAB_1FD0
  4134 00:C005: A9 00              LDA   #$00              ; clear high byte
  4135 00:C007: 80 EF              BRA   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
  4136                        
  4137                        ; check not Direct (used by DEF and INPUT)
  4138                        
  4139                        LAB_CKRN
  4140 00:C009: A6 3A              LDX   Clineh            ; get current line high byte
  4141 00:C00B: E8                 INX                     ; increment it
  4142 00:C00C: D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
  4143                        
  4144                                                      ; else do illegal direct error
  4145                        LAB_1FD9
  4146 00:C00E: A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
  4147                        LAB_1FDB
  4148 00:C010: 4C 01 B1           JMP   LAB_XERR          ; go do error #X, then warm start
  4149                        
  4150                        ; perform DEF
  4151                        
  4152                        LAB_DEF
  Mon Feb  8 2021  9:20                                                                                                    Page 67


  4153 00:C013: 20 41 C0           JSR   LAB_200B          ; check FNx syntax
  4154 00:C016: 85 4E              STA   func_l            ; save function pointer low byte
  4155 00:C018: 84 4F              STY   func_h            ; save function pointer high byte
  4156 00:C01A: 20 09 C0           JSR   LAB_CKRN          ; check not Direct (back here if ok)
  4157 00:C01D: 20 94 BB           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
  4158 00:C020: F7 13              SMB7  Sufnxf            ; set subscript/FNx flag
  4159                        ;      LDA   #$80              ; set flag for FNx
  4160                        ;      STA   Sufnxf            ; save subscript/FNx flag
  4161 00:C022: 20 4C BD           JSR   LAB_GVAR          ; get (var) address
  4162 00:C025: 20 6A BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4163 00:C028: 20 8B BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  4164 00:C02B: A9 BD              LDA   #TK_EQUAL         ; get = token
  4165 00:C02D: 20 8D BB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  4166 00:C030: A5 48              LDA   Cvarah            ; get current var address high byte
  4167 00:C032: 48                 PHA                     ; push it
  4168 00:C033: A5 47              LDA   Cvaral            ; get current var address low byte
  4169 00:C035: 48                 PHA                     ; push it
  4170 00:C036: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  4171 00:C038: 48                 PHA                     ; push it
  4172 00:C039: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  4173 00:C03B: 48                 PHA                     ; push it
  4174 00:C03C: 20 43 B6           JSR   LAB_DATA          ; go perform DATA
  4175 00:C03F: 80 6E              BRA   LAB_207A          ; put execute pointer and variable pointer into function
  4176                                                      ; and return
  4177                        
  4178                        ; check FNx syntax
  4179                        
  4180                        LAB_200B
  4181 00:C041: A9 AB              LDA   #TK_FN            ; get FN" token
  4182 00:C043: 20 8D BB           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
  4183                                                      ; return character after A
  4184 00:C046: 09 80              ORA   #$80              ; set FN flag bit
  4185 00:C048: 85 13              STA   Sufnxf            ; save FN flag so array variable test fails
  4186 00:C04A: 20 53 BD           JSR   LAB_1D12          ; search for FN variable
  4187 00:C04D: 4C 6A BA           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
  4188                                                      ; mismatch
  4189                        
  4190                                                      ; Evaluate FNx
  4191                        LAB_201E
  4192 00:C050: 20 41 C0           JSR   LAB_200B          ; check FNx syntax
  4193 00:C053: 48                 PHA                     ; push function pointer low byte
  4194 00:C054: 5A                 PHY                     ; push function pointer high byte
  4195 00:C055: 20 94 BB           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
  4196 00:C058: 20 7C BA           JSR   LAB_EVEX          ; evaluate expression
  4197 00:C05B: 20 8B BB           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  4198 00:C05E: 20 6A BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4199 00:C061: 68                 PLA                     ; pop function pointer high byte
  4200 00:C062: 85 4F              STA   func_h            ; restore it
  4201 00:C064: 68                 PLA                     ; pop function pointer low byte
  4202 00:C065: 85 4E              STA   func_l            ; restore it
  4203 00:C067: A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
  4204 00:C069: A0 03              LDY   #$03              ; index to variable pointer high byte
  4205 00:C06B: B1 4E              LDA   (func_l),Y        ; get variable pointer high byte
  4206 00:C06D: F0 A1              BEQ   LAB_1FDB          ; if zero go do undefined function error
  4207                        
  4208 00:C06F: 85 48              STA   Cvarah            ; save variable address high byte
  4209 00:C071: 88                 DEY                     ; index to variable address low byte
  4210 00:C072: B1 4E              LDA   (func_l),Y        ; get variable address low byte
  4211 00:C074: 85 47              STA   Cvaral            ; save variable address low byte
  4212 00:C076: AA                 TAX                     ; copy address low byte
  4213                        
  4214                                                      ; now stack the function variable value before use
  4215 00:C077: C8                 INY                     ; index to mantissa_3
  Mon Feb  8 2021  9:20                                                                                                    Page 68


  4216                        LAB_2043
  4217 00:C078: B1 47              LDA   (Cvaral),Y        ; get byte from variable
  4218 00:C07A: 48                 PHA                     ; stack it
  4219 00:C07B: 88                 DEY                     ; decrement index
  4220 00:C07C: 10 FA              BPL   LAB_2043          ; loop until variable stacked
  4221                        
  4222 00:C07E: A4 48              LDY   Cvarah            ; get variable address high byte
  4223 00:C080: 20 2C C8           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
  4224                                                      ; (function variable), return Y=0, always
  4225 00:C083: A5 6F              LDA   Bpntrh            ; get BASIC execute pointer high byte
  4226 00:C085: 48                 PHA                     ; push it
  4227 00:C086: A5 6E              LDA   Bpntrl            ; get BASIC execute pointer low byte
  4228 00:C088: 48                 PHA                     ; push it
  4229 00:C089: B1 4E              LDA   (func_l),Y        ; get function execute pointer low byte
  4230 00:C08B: 85 6E              STA   Bpntrl            ; save as BASIC execute pointer low byte
  4231 00:C08D: C8                 INY                     ; index to high byte
  4232 00:C08E: B1 4E              LDA   (func_l),Y        ; get function execute pointer high byte
  4233 00:C090: 85 6F              STA   Bpntrh            ; save as BASIC execute pointer high byte
  4234 00:C092: A5 48              LDA   Cvarah            ; get variable address high byte
  4235 00:C094: 48                 PHA                     ; push it
  4236 00:C095: A5 47              LDA   Cvaral            ; get variable address low byte
  4237 00:C097: 48                 PHA                     ; push it
  4238 00:C098: 20 67 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  4239                                                      ; else do type mismatch
  4240 00:C09B: 68                 PLA                     ; pull variable address low byte
  4241 00:C09C: 85 4E              STA   func_l            ; save variable address low byte
  4242 00:C09E: 68                 PLA                     ; pull variable address high byte
  4243 00:C09F: 85 4F              STA   func_h            ; save variable address high byte
  4244 00:C0A1: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  4245 00:C0A4: F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
  4246 00:C0A6: 4C 9C BB           JMP   LAB_SNER          ; else syntax error then warm start
  4247                        
  4248                        ; restore Bpntrl,Bpntrh and function variable from stack
  4249                        
  4250                        LAB_2074
  4251 00:C0A9: 68                 PLA                     ; pull BASIC execute pointer low byte
  4252 00:C0AA: 85 6E              STA   Bpntrl            ; restore BASIC execute pointer low byte
  4253 00:C0AC: 68                 PLA                     ; pull BASIC execute pointer high byte
  4254 00:C0AD: 85 6F              STA   Bpntrh            ; restore BASIC execute pointer high byte
  4255                        
  4256                        ; put execute pointer and variable pointer into function
  4257                        
  4258                        LAB_207A
  4259 00:C0AF: A0 00              LDY   #$00              ; clear index
  4260 00:C0B1: 68                 PLA                     ; pull BASIC execute pointer low byte
  4261 00:C0B2: 91 4E              STA   (func_l),Y        ; save to function
  4262 00:C0B4: C8                 INY                     ; increment index
  4263 00:C0B5: 68                 PLA                     ; pull BASIC execute pointer high byte
  4264 00:C0B6: 91 4E              STA   (func_l),Y        ; save to function
  4265 00:C0B8: C8                 INY                     ; increment index
  4266 00:C0B9: 68                 PLA                     ; pull current var address low byte
  4267 00:C0BA: 91 4E              STA   (func_l),Y        ; save to function
  4268 00:C0BC: C8                 INY                     ; increment index
  4269 00:C0BD: 68                 PLA                     ; pull current var address high byte
  4270 00:C0BE: 91 4E              STA   (func_l),Y        ; save to function
  4271 00:C0C0: 60                 RTS
  4272                        
  4273                        ; perform STR$()
  4274                        
  4275                        LAB_STRS
  4276 00:C0C1: 20 6A BA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4277 00:C0C4: 20 0E CA           JSR   LAB_296E          ; convert FAC1 to string
  4278 00:C0C7: A9 75              LDA   #<Decssp1         ; set result string low pointer
  Mon Feb  8 2021  9:20                                                                                                    Page 69


  4279 00:C0C9: A0 00              LDY   #>Decssp1         ; set result string high pointer
  4280 00:C0CB: F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
  4281                        
  4282                        ; Do string vector
  4283                        ; copy des_pl/h to des_2l/h and make string space A bytes long
  4284                        
  4285                        LAB_209C
  4286 00:C0CD: A6 60              LDX   des_pl            ; get descriptor pointer low byte
  4287 00:C0CF: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  4288 00:C0D1: 86 50              STX   des_2l            ; save descriptor pointer low byte
  4289 00:C0D3: 84 51              STY   des_2h            ; save descriptor pointer high byte
  4290                        
  4291                        ; make string space A bytes long
  4292                        ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4293                        
  4294                        LAB_MSSP
  4295 00:C0D5: 20 49 C1           JSR   LAB_2115          ; make space in string memory for string A long
  4296                                                      ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4297 00:C0D8: 86 5F              STX   str_pl            ; save string pointer low byte
  4298 00:C0DA: 84 60              STY   str_ph            ; save string pointer high byte
  4299 00:C0DC: 85 5E              STA   str_ln            ; save length
  4300 00:C0DE: 60                 RTS
  4301                        
  4302                        ; Scan, set up string
  4303                        ; print " terminated string to Sutill/Sutilh
  4304                        
  4305                        LAB_20AE
  4306 00:C0DF: A2 22              LDX   #$22              ; set terminator to "
  4307 00:C0E1: 86 0D              STX   Srchc             ; set search character (terminator 1)
  4308 00:C0E3: 86 0E              STX   Asrch             ; set terminator 2
  4309                        
  4310                        ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
  4311                        ; source is AY
  4312                        
  4313                        LAB_20B4
  4314 00:C0E5: 85 6A              STA   ssptr_l           ; store string start low byte
  4315 00:C0E7: 84 6B              STY   ssptr_h           ; store string start high byte
  4316 00:C0E9: 85 5F              STA   str_pl            ; save string pointer low byte
  4317 00:C0EB: 84 60              STY   str_ph            ; save string pointer high byte
  4318 00:C0ED: A0 FF              LDY   #$FF              ; set length to -1
  4319                        LAB_20BE
  4320 00:C0EF: C8                 INY                     ; increment length
  4321 00:C0F0: B1 6A              LDA   (ssptr_l),Y       ; get byte from string
  4322 00:C0F2: F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
  4323                        
  4324 00:C0F4: C5 0D              CMP   Srchc             ; compare with search character (terminator 1)
  4325 00:C0F6: F0 04              BEQ   LAB_20CB          ; branch if terminator
  4326                        
  4327 00:C0F8: C5 0E              CMP   Asrch             ; compare with terminator 2
  4328 00:C0FA: D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
  4329                        
  4330                        LAB_20CB
  4331 00:C0FC: C9 22              CMP   #$22              ; compare with "
  4332 00:C0FE: F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
  4333                        
  4334                        LAB_20CF
  4335 00:C100: 18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
  4336                        LAB_20D0
  4337 00:C101: 84 5E              STY   str_ln            ; save length in FAC1 exponent
  4338 00:C103: 98                 TYA                     ; copy length to A
  4339 00:C104: 65 6A              ADC   ssptr_l           ; add string start low byte
  4340 00:C106: 85 6C              STA   Sendl             ; save string end low byte
  4341 00:C108: A6 6B              LDX   ssptr_h           ; get string start high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 70


  4342 00:C10A: 90 01              BCC   LAB_20DC          ; branch if no low byte overflow
  4343                        
  4344 00:C10C: E8                 INX                     ; else increment high byte
  4345                        LAB_20DC
  4346 00:C10D: 86 6D              STX   Sendh             ; save string end high byte
  4347 00:C10F: A5 6B              LDA   ssptr_h           ; get string start high byte
  4348 00:C111: F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
  4349 00:C113: C9 05              CMP   #>Ibuffs          ; compare with location of input buffer page
  4350 00:C115: D0 0B              BNE   LAB_RTST          ; branch if not in utility area
  4351                        
  4352                        LAB_MVST
  4353                                                      ; string in utility area, move to string memory
  4354 00:C117: 98                 TYA                     ; copy length to A
  4355 00:C118: 20 CD C0           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
  4356                                                      ; long
  4357 00:C11B: A6 6A              LDX   ssptr_l           ; get string start low byte
  4358 00:C11D: A4 6B              LDY   ssptr_h           ; get string start high byte
  4359 00:C11F: 20 BB C2           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
  4360                        
  4361                        ; check for space on descriptor stack then ..
  4362                        ; put string address and length on descriptor stack and update stack pointers
  4363                        
  4364                        LAB_RTST
  4365 00:C122: A6 17              LDX   next_s            ; get string stack pointer
  4366 00:C124: E0 23              CPX   #des_sk+$09       ; compare with max+1
  4367 00:C126: D0 05              BNE   LAB_20F8          ; branch if space on string stack
  4368                        
  4369                                                      ; else do string too complex error
  4370 00:C128: A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
  4371                        LAB_20F5
  4372 00:C12A: 4C 01 B1           JMP   LAB_XERR          ; do error #X, then warm start
  4373                        
  4374                        ; put string address and length on descriptor stack and update stack pointers
  4375                        
  4376                        LAB_20F8
  4377 00:C12D: A5 5E              LDA   str_ln            ; get string length
  4378 00:C12F: 95 00              STA   PLUS_0,X          ; put on string stack
  4379 00:C131: A5 5F              LDA   str_pl            ; get string pointer low byte
  4380 00:C133: 95 01              STA   PLUS_1,X          ; put on string stack
  4381 00:C135: A5 60              LDA   str_ph            ; get string pointer high byte
  4382 00:C137: 95 02              STA   PLUS_2,X          ; put on string stack
  4383 00:C139: 86 60              STX   des_pl            ; save string descriptor pointer low byte
  4384 00:C13B: 64 61              STZ   des_ph            ; save string descriptor pointer high byte (always $00)
  4385 00:C13D: A0 FF              LDY   #$FF              ; Y = $FF
  4386 00:C13F: 84 11              STY   Dtypef            ; save data type flag, $FF=string
  4387 00:C141: 86 18              STX   last_sl           ; save old stack pointer (current top item)
  4388 00:C143: E8                 INX                     ; update stack pointer
  4389 00:C144: E8                 INX                     ; update stack pointer
  4390 00:C145: E8                 INX                     ; update stack pointer
  4391 00:C146: 86 17              STX   next_s            ; save new top item value
  4392 00:C148: 60                 RTS
  4393                        
  4394                        ; Build descriptor
  4395                        ; make space in string memory for string A long
  4396                        ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
  4397                        
  4398                        LAB_2115
  4399 00:C149: 46 12              LSR   Gclctd            ; clear garbage collected flag (b7)
  4400                        
  4401                                                      ; make space for string A long
  4402                        LAB_2117
  4403 00:C14B: 48                 PHA                     ; save string length
  4404 00:C14C: 49 FF              EOR   #$FF              ; complement it
  Mon Feb  8 2021  9:20                                                                                                    Page 71


  4405 00:C14E: 38                 SEC                     ; set carry for subtract (twos comp add)
  4406 00:C14F: 65 33              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
  4407 00:C151: A4 34              LDY   Sstorh            ; get bottom of string space high byte
  4408 00:C153: B0 01              BCS   LAB_2122          ; skip decrement if no underflow
  4409                        
  4410 00:C155: 88                 DEY                     ; decrement bottom of string space high byte
  4411                        LAB_2122
  4412 00:C156: C4 32              CPY   Earryh            ; compare with array mem end high byte
  4413 00:C158: 90 11              BCC   LAB_2137          ; do out of memory error if less
  4414                        
  4415 00:C15A: D0 04              BNE   LAB_212C          ; if not = skip next test
  4416                        
  4417 00:C15C: C5 31              CMP   Earryl            ; compare with array mem end low byte
  4418 00:C15E: 90 0B              BCC   LAB_2137          ; do out of memory error if less
  4419                        
  4420                        LAB_212C
  4421 00:C160: 85 33              STA   Sstorl            ; save bottom of string space low byte
  4422 00:C162: 84 34              STY   Sstorh            ; save bottom of string space high byte
  4423 00:C164: 85 35              STA   Sutill            ; save string utility ptr low byte
  4424 00:C166: 84 36              STY   Sutilh            ; save string utility ptr high byte
  4425 00:C168: AA                 TAX                     ; copy low byte to X
  4426 00:C169: 68                 PLA                     ; get string length back
  4427 00:C16A: 60                 RTS
  4428                        
  4429                        LAB_2137
  4430 00:C16B: A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
  4431 00:C16D: A5 12              LDA   Gclctd            ; get garbage collected flag
  4432 00:C16F: 30 B9              BMI   LAB_20F5          ; if set then do error code X
  4433                        
  4434 00:C171: 20 7B C1           JSR   LAB_GARB          ; else go do garbage collection
  4435 00:C174: A9 80              LDA   #$80              ; flag for garbage collected
  4436 00:C176: 85 12              STA   Gclctd            ; set garbage collected flag
  4437 00:C178: 68                 PLA                     ; pull length
  4438 00:C179: 80 D0              BRA   LAB_2117          ; go try again (loop always, length should never be = $00)
  4439                        
  4440                        ; garbage collection routine
  4441                        
  4442                        LAB_GARB
  4443 00:C17B: A6 37              LDX   Ememl             ; get end of mem low byte
  4444 00:C17D: A5 38              LDA   Ememh             ; get end of mem high byte
  4445                        
  4446                        ; re-run routine from last ending
  4447                        
  4448                        LAB_214B
  4449 00:C17F: 86 33              STX   Sstorl            ; set string storage low byte
  4450 00:C181: 85 34              STA   Sstorh            ; set string storage high byte
  4451 00:C183: 64 4F              STZ   garb_h            ; clear working pointer high byte (flag no strings to move)
  4452                                                      ; patch 2.22p5
  4453 00:C185: 64 4E              STZ   garb_l            ; clear working pointer low byte (flag no strings to move)
  4454                        
  4455 00:C187: A5 31              LDA   Earryl            ; get array mem end low byte
  4456 00:C189: A6 32              LDX   Earryh            ; get array mem end high byte
  4457 00:C18B: 85 5C              STA   Histrl            ; save as highest string low byte
  4458 00:C18D: 86 5D              STX   Histrh            ; save as highest string high byte
  4459 00:C18F: A9 1A              LDA   #des_sk           ; set descriptor stack pointer
  4460 00:C191: 85 23              STA   ut1_pl            ; save descriptor stack pointer low byte
  4461 00:C193: 64 24              STZ   ut1_ph            ; save descriptor stack pointer high byte ($00)
  4462                        LAB_2161
  4463 00:C195: C5 17              CMP   next_s            ; compare with descriptor stack pointer
  4464 00:C197: F0 05              BEQ   LAB_216A          ; branch if =
  4465                        
  4466 00:C199: 20 FF C1           JSR   LAB_21D7          ; go garbage collect descriptor stack
  4467 00:C19C: 80 F7              BRA   LAB_2161          ; loop always
  Mon Feb  8 2021  9:20                                                                                                    Page 72


  4468                        
  4469                                                      ; done stacked strings, now do string vars
  4470                        LAB_216A
  4471 00:C19E: 06 52              ASL   g_step            ; set step size = $06
  4472 00:C1A0: A5 2D              LDA   Svarl             ; get start of vars low byte
  4473 00:C1A2: A6 2E              LDX   Svarh             ; get start of vars high byte
  4474 00:C1A4: 85 23              STA   ut1_pl            ; save as pointer low byte
  4475 00:C1A6: 86 24              STX   ut1_ph            ; save as pointer high byte
  4476                        LAB_2176
  4477 00:C1A8: E4 30              CPX   Sarryh            ; compare start of arrays high byte
  4478 00:C1AA: D0 04              BNE   LAB_217E          ; branch if no high byte match
  4479                        
  4480 00:C1AC: C5 2F              CMP   Sarryl            ; else compare start of arrays low byte
  4481 00:C1AE: F0 05              BEQ   LAB_2183          ; branch if = var mem end
  4482                        
  4483                        LAB_217E
  4484 00:C1B0: 20 F9 C1           JSR   LAB_21D1          ; go garbage collect strings
  4485 00:C1B3: 80 F3              BRA   LAB_2176          ; loop always
  4486                        
  4487                                                      ; done string vars, now do string arrays
  4488                        LAB_2183
  4489 00:C1B5: 85 56              STA   Nbendl            ; save start of arrays low byte as working pointer
  4490 00:C1B7: 86 57              STX   Nbendh            ; save start of arrays high byte as working pointer
  4491 00:C1B9: A9 04              LDA   #$04              ; set step size
  4492 00:C1BB: 85 52              STA   g_step            ; save step size
  4493                        LAB_218B
  4494 00:C1BD: A5 56              LDA   Nbendl            ; get pointer low byte
  4495 00:C1BF: A6 57              LDX   Nbendh            ; get pointer high byte
  4496                        LAB_218F
  4497 00:C1C1: E4 32              CPX   Earryh            ; compare with array mem end high byte
  4498 00:C1C3: D0 04              BNE   LAB_219A          ; branch if not at end
  4499                        
  4500 00:C1C5: C5 31              CMP   Earryl            ; else compare with array mem end low byte
  4501 00:C1C7: F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
  4502                        
  4503                        LAB_219A
  4504 00:C1C9: 85 23              STA   ut1_pl            ; save pointer low byte
  4505 00:C1CB: 86 24              STX   ut1_ph            ; save pointer high byte
  4506 00:C1CD: A0 02              LDY   #$02              ; set index
  4507 00:C1CF: B1 23              LDA   (ut1_pl),Y        ; get array size low byte
  4508 00:C1D1: 65 56              ADC   Nbendl            ; add start of this array low byte
  4509 00:C1D3: 85 56              STA   Nbendl            ; save start of next array low byte
  4510 00:C1D5: C8                 INY                     ; increment index
  4511 00:C1D6: B1 23              LDA   (ut1_pl),Y        ; get array size high byte
  4512 00:C1D8: 65 57              ADC   Nbendh            ; add start of this array high byte
  4513 00:C1DA: 85 57              STA   Nbendh            ; save start of next array high byte
  4514 00:C1DC: A0 01              LDY   #$01              ; set index
  4515 00:C1DE: B1 23              LDA   (ut1_pl),Y        ; get name second byte
  4516 00:C1E0: 10 DB              BPL   LAB_218B          ; skip if not string array
  4517                        
  4518                        ; was string array so ..
  4519                        
  4520 00:C1E2: A0 04              LDY   #$04              ; set index
  4521 00:C1E4: B1 23              LDA   (ut1_pl),Y        ; get # of dimensions
  4522 00:C1E6: 0A                 ASL                     ; *2
  4523 00:C1E7: 69 05              ADC   #$05              ; +5 (array header size)
  4524 00:C1E9: 20 31 C2           JSR   LAB_2208          ; go set up for first element
  4525                        LAB_21C4
  4526 00:C1EC: E4 57              CPX   Nbendh            ; compare with start of next array high byte
  4527 00:C1EE: D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
  4528                        
  4529 00:C1F0: C5 56              CMP   Nbendl            ; else compare element pointer low byte with next array
  4530                                                      ; low byte
  Mon Feb  8 2021  9:20                                                                                                    Page 73


  4531 00:C1F2: F0 CD              BEQ   LAB_218F          ; if equal then go do next array
  4532                        
  4533                        LAB_21CC
  4534 00:C1F4: 20 FF C1           JSR   LAB_21D7          ; go defrag array strings
  4535 00:C1F7: 80 F3              BRA   LAB_21C4          ; go do next array string (loop always)
  4536                        
  4537                        ; defrag string variables
  4538                        ; enter with XA = variable pointer
  4539                        ; return with XA = next variable pointer
  4540                        
  4541                        LAB_21D1
  4542 00:C1F9: C8                 INY                     ; increment index (Y was $00)
  4543 00:C1FA: B1 23              LDA   (ut1_pl),Y        ; get var name byte 2
  4544 00:C1FC: 10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
  4545                        
  4546 00:C1FE: C8                 INY                     ; else increment index
  4547                        LAB_21D7
  4548 00:C1FF: B1 23              LDA   (ut1_pl),Y        ; get string length
  4549 00:C201: F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
  4550                        
  4551 00:C203: C8                 INY                     ; else increment index
  4552 00:C204: B1 23              LDA   (ut1_pl),Y        ; get string pointer low byte
  4553 00:C206: AA                 TAX                     ; copy to X
  4554 00:C207: C8                 INY                     ; increment index
  4555 00:C208: B1 23              LDA   (ut1_pl),Y        ; get string pointer high byte
  4556 00:C20A: C5 34              CMP   Sstorh            ; compare bottom of string space high byte
  4557 00:C20C: 90 06              BCC   LAB_21EC          ; branch if less
  4558 00:C20E: D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
  4559                        
  4560                                                      ; high bytes were = so compare low bytes
  4561 00:C210: E4 33              CPX   Sstorl            ; compare bottom of string space low byte
  4562 00:C212: B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
  4563                        
  4564                                                      ; string pointer is < string storage pointer (pos in mem)
  4565                        LAB_21EC
  4566 00:C214: C5 5D              CMP   Histrh            ; compare to highest string high byte
  4567 00:C216: 90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
  4568                        
  4569 00:C218: D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
  4570                        
  4571                                                      ; high bytes were = so compare low bytes
  4572 00:C21A: E4 5C              CPX   Histrl            ; compare to highest string low byte
  4573 00:C21C: 90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
  4574                        
  4575                                                      ; string is in string memory space
  4576                        LAB_21F6
  4577 00:C21E: 86 5C              STX   Histrl            ; save as new highest string low byte
  4578 00:C220: 85 5D              STA   Histrh            ; save as new highest string high byte
  4579 00:C222: A5 23              LDA   ut1_pl            ; get start of vars(descriptors) low byte
  4580 00:C224: A6 24              LDX   ut1_ph            ; get start of vars(descriptors) high byte
  4581 00:C226: 85 4E              STA   garb_l            ; save as working pointer low byte
  4582 00:C228: 86 4F              STX   garb_h            ; save as working pointer high byte
  4583 00:C22A: 88                 DEY                     ; decrement index DIFFERS
  4584 00:C22B: 88                 DEY                     ; decrement index (should point to descriptor start)
  4585 00:C22C: 84 54              STY   g_indx            ; save index pointer
  4586                        
  4587                                                      ; step pointer to next string
  4588                        LAB_2206
  4589 00:C22E: 18                 CLC                     ; clear carry for add
  4590                        LAB_2207
  4591 00:C22F: A5 52              LDA   g_step            ; get step size
  4592                        LAB_2208
  4593 00:C231: 65 23              ADC   ut1_pl            ; add pointer low byte
  Mon Feb  8 2021  9:20                                                                                                    Page 74


  4594 00:C233: 85 23              STA   ut1_pl            ; save pointer low byte
  4595 00:C235: 90 02              BCC   LAB_2211          ; branch if no overflow
  4596                        
  4597 00:C237: E6 24              INC   ut1_ph            ; else increment high byte
  4598                        LAB_2211
  4599 00:C239: A6 24              LDX   ut1_ph            ; get pointer high byte
  4600 00:C23B: A0 00              LDY   #$00              ; clear Y
  4601 00:C23D: 60                 RTS
  4602                        
  4603                        ; search complete, now either exit or set-up and move string
  4604                        
  4605                        LAB_2216
  4606 00:C23E: C6 52              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
  4607                                                      ; patch 2.22p5
  4608 00:C240: A5 4F              LDA   garb_h            ; any string to move?
  4609 00:C242: 05 4E              ORA   garb_l
  4610 00:C244: F0 F3              BEQ   LAB_2211          ; exit if nothing to move
  4611                        
  4612 00:C246: A4 54              LDY   g_indx            ; get index byte back (points to descriptor)
  4613 00:C248: 18                 CLC                     ; clear carry for add
  4614 00:C249: B1 4E              LDA   (garb_l),Y        ; get string length
  4615 00:C24B: 65 5C              ADC   Histrl            ; add highest string low byte
  4616 00:C24D: 85 58              STA   Obendl            ; save old block end low pointer
  4617 00:C24F: A5 5D              LDA   Histrh            ; get highest string high byte
  4618 00:C251: 69 00              ADC   #$00              ; add any carry
  4619 00:C253: 85 59              STA   Obendh            ; save old block end high byte
  4620 00:C255: A5 33              LDA   Sstorl            ; get bottom of string space low byte
  4621 00:C257: A6 34              LDX   Sstorh            ; get bottom of string space high byte
  4622 00:C259: 85 56              STA   Nbendl            ; save new block end low byte
  4623 00:C25B: 86 57              STX   Nbendh            ; save new block end high byte
  4624 00:C25D: 20 8B B0           JSR   LAB_11D6          ; open up space in memory, don't set array end
  4625 00:C260: A4 54              LDY   g_indx            ; get index byte
  4626 00:C262: C8                 INY                     ; point to descriptor low byte
  4627 00:C263: A5 56              LDA   Nbendl            ; get string pointer low byte
  4628 00:C265: 91 4E              STA   (garb_l),Y        ; save new string pointer low byte
  4629 00:C267: AA                 TAX                     ; copy string pointer low byte
  4630 00:C268: E6 57              INC   Nbendh            ; correct high byte (move sets high byte -1)
  4631 00:C26A: A5 57              LDA   Nbendh            ; get new string pointer high byte
  4632 00:C26C: C8                 INY                     ; point to descriptor high byte
  4633 00:C26D: 91 4E              STA   (garb_l),Y        ; save new string pointer high byte
  4634 00:C26F: 4C 7F C1           JMP   LAB_214B          ; re-run routine from last ending
  4635                                                      ; (but don't collect this string)
  4636                        
  4637                        ; concatenate
  4638                        ; add strings, string 1 is in descriptor des_pl, string 2 is in line
  4639                        
  4640                        LAB_224D
  4641 00:C272: A5 61              LDA   des_ph            ; get descriptor pointer high byte
  4642 00:C274: 48                 PHA                     ; put on stack
  4643 00:C275: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  4644 00:C277: 48                 PHA                     ; put on stack
  4645                        
  4646                        LAB_224Da                     ; patch 2.22p5 - added extra label
  4647                        
  4648 00:C278: 20 69 BB           JSR   LAB_GVAL          ; get value from line
  4649 00:C27B: 20 6D BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4650 00:C27E: 68                 PLA                     ; get descriptor pointer low byte back
  4651 00:C27F: 85 6A              STA   ssptr_l           ; set pointer low byte
  4652 00:C281: 68                 PLA                     ; get descriptor pointer high byte back
  4653 00:C282: 85 6B              STA   ssptr_h           ; set pointer high byte
  4654 00:C284: B2 6A              LDA   (ssptr_l)         ; get length_1 from descriptor
  4655 00:C286: 18                 CLC                     ; clear carry for add
  4656 00:C287: 72 60              ADC   (des_pl)          ; add length_2
  Mon Feb  8 2021  9:20                                                                                                    Page 75


  4657 00:C289: 90 05              BCC   LAB_226D          ; branch if no overflow
  4658                        
  4659 00:C28B: A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
  4660 00:C28D: 4C 01 B1           JMP   LAB_XERR          ; do error #X, then warm start
  4661                        
  4662                        LAB_226D
  4663 00:C290: 20 CD C0           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
  4664                                                      ; long
  4665 00:C293: 20 AD C2           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
  4666 00:C296: A5 50              LDA   des_2l            ; get descriptor pointer low byte
  4667 00:C298: A4 51              LDY   des_2h            ; get descriptor pointer high byte
  4668 00:C29A: 20 DE C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4669                                                      ; returns with A = length, ut1_pl = pointer low byte,
  4670                                                      ; ut1_ph = pointer high byte
  4671 00:C29D: 20 BF C2           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
  4672 00:C2A0: A5 6A              LDA   ssptr_l           ; set descriptor pointer low byte
  4673 00:C2A2: A4 6B              LDY   ssptr_h           ; set descriptor pointer high byte
  4674 00:C2A4: 20 DE C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4675                                                      ; returns with A = length, X=ut1_pl=pointer low byte,
  4676                                                      ; Y=ut1_ph=pointer high byte
  4677 00:C2A7: 20 22 C1           JSR   LAB_RTST          ; check for space on descriptor stack then put string
  4678                                                      ; address and length on descriptor stack and update stack
  4679                                                      ; pointers
  4680 00:C2AA: 4C 91 BA           JMP   LAB_1ADB          ; continue evaluation
  4681                        
  4682                        ; copy string from descriptor (sdescr) to (Sutill)
  4683                        
  4684                        LAB_228A
  4685 00:C2AD: A0 00              LDY   #$00              ; clear index
  4686 00:C2AF: B1 6A              LDA   (sdescr),Y        ; get string length
  4687 00:C2B1: 48                 PHA                     ; save on stack
  4688 00:C2B2: C8                 INY                     ; increment index
  4689 00:C2B3: B1 6A              LDA   (sdescr),Y        ; get source string pointer low byte
  4690 00:C2B5: AA                 TAX                     ; copy to X
  4691 00:C2B6: C8                 INY                     ; increment index
  4692 00:C2B7: B1 6A              LDA   (sdescr),Y        ; get source string pointer high byte
  4693 00:C2B9: A8                 TAY                     ; copy to Y
  4694 00:C2BA: 68                 PLA                     ; get length back
  4695                        
  4696                        ; store string A bytes long from YX to (Sutill)
  4697                        
  4698                        LAB_2298
  4699 00:C2BB: 86 23              STX   ut1_pl            ; save source string pointer low byte
  4700 00:C2BD: 84 24              STY   ut1_ph            ; save source string pointer high byte
  4701                        
  4702                        ; store string A bytes long from (ut1_pl) to (Sutill)
  4703                        
  4704                        LAB_229C
  4705 00:C2BF: AA                 TAX                     ; copy length to index (don't count with Y)
  4706 00:C2C0: F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
  4707                        
  4708 00:C2C2: A0 00              LDY   #$00              ; zero pointer (copy forward)
  4709                        LAB_22A0
  4710 00:C2C4: B1 23              LDA   (ut1_pl),Y        ; get source byte
  4711 00:C2C6: 91 35              STA   (Sutill),Y        ; save destination byte
  4712                        
  4713 00:C2C8: C8                 INY                     ; increment index
  4714 00:C2C9: CA                 DEX                     ; decrement counter
  4715 00:C2CA: D0 F8              BNE   LAB_22A0          ; loop while <> 0
  4716                        
  4717 00:C2CC: 98                 TYA                     ; restore length from Y
  4718                        LAB_22A9
  4719 00:C2CD: 18                 CLC                     ; clear carry for add
  Mon Feb  8 2021  9:20                                                                                                    Page 76


  4720 00:C2CE: 65 35              ADC   Sutill            ; add string utility ptr low byte
  4721 00:C2D0: 85 35              STA   Sutill            ; save string utility ptr low byte
  4722 00:C2D2: 90 02              BCC   LAB_22B2          ; branch if no carry
  4723                        
  4724 00:C2D4: E6 36              INC   Sutilh            ; else increment string utility ptr high byte
  4725                        LAB_22B2
  4726 00:C2D6: 60                 RTS
  4727                        
  4728                        ; evaluate string
  4729                        
  4730                        LAB_EVST
  4731 00:C2D7: 20 6D BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4732                        
  4733                        ; pop string off descriptor stack, or from top of string space
  4734                        ; returns with A = length, X=pointer low byte, Y=pointer high byte
  4735                        
  4736                        LAB_22B6
  4737 00:C2DA: A5 60              LDA   des_pl            ; get descriptor pointer low byte
  4738 00:C2DC: A4 61              LDY   des_ph            ; get descriptor pointer high byte
  4739                        
  4740                        ; pop (YA) descriptor off stack or from top of string space
  4741                        ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
  4742                        
  4743                        LAB_22BA
  4744 00:C2DE: 85 23              STA   ut1_pl            ; save descriptor pointer low byte
  4745 00:C2E0: 84 24              STY   ut1_ph            ; save descriptor pointer high byte
  4746 00:C2E2: 20 0F C3           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
  4747 00:C2E5: 08                 PHP                     ; save status flags
  4748 00:C2E6: A0 00              LDY   #$00              ; clear index
  4749 00:C2E8: B1 23              LDA   (ut1_pl),Y        ; get length from string descriptor
  4750 00:C2EA: 48                 PHA                     ; put on stack
  4751 00:C2EB: C8                 INY                     ; increment index
  4752 00:C2EC: B1 23              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
  4753 00:C2EE: AA                 TAX                     ; copy to X
  4754 00:C2EF: C8                 INY                     ; increment index
  4755 00:C2F0: B1 23              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
  4756 00:C2F2: A8                 TAY                     ; copy to Y
  4757 00:C2F3: 68                 PLA                     ; get string length back
  4758 00:C2F4: 28                 PLP                     ; restore status
  4759 00:C2F5: D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
  4760                        
  4761 00:C2F7: C4 34              CPY   Sstorh            ; compare bottom of string space high byte
  4762 00:C2F9: D0 0F              BNE   LAB_22E6          ; branch if <>
  4763                        
  4764 00:C2FB: E4 33              CPX   Sstorl            ; else compare bottom of string space low byte
  4765 00:C2FD: D0 0B              BNE   LAB_22E6          ; branch if <>
  4766                        
  4767 00:C2FF: 48                 PHA                     ; save string length
  4768 00:C300: 18                 CLC                     ; clear carry for add
  4769 00:C301: 65 33              ADC   Sstorl            ; add bottom of string space low byte
  4770 00:C303: 85 33              STA   Sstorl            ; save bottom of string space low byte
  4771 00:C305: 90 02              BCC   LAB_22E5          ; skip increment if no overflow
  4772                        
  4773 00:C307: E6 34              INC   Sstorh            ; increment bottom of string space high byte
  4774                        LAB_22E5
  4775 00:C309: 68                 PLA                     ; restore string length
  4776                        LAB_22E6
  4777 00:C30A: 86 23              STX   ut1_pl            ; save string pointer low byte
  4778 00:C30C: 84 24              STY   ut1_ph            ; save string pointer high byte
  4779 00:C30E: 60                 RTS
  4780                        
  4781                        ; clean descriptor stack, YA = pointer
  4782                        ; checks if AY is on the descriptor stack, if so does a stack discard
  Mon Feb  8 2021  9:20                                                                                                    Page 77


  4783                        
  4784                        LAB_22EB
  4785 00:C30F: C4 19              CPY   last_sh           ; compare pointer high byte
  4786 00:C311: D0 0C              BNE   LAB_22FB          ; exit if <>
  4787                        
  4788 00:C313: C5 18              CMP   last_sl           ; compare pointer low byte
  4789 00:C315: D0 08              BNE   LAB_22FB          ; exit if <>
  4790                        
  4791 00:C317: 85 17              STA   next_s            ; save descriptor stack pointer
  4792 00:C319: E9 03              SBC   #$03              ; -3
  4793 00:C31B: 85 18              STA   last_sl           ; save low byte -3
  4794 00:C31D: A0 00              LDY   #$00              ; clear high byte
  4795                        LAB_22FB
  4796 00:C31F: 60                 RTS
  4797                        
  4798                        ; perform CHR$()
  4799                        
  4800                        LAB_CHRS
  4801 00:C320: 20 24 C4           JSR   LAB_EVBY          ; evaluate byte expression, result in X
  4802 00:C323: DA                 PHX                     ; save character to stack
  4803 00:C324: A9 01              LDA   #$01              ; string is single byte
  4804 00:C326: 20 D5 C0           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  4805                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4806 00:C329: 68                 PLA                     ; get character back
  4807 00:C32A: 92 5F              STA   (str_pl)          ; save byte in string (byte IS string!)
  4808 00:C32C: 4C 22 C1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  4809                                                      ; address and length on descriptor stack and update stack
  4810                                                      ; pointers
  4811                        
  4812                        ; perform LEFT$()
  4813                        
  4814                        LAB_LEFT
  4815 00:C32F: 48                 PHA                     ; push byte parameter
  4816 00:C330: 20 8F C3           JSR   LAB_236F          ; pull string data and byte parameter from stack
  4817                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  4818 00:C333: D1 50              CMP   (des_2l),Y        ; compare byte parameter with string length
  4819 00:C335: 98                 TYA                     ; clear A
  4820 00:C336: 80 09              BRA   LAB_2316          ; go do string copy (branch always)
  4821                        
  4822                        ; perform RIGHT$()
  4823                        
  4824                        LAB_RIGHT
  4825 00:C338: 48                 PHA                     ; push byte parameter
  4826 00:C339: 20 8F C3           JSR   LAB_236F          ; pull string data and byte parameter from stack
  4827                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  4828 00:C33C: 18                 CLC                     ; clear carry for add-1
  4829 00:C33D: F1 50              SBC   (des_2l),Y        ; subtract string length
  4830 00:C33F: 49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
  4831                        
  4832                        LAB_2316
  4833 00:C341: 90 04              BCC   LAB_231C          ; branch if string length > byte parameter
  4834                        
  4835 00:C343: B1 50              LDA   (des_2l),Y        ; else make parameter = length
  4836 00:C345: AA                 TAX                     ; copy to byte parameter copy
  4837 00:C346: 98                 TYA                     ; clear string start offset
  4838                        LAB_231C
  4839 00:C347: 48                 PHA                     ; save string start offset
  4840                        LAB_231D
  4841 00:C348: 8A                 TXA                     ; copy byte parameter (or string length if <)
  4842                        LAB_231E
  4843 00:C349: 48                 PHA                     ; save string length
  4844 00:C34A: 20 D5 C0           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  4845                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 78


  4846 00:C34D: A5 50              LDA   des_2l            ; get descriptor pointer low byte
  4847 00:C34F: A4 51              LDY   des_2h            ; get descriptor pointer high byte
  4848 00:C351: 20 DE C2           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4849                                                      ; returns with A = length, X=ut1_pl=pointer low byte,
  4850                                                      ; Y=ut1_ph=pointer high byte
  4851 00:C354: 7A                 PLY                     ; get string length back
  4852 00:C355: 68                 PLA                     ; get string start offset back
  4853 00:C356: 18                 CLC                     ; clear carry for add
  4854 00:C357: 65 23              ADC   ut1_pl            ; add start offset to string start pointer low byte
  4855 00:C359: 85 23              STA   ut1_pl            ; save string start pointer low byte
  4856 00:C35B: 90 02              BCC   LAB_2335          ; branch if no overflow
  4857                        
  4858 00:C35D: E6 24              INC   ut1_ph            ; else increment string start pointer high byte
  4859                        LAB_2335
  4860 00:C35F: 98                 TYA                     ; copy length to A
  4861 00:C360: 20 BF C2           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
  4862 00:C363: 4C 22 C1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  4863                                                      ; address and length on descriptor stack and update stack
  4864                                                      ; pointers
  4865                        
  4866                        ; perform MID$()
  4867                        
  4868                        LAB_MIDS
  4869 00:C366: 48                 PHA                     ; push byte parameter
  4870 00:C367: A9 FF              LDA   #$FF              ; set default length = 255
  4871 00:C369: 85 61              STA   mids_l            ; save default length
  4872 00:C36B: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  4873 00:C36E: C9 29              CMP   #')'              ; compare with ")"
  4874 00:C370: F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
  4875                        
  4876 00:C372: 20 98 BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  4877 00:C375: 20 21 C4           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
  4878                        LAB_2358
  4879 00:C378: 20 8F C3           JSR   LAB_236F          ; pull string data and byte parameter from stack
  4880                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  4881 00:C37B: CA                 DEX                     ; decrement start index
  4882 00:C37C: 8A                 TXA                     ; copy to A
  4883 00:C37D: 48                 PHA                     ; save string start offset
  4884 00:C37E: 18                 CLC                     ; clear carry for sub-1
  4885 00:C37F: A2 00              LDX   #$00              ; clear output string length
  4886 00:C381: F1 50              SBC   (des_2l),Y        ; subtract string length
  4887 00:C383: B0 C3              BCS   LAB_231D          ; if start>string length go do null string
  4888                        
  4889 00:C385: 49 FF              EOR   #$FF              ; complement -length
  4890 00:C387: C5 61              CMP   mids_l            ; compare byte parameter
  4891 00:C389: 90 BE              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
  4892                        
  4893 00:C38B: A5 61              LDA   mids_l            ; get length byte
  4894 00:C38D: 80 BA              BRA   LAB_231E          ; go do string copy (branch always)
  4895                        
  4896                        ; pull string data and byte parameter from stack
  4897                        ; return pointer in des_2l/h, byte in A (and X), Y=0
  4898                        
  4899                        LAB_236F
  4900 00:C38F: 20 8B BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  4901 00:C392: 68                 PLA                     ; pull return address low byte (return address)
  4902 00:C393: 85 54              STA   Fnxjpl            ; save functions jump vector low byte
  4903 00:C395: 68                 PLA                     ; pull return address high byte (return address)
  4904 00:C396: 85 55              STA   Fnxjph            ; save functions jump vector high byte
  4905 00:C398: FA                 PLX                     ; get byte parameter
  4906 00:C399: 68                 PLA                     ; pull string pointer low byte
  4907 00:C39A: 85 50              STA   des_2l            ; save it
  4908 00:C39C: 68                 PLA                     ; pull string pointer high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 79


  4909 00:C39D: 85 51              STA   des_2h            ; save it
  4910 00:C39F: A0 00              LDY   #$00              ; clear index
  4911 00:C3A1: 8A                 TXA                     ; copy byte parameter
  4912 00:C3A2: F0 77              BEQ   LAB_23A8          ; if null do function call error then warm start
  4913                        
  4914 00:C3A4: E6 54              INC   Fnxjpl            ; increment function jump vector low byte
  4915                                                      ; (JSR pushes return addr-1. this is all very nice
  4916                                                      ; but will go tits up if either call is on a page
  4917                                                      ; boundary!)
  4918 00:C3A6: 6C 54 00           JMP   (Fnxjpl)          ; in effect, RTS
  4919                        
  4920                        ; perform LCASE$()
  4921                        
  4922                        LAB_LCASE
  4923 00:C3A9: 20 D7 C2           JSR   LAB_EVST          ; evaluate string
  4924 00:C3AC: 85 5E              STA   str_ln            ; set string length
  4925 00:C3AE: A8                 TAY                     ; copy length to Y
  4926 00:C3AF: F0 38              BEQ   NoString          ; branch if null string
  4927                        
  4928 00:C3B1: 20 D5 C0           JSR   LAB_MSSP          ; make string space A bytes long A=length,
  4929                                                      ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4930 00:C3B4: 86 5F              STX   str_pl            ; save string pointer low byte
  4931 00:C3B6: 84 60              STY   str_ph            ; save string pointer high byte
  4932 00:C3B8: A8                 TAY                     ; get string length back
  4933                        
  4934                        LC_loop
  4935 00:C3B9: 88                 DEY                     ; decrement index
  4936 00:C3BA: B1 23              LDA   (ut1_pl),Y        ; get byte from string
  4937 00:C3BC: 20 C2 BD           JSR   LAB_1D82          ; is character "A" to "Z"
  4938 00:C3BF: 90 02              BCC   NoUcase           ; branch if not upper case alpha
  4939                        
  4940 00:C3C1: 09 20              ORA   #$20              ; convert upper to lower case
  4941                        NoUcase
  4942 00:C3C3: 91 35              STA   (Sutill),Y        ; save byte back to string
  4943 00:C3C5: 98                 TYA                     ; test index
  4944 00:C3C6: D0 F1              BNE   LC_loop           ; loop if not all done
  4945 00:C3C8: 80 1F              BRA   NoString          ; tidy up and exit, branch always
  4946                        
  4947                        ; perform UCASE$()
  4948                        
  4949                        LAB_UCASE
  4950 00:C3CA: 20 D7 C2           JSR   LAB_EVST          ; evaluate string
  4951 00:C3CD: 85 5E              STA   str_ln            ; set string length
  4952 00:C3CF: A8                 TAY                     ; copy length to Y
  4953 00:C3D0: F0 17              BEQ   NoString          ; branch if null string
  4954                        
  4955 00:C3D2: 20 D5 C0           JSR   LAB_MSSP          ; make string space A bytes long A=length,
  4956                                                      ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4957 00:C3D5: 86 5F              STX   str_pl            ; save string pointer low byte
  4958 00:C3D7: 84 60              STY   str_ph            ; save string pointer high byte
  4959 00:C3D9: A8                 TAY                     ; get string length back
  4960                        
  4961                        UC_loop
  4962 00:C3DA: 88                 DEY                     ; decrement index
  4963 00:C3DB: B1 23              LDA   (ut1_pl),Y        ; get byte from string
  4964 00:C3DD: 20 BE BD           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
  4965 00:C3E0: 90 02              BCC   NoLcase           ; branch if not alpha
  4966                        
  4967 00:C3E2: 29 DF              AND   #$DF              ; convert lower to upper case
  4968                        NoLcase
  4969 00:C3E4: 91 35              STA   (Sutill),Y        ; save byte back to string
  4970 00:C3E6: 98                 TYA                     ; test index
  4971 00:C3E7: D0 F1              BNE   UC_loop           ; loop if not all done
  Mon Feb  8 2021  9:20                                                                                                    Page 80


  4972                        
  4973                        NoString
  4974 00:C3E9: 4C 22 C1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  4975                                                      ; address and length on descriptor stack and update stack
  4976                                                      ; pointers
  4977                        
  4978                        ; perform SADD()
  4979                        
  4980                        LAB_SADD
  4981 00:C3EC: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  4982 00:C3EF: 20 4C BD           JSR   LAB_GVAR          ; get var address
  4983                        
  4984 00:C3F2: 20 8B BB           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  4985 00:C3F5: 20 6D BA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4986                        
  4987 00:C3F8: A0 02              LDY   #$02              ; index to string pointer high byte
  4988 00:C3FA: B1 47              LDA   (Cvaral),Y        ; get string pointer high byte
  4989 00:C3FC: AA                 TAX                     ; copy string pointer high byte to X
  4990 00:C3FD: 88                 DEY                     ; index to string pointer low byte
  4991 00:C3FE: B1 47              LDA   (Cvaral),Y        ; get string pointer low byte
  4992 00:C400: A8                 TAY                     ; copy string pointer low byte to Y
  4993 00:C401: 8A                 TXA                     ; copy string pointer high byte to A
  4994 00:C402: 4C F8 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  4995                        
  4996                        ; perform LEN()
  4997                        
  4998                        LAB_LENS
  4999 00:C405: 20 0B C4           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  5000 00:C408: 4C 05 C0           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  5001                        
  5002                        ; evaluate string, get length in Y
  5003                        
  5004                        LAB_ESGL
  5005 00:C40B: 20 D7 C2           JSR   LAB_EVST          ; evaluate string
  5006 00:C40E: A8                 TAY                     ; copy length to Y
  5007 00:C40F: 60                 RTS
  5008                        
  5009                        ; perform ASC()
  5010                        
  5011                        LAB_ASC
  5012 00:C410: 20 0B C4           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  5013 00:C413: F0 06              BEQ   LAB_23A8          ; if null do function call error then warm start
  5014                        
  5015 00:C415: B2 23              LDA   (ut1_pl)          ; get byte
  5016 00:C417: A8                 TAY                     ; copy to Y
  5017 00:C418: 4C 05 C0           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  5018                        
  5019                        ; do function call error then warm start
  5020                        
  5021                        LAB_23A8
  5022 00:C41B: 4C C8 BE           JMP   LAB_FCER          ; do function call error then warm start
  5023                        
  5024                        ; scan and get byte parameter
  5025                        
  5026                        LAB_SGBY
  5027 00:C41E: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  5028                        
  5029                        ; get byte parameter
  5030                        
  5031                        LAB_GTBY
  5032 00:C421: 20 67 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5033                                                      ; else do type mismatch
  5034                        
  Mon Feb  8 2021  9:20                                                                                                    Page 81


  5035                        ; evaluate byte expression, result in X
  5036                        
  5037                        LAB_EVBY
  5038 00:C424: 20 42 BE           JSR   LAB_EVPI          ; evaluate integer expression (no check)
  5039                        
  5040 00:C427: A4 60              LDY   FAC1_2            ; get FAC1 mantissa2
  5041 00:C429: D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
  5042                        
  5043 00:C42B: A6 61              LDX   FAC1_3            ; get FAC1 mantissa3
  5044 00:C42D: 4C BB CF           JMP   LAB_GBYT          ; scan memory and return
  5045                        
  5046                        ; perform VAL()
  5047                        
  5048                        LAB_VAL
  5049 00:C430: 20 0B C4           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  5050 00:C433: D0 03              BNE   LAB_23C5          ; branch if not null string
  5051                        
  5052                                                      ; string was null so set result = $00
  5053 00:C435: 4C D8 C5           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
  5054                        
  5055                        LAB_23C5
  5056                                                      ; patch 2.22p5 - new routine
  5057 00:C438: 48                 PHA                     ; save length
  5058 00:C439: C8                 INY                     ; string length +1
  5059 00:C43A: 98                 TYA
  5060 00:C43B: 20 D5 C0           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
  5061 00:C43E: 68                 PLA                     ; get length back
  5062 00:C43F: 20 BF C2           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
  5063 00:C442: A9 00              LDA   #0                ; add delimiter to end of string
  5064 00:C444: 92 35              STA   (Sutill)
  5065 00:C446: A6 6E              LDX   Bpntrl            ; save BASIC execute pointer low byte
  5066 00:C448: A4 6F              LDY   Bpntrh
  5067 00:C44A: 86 6C              STX   Btmpl
  5068 00:C44C: 84 6D              STY   Btmph
  5069 00:C44E: A6 5F              LDX   str_pl            ; point to temporary string
  5070 00:C450: A4 60              LDY   str_ph
  5071 00:C452: 86 6E              STX   Bpntrl
  5072 00:C454: 84 6F              STY   Bpntrh
  5073 00:C456: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  5074 00:C459: 20 26 C9           JSR   LAB_2887          ; get FAC1 from string
  5075                        
  5076                        LAB_23F3
  5077 00:C45C: A6 6C              LDX   Btmpl             ; get BASIC execute pointer low byte back
  5078 00:C45E: A4 6D              LDY   Btmph             ; get BASIC execute pointer high byte back
  5079 00:C460: 86 6E              STX   Bpntrl            ; save BASIC execute pointer low byte
  5080 00:C462: 84 6F              STY   Bpntrh            ; save BASIC execute pointer high byte
  5081 00:C464: 60                 RTS
  5082                        
  5083                        ; get two parameters for POKE or WAIT
  5084                        
  5085                        LAB_GADB
  5086 00:C465: 20 67 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5087                                                      ; else do type mismatch
  5088 00:C468: 20 7E C4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  5089                        
  5090                        ; scan for "," and get byte, else do Syntax error then warm start
  5091                        
  5092                        LAB_SCGB
  5093 00:C46B: 20 98 BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5094 00:C46E: A5 0B              LDA   Itemph            ; save temporary integer high byte
  5095 00:C470: 48                 PHA                     ; on stack
  5096 00:C471: A5 0A              LDA   Itempl            ; save temporary integer low byte
  5097 00:C473: 48                 PHA                     ; on stack
  Mon Feb  8 2021  9:20                                                                                                    Page 82


  5098 00:C474: 20 21 C4           JSR   LAB_GTBY          ; get byte parameter
  5099 00:C477: 68                 PLA                     ; pull low byte
  5100 00:C478: 85 0A              STA   Itempl            ; restore temporary integer low byte
  5101 00:C47A: 68                 PLA                     ; pull high byte
  5102 00:C47B: 85 0B              STA   Itemph            ; restore temporary integer high byte
  5103 00:C47D: 60                 RTS
  5104                        
  5105                        ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
  5106                        ; -ve and converts it into a right truncated integer in Itempl and Itemph
  5107                        
  5108                        ; save unsigned 16 bit integer part of FAC1 in temporary integer
  5109                        
  5110                        LAB_F2FX
  5111 00:C47E: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5112 00:C480: C9 98              CMP   #$98              ; compare with exponent = 2^24
  5113 00:C482: B0 97              BCS   LAB_23A8          ; if >= do function call error then warm start
  5114                        
  5115                        LAB_F2FU
  5116 00:C484: 20 D0 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  5117 00:C487: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5118 00:C489: A4 61              LDY   FAC1_3            ; get FAC1 mantissa3
  5119 00:C48B: 84 0A              STY   Itempl            ; save temporary integer low byte
  5120 00:C48D: 85 0B              STA   Itemph            ; save temporary integer high byte
  5121 00:C48F: 60                 RTS
  5122                        
  5123                        ; perform PEEK()
  5124                        
  5125                        LAB_PEEK
  5126 00:C490: 20 7E C4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  5127 00:C493: A2 00              LDX   #$00              ; clear index
  5128 00:C495: A1 0A              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
  5129 00:C497: A8                 TAY                     ; copy byte to Y
  5130 00:C498: 4C 05 C0           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  5131                        
  5132                        ; perform POKE
  5133                        
  5134                        LAB_POKE
  5135 00:C49B: 20 65 C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  5136 00:C49E: 8A                 TXA                     ; copy byte argument to A
  5137 00:C49F: A2 00              LDX   #$00              ; clear index
  5138 00:C4A1: 81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  5139 00:C4A3: 60                 RTS
  5140                        
  5141                        ; perform DEEK()
  5142                        
  5143                        LAB_DEEK
  5144 00:C4A4: 20 7E C4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  5145 00:C4A7: A2 00              LDX   #$00              ; clear index
  5146 00:C4A9: A1 0A              LDA   (Itempl,X)        ; PEEK low byte
  5147 00:C4AB: A8                 TAY                     ; copy to Y
  5148 00:C4AC: E6 0A              INC   Itempl            ; increment pointer low byte
  5149 00:C4AE: D0 02              BNE   Deekh             ; skip high increment if no rollover
  5150                        
  5151 00:C4B0: E6 0B              INC   Itemph            ; increment pointer high byte
  5152                        Deekh
  5153 00:C4B2: A1 0A              LDA   (Itempl,X)        ; PEEK high byte
  5154 00:C4B4: 4C F8 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  5155                        
  5156                        ; perform DOKE
  5157                        
  5158                        LAB_DOKE
  5159 00:C4B7: 20 67 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5160                                                      ; else do type mismatch
  Mon Feb  8 2021  9:20                                                                                                    Page 83


  5161 00:C4BA: 20 7E C4           JSR   LAB_F2FX          ; convert floating-to-fixed
  5162                        
  5163 00:C4BD: 84 49              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
  5164 00:C4BF: 85 4A              STA   Frnxth            ; save pointer high byte
  5165                        
  5166 00:C4C1: 20 98 BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5167 00:C4C4: 20 67 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5168                                                      ; else do type mismatch
  5169 00:C4C7: 20 7E C4           JSR   LAB_F2FX          ; convert floating-to-fixed
  5170                        
  5171 00:C4CA: 98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
  5172 00:C4CB: A2 00              LDX   #$00              ; clear index
  5173 00:C4CD: 81 49              STA   (Frnxtl,X)        ; POKE low byte
  5174 00:C4CF: E6 49              INC   Frnxtl            ; increment pointer low byte
  5175 00:C4D1: D0 02              BNE   Dokeh             ; skip high increment if no rollover
  5176                        
  5177 00:C4D3: E6 4A              INC   Frnxth            ; increment pointer high byte
  5178                        Dokeh
  5179 00:C4D5: A5 0B              LDA   Itemph            ; get value high byte
  5180 00:C4D7: 81 49              STA   (Frnxtl,X)        ; POKE high byte
  5181 00:C4D9: 4C BB CF           JMP   LAB_GBYT          ; scan memory and return
  5182                        
  5183                        ; perform SWAP
  5184                        
  5185                        LAB_SWAP
  5186 00:C4DC: 20 4C BD           JSR   LAB_GVAR          ; get var1 address
  5187 00:C4DF: 85 49              STA   Lvarpl            ; save var1 address low byte
  5188 00:C4E1: 84 4A              STY   Lvarph            ; save var1 address high byte
  5189 00:C4E3: A5 11              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  5190 00:C4E5: 48                 PHA                     ; save data type flag
  5191                        
  5192 00:C4E6: 20 98 BB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5193 00:C4E9: 20 4C BD           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
  5194 00:C4EC: 68                 PLA                     ; pull var1 data type flag
  5195 00:C4ED: 45 11              EOR   Dtypef            ; compare with var2 data type
  5196 00:C4EF: 10 10              BPL   SwapErr           ; exit if not both the same type
  5197                        
  5198 00:C4F1: A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
  5199                        SwapLp
  5200 00:C4F3: B1 49              LDA   (Lvarpl),Y        ; get byte from var1
  5201 00:C4F5: AA                 TAX                     ; save var1 byte
  5202 00:C4F6: B1 47              LDA   (Cvaral),Y        ; get byte from var2
  5203 00:C4F8: 91 49              STA   (Lvarpl),Y        ; save byte to var1
  5204 00:C4FA: 8A                 TXA                     ; restore var1 byte
  5205 00:C4FB: 91 47              STA   (Cvaral),Y        ; save byte to var2
  5206 00:C4FD: 88                 DEY                     ; decrement index
  5207 00:C4FE: 10 F3              BPL   SwapLp            ; loop until done
  5208 00:C500: 60                 RTS
  5209                        
  5210                        SwapErr
  5211 00:C501: 4C 77 BA           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
  5212                        
  5213                        ; perform CALL
  5214                        
  5215                        LAB_CALL
  5216 00:C504: 20 67 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5217                                                      ; else do type mismatch
  5218 00:C507: 20 7E C4           JSR   LAB_F2FX          ; convert floating-to-fixed
  5219 00:C50A: A9 C5              LDA   #>CallExit        ; set return address high byte
  5220 00:C50C: 48                 PHA                     ; put on stack
  5221 00:C50D: A9 12              LDA   #<CallExit-1      ; set return address low byte
  5222 00:C50F: 48                 PHA                     ; put on stack
  5223 00:C510: 6C 0A 00           JMP   (Itempl)          ; do indirect jump to user routine
  Mon Feb  8 2021  9:20                                                                                                    Page 84


  5224                        
  5225                        ; if the called routine exits correctly then it will return to here. this will then get
  5226                        ; the next byte for the interpreter and return
  5227                        
  5228                        CallExit
  5229 00:C513: 4C BB CF           JMP   LAB_GBYT          ; scan memory and return
  5230                        
  5231                        ; perform WAIT
  5232                        
  5233                        LAB_WAIT
  5234 00:C516: 20 65 C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  5235 00:C519: 86 49              STX   Frnxtl            ; save byte
  5236 00:C51B: A2 00              LDX   #$00              ; clear mask
  5237 00:C51D: 20 BB CF           JSR   LAB_GBYT          ; scan memory
  5238 00:C520: F0 03              BEQ   LAB_2441          ; skip if no third argument
  5239                        
  5240 00:C522: 20 6B C4           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
  5241                        LAB_2441
  5242 00:C525: 86 4A              STX   Frnxth            ; save EOR argument
  5243                        LAB_2445
  5244 00:C527: B1 0A              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
  5245 00:C529: 45 4A              EOR   Frnxth            ; EOR with second argument (mask)
  5246 00:C52B: 25 49              AND   Frnxtl            ; AND with first argument (byte)
  5247 00:C52D: F0 F8              BEQ   LAB_2445          ; loop if result is zero
  5248                        
  5249                        LAB_244D
  5250 00:C52F: 60                 RTS
  5251                        
  5252                        ; perform subtraction, FAC1 from (AY)
  5253                        
  5254                        LAB_2455
  5255 00:C530: 20 11 C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5256                        
  5257                        ; perform subtraction, FAC1 from FAC2
  5258                        
  5259                        LAB_SUBTRACT
  5260 00:C533: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5261 00:C535: 49 FF              EOR   #$FF              ; complement it
  5262 00:C537: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5263 00:C539: 45 69              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
  5264 00:C53B: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5265 00:C53D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5266 00:C53F: 80 0C              BRA   LAB_ADD           ; go add FAC2 to FAC1
  5267                        
  5268                        ; perform addition
  5269                        
  5270                        LAB_2467
  5271 00:C541: 20 62 C6           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
  5272 00:C544: 90 49              BCC   LAB_24A8          ; go subtract mantissas
  5273                        
  5274                        ; add 0.5 to FAC1
  5275                        
  5276                        LAB_244E
  5277 00:C546: A9 79              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
  5278 00:C548: A0 D1              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
  5279                        
  5280                        ; add (AY) to FAC1
  5281                        
  5282                        LAB_246C
  5283 00:C54A: 20 11 C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5284                        
  5285                        ; add FAC2 to FAC1
  5286                        
  Mon Feb  8 2021  9:20                                                                                                    Page 85


  5287                        LAB_ADD
  5288 00:C54D: D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
  5289                        
  5290                        ; copy FAC2 to FAC1
  5291                        
  5292                        LAB_279B
  5293 00:C54F: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  5294                        
  5295                        ; save FAC1 sign and copy ABS(FAC2) to FAC1
  5296                        
  5297                        LAB_279D
  5298 00:C551: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5299 00:C553: A2 04              LDX   #$04              ; 4 bytes to copy
  5300                        LAB_27A1
  5301 00:C555: B5 64              LDA   FAC1_o,X          ; get byte from FAC2,X
  5302 00:C557: 95 5D              STA   FAC1_e-1,X        ; save byte at FAC1,X
  5303 00:C559: CA                 DEX                     ; decrement count
  5304 00:C55A: D0 F9              BNE   LAB_27A1          ; loop if not all done
  5305                        
  5306 00:C55C: 86 6B              STX   FAC1_r            ; clear FAC1 rounding byte
  5307 00:C55E: 60                 RTS
  5308                        
  5309                                                      ; FAC1 is non zero
  5310                        LAB_2474
  5311 00:C55F: A6 6B              LDX   FAC1_r            ; get FAC1 rounding byte
  5312 00:C561: 86 55              STX   FAC2_r            ; save as FAC2 rounding byte
  5313 00:C563: A2 65              LDX   #FAC2_e           ; set index to FAC2 exponent addr
  5314 00:C565: A5 65              LDA   FAC2_e            ; get FAC2 exponent
  5315                        LAB_247C
  5316 00:C567: A8                 TAY                     ; copy exponent
  5317 00:C568: F0 C5              BEQ   LAB_244D          ; exit if zero
  5318                        
  5319 00:C56A: 38                 SEC                     ; set carry for subtract
  5320 00:C56B: E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent
  5321 00:C56D: F0 20              BEQ   LAB_24A8          ; branch if = (go add mantissa)
  5322 00:C56F: 90 10              BCC   LAB_2498          ; branch if <
  5323                        
  5324                                                      ; FAC2>FAC1
  5325 00:C571: 84 5E              STY   FAC1_e            ; save FAC1 exponent
  5326 00:C573: A4 69              LDY   FAC2_s            ; get FAC2 sign (b7)
  5327 00:C575: 84 62              STY   FAC1_s            ; save FAC1 sign (b7)
  5328 00:C577: 49 FF              EOR   #$FF              ; complement A
  5329 00:C579: 69 00              ADC   #$00              ; +1 (twos complement, carry is set)
  5330 00:C57B: 64 55              STZ   FAC2_r            ; clear FAC2 rounding byte
  5331 00:C57D: A2 5E              LDX   #FAC1_e           ; set index to FAC1 exponent addr
  5332 00:C57F: 80 02              BRA   LAB_249C          ; branch always
  5333                        
  5334                        LAB_2498
  5335 00:C581: 64 6B              STZ   FAC1_r            ; clear FAC1 rounding byte
  5336                        LAB_249C
  5337 00:C583: C9 F9              CMP   #$F9              ; compare exponent diff with $F9
  5338 00:C585: 30 BA              BMI   LAB_2467          ; branch if range $79-$F8
  5339                        
  5340 00:C587: A8                 TAY                     ; copy exponent difference to Y
  5341 00:C588: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5342 00:C58A: 56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
  5343 00:C58C: 20 79 C6           JSR   LAB_2592          ; shift FACX Y times right
  5344                        
  5345                                                      ; exponents are equal now do mantissa subtract
  5346                        LAB_24A8
  5347 00:C58F: 24 6A              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
  5348 00:C591: 10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
  5349                        
  Mon Feb  8 2021  9:20                                                                                                    Page 86


  5350 00:C593: A0 5E              LDY   #FAC1_e           ; set index to FAC1 exponent addr
  5351 00:C595: E0 65              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
  5352 00:C597: F0 02              BEQ   LAB_24B4          ; branch if =
  5353                        
  5354 00:C599: A0 65              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
  5355                        
  5356                                                      ; subtract smaller from bigger (take sign of bigger)
  5357                        LAB_24B4
  5358 00:C59B: 38                 SEC                     ; set carry for subtract
  5359 00:C59C: 49 FF              EOR   #$FF              ; ones complement A
  5360 00:C59E: 65 55              ADC   FAC2_r            ; add FAC2 rounding byte
  5361 00:C5A0: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5362 00:C5A2: B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
  5363 00:C5A5: F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
  5364 00:C5A7: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5365 00:C5A9: B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
  5366 00:C5AC: F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
  5367 00:C5AE: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5368 00:C5B0: B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
  5369 00:C5B3: F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
  5370 00:C5B5: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5371                        
  5372                        ; do ABS and normalise FAC1
  5373                        
  5374                        LAB_24D0
  5375 00:C5B7: B0 03              BCS   LAB_24D5          ; branch if number is +ve
  5376                        
  5377 00:C5B9: 20 1E C6           JSR   LAB_2537          ; negate FAC1
  5378                        
  5379                        ; normalise FAC1
  5380                        
  5381                        LAB_24D5
  5382 00:C5BC: A9 00              LDA   #$00              ; clear A
  5383 00:C5BE: A8                 TAY                     ; clear Y
  5384 00:C5BF: 18                 CLC                     ; clear carry for add
  5385                        LAB_24D9
  5386 00:C5C0: A6 5F              LDX   FAC1_1            ; get FAC1 mantissa1
  5387 00:C5C2: D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
  5388                        
  5389 00:C5C4: A6 60              LDX   FAC1_2            ; get FAC1 mantissa2
  5390 00:C5C6: 86 5F              STX   FAC1_1            ; save FAC1 mantissa1
  5391 00:C5C8: A6 61              LDX   FAC1_3            ; get FAC1 mantissa3
  5392 00:C5CA: 86 60              STX   FAC1_2            ; save FAC1 mantissa2
  5393 00:C5CC: A6 6B              LDX   FAC1_r            ; get FAC1 rounding byte
  5394 00:C5CE: 86 61              STX   FAC1_3            ; save FAC1 mantissa3
  5395 00:C5D0: 84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
  5396 00:C5D2: 69 08              ADC   #$08              ; add x to exponent offset
  5397 00:C5D4: C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
  5398 00:C5D6: D0 E8              BNE   LAB_24D9          ; loop if not max
  5399                        
  5400                        ; clear FAC1 exponent and sign
  5401                        
  5402                        LAB_24F1
  5403 00:C5D8: A9 00              LDA   #$00              ; clear A
  5404                        LAB_24F3
  5405 00:C5DA: 85 5E              STA   FAC1_e            ; set FAC1 exponent
  5406                        
  5407                        ; save FAC1 sign
  5408                        
  5409                        LAB_24F5
  5410 00:C5DC: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5411 00:C5DE: 60                 RTS
  5412                        
  Mon Feb  8 2021  9:20                                                                                                    Page 87


  5413                        ; add FAC2 mantissa to FAC1 mantissa
  5414                        
  5415                        LAB_24F8
  5416 00:C5DF: 65 55              ADC   FAC2_r            ; add FAC2 rounding byte
  5417 00:C5E1: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5418 00:C5E3: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5419 00:C5E5: 65 68              ADC   FAC2_3            ; add FAC2 mantissa3
  5420 00:C5E7: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5421 00:C5E9: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5422 00:C5EB: 65 67              ADC   FAC2_2            ; add FAC2 mantissa2
  5423 00:C5ED: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5424 00:C5EF: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5425 00:C5F1: 65 66              ADC   FAC2_1            ; add FAC2 mantissa1
  5426 00:C5F3: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5427 00:C5F5: B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
  5428 00:C5F7: 60                 RTS                     ; else just exit
  5429                        
  5430                        LAB_2511
  5431 00:C5F8: 69 01              ADC   #$01              ; add 1 to exponent offset
  5432 00:C5FA: 06 6B              ASL   FAC1_r            ; shift FAC1 rounding byte
  5433 00:C5FC: 26 61              ROL   FAC1_3            ; shift FAC1 mantissa3
  5434 00:C5FE: 26 60              ROL   FAC1_2            ; shift FAC1 mantissa2
  5435 00:C600: 26 5F              ROL   FAC1_1            ; shift FAC1 mantissa1
  5436                        
  5437                        ; normalise FAC1
  5438                        
  5439                        LAB_251B
  5440 00:C602: 10 F4              BPL   LAB_2511          ; loop if not normalised
  5441                        
  5442 00:C604: 38                 SEC                     ; set carry for subtract
  5443 00:C605: E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent
  5444 00:C607: B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
  5445                        
  5446 00:C609: 49 FF              EOR   #$FF              ; complement exponent
  5447 00:C60B: 69 01              ADC   #$01              ; +1 (twos complement)
  5448 00:C60D: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5449                        
  5450                        ; test and normalise FAC1 for C=0/1
  5451                        
  5452                        LAB_2528
  5453 00:C60F: 90 0C              BCC   LAB_2536          ; exit if no overflow
  5454                        
  5455                        ; normalise FAC1 for C=1
  5456                        
  5457                        LAB_252A
  5458 00:C611: E6 5E              INC   FAC1_e            ; increment FAC1 exponent
  5459 00:C613: F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
  5460                        
  5461 00:C615: 66 5F              ROR   FAC1_1            ; shift FAC1 mantissa1
  5462 00:C617: 66 60              ROR   FAC1_2            ; shift FAC1 mantissa2
  5463 00:C619: 66 61              ROR   FAC1_3            ; shift FAC1 mantissa3
  5464 00:C61B: 66 6B              ROR   FAC1_r            ; shift FAC1 rounding byte
  5465                        LAB_2536
  5466 00:C61D: 60                 RTS
  5467                        
  5468                        ; negate FAC1
  5469                        
  5470                        LAB_2537
  5471 00:C61E: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5472 00:C620: 49 FF              EOR   #$FF              ; complement it
  5473 00:C622: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5474                        
  5475                        ; twos complement FAC1 mantissa
  Mon Feb  8 2021  9:20                                                                                                    Page 88


  5476                        
  5477                        LAB_253D
  5478 00:C624: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5479 00:C626: 49 FF              EOR   #$FF              ; complement it
  5480 00:C628: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5481 00:C62A: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5482 00:C62C: 49 FF              EOR   #$FF              ; complement it
  5483 00:C62E: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5484 00:C630: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5485 00:C632: 49 FF              EOR   #$FF              ; complement it
  5486 00:C634: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5487 00:C636: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5488 00:C638: 49 FF              EOR   #$FF              ; complement it
  5489 00:C63A: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5490 00:C63C: E6 6B              INC   FAC1_r            ; increment FAC1 rounding byte
  5491 00:C63E: D0 0A              BNE   LAB_2563          ; exit if no overflow
  5492                        
  5493                        ; increment FAC1 mantissa
  5494                        
  5495                        LAB_2559
  5496 00:C640: E6 61              INC   FAC1_3            ; increment FAC1 mantissa3
  5497 00:C642: D0 06              BNE   LAB_2563          ; finished if no rollover
  5498                        
  5499 00:C644: E6 60              INC   FAC1_2            ; increment FAC1 mantissa2
  5500 00:C646: D0 02              BNE   LAB_2563          ; finished if no rollover
  5501                        
  5502 00:C648: E6 5F              INC   FAC1_1            ; increment FAC1 mantissa1
  5503                        LAB_2563
  5504 00:C64A: 60                 RTS
  5505                        
  5506                        ; do overflow error (overflow exit)
  5507                        
  5508                        LAB_2564
  5509 00:C64B: A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
  5510 00:C64D: 4C 01 B1           JMP   LAB_XERR          ; do error #X, then warm start
  5511                        
  5512                        ; shift FCAtemp << A+8 times
  5513                        
  5514                        LAB_2569
  5515 00:C650: A2 26              LDX   #FACt_1-1         ; set offset to FACtemp
  5516                        LAB_256B
  5517 00:C652: B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
  5518 00:C654: 84 6B              STY   FAC1_r            ; save as FAC1 rounding byte
  5519 00:C656: B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
  5520 00:C658: 94 03              STY   PLUS_3,X          ; save FACX mantissa3
  5521 00:C65A: B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
  5522 00:C65C: 94 02              STY   PLUS_2,X          ; save FACX mantissa2
  5523 00:C65E: A4 64              LDY   FAC1_o            ; get FAC1 overflow byte
  5524 00:C660: 94 01              STY   PLUS_1,X          ; save FACX mantissa1
  5525                        
  5526                        ; shift FACX -A times right (> 8 shifts)
  5527                        
  5528                        LAB_257B
  5529 00:C662: 69 08              ADC   #$08              ; add 8 to shift count
  5530 00:C664: 30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
  5531                        
  5532 00:C666: F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
  5533                        
  5534 00:C668: E9 08              SBC   #$08              ; else subtract 8 again
  5535 00:C66A: A8                 TAY                     ; save count to Y
  5536 00:C66B: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5537 00:C66D: B0 12              BCS   LAB_259A          ;
  5538                        
  Mon Feb  8 2021  9:20                                                                                                    Page 89


  5539                        LAB_2588
  5540 00:C66F: 16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
  5541 00:C671: 90 02              BCC   LAB_258E          ; branch if +ve
  5542                        
  5543 00:C673: F6 01              INC   PLUS_1,X          ; this sets b7 eventually
  5544                        LAB_258E
  5545 00:C675: 76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
  5546 00:C677: 76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
  5547                        
  5548                        ; shift FACX Y times right
  5549                        
  5550                        LAB_2592
  5551 00:C679: 76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
  5552 00:C67B: 76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
  5553 00:C67D: 6A                 ROR                     ; shift FACX rounding byte
  5554 00:C67E: C8                 INY                     ; increment exponent diff
  5555 00:C67F: D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
  5556                        
  5557                        LAB_259A
  5558 00:C681: 18                 CLC                     ; just clear it
  5559 00:C682: 60                 RTS
  5560                        
  5561                        ; perform LOG()
  5562                        
  5563                        LAB_LOG
  5564 00:C683: 20 6E C8           JSR   LAB_27CA          ; test sign and zero
  5565 00:C686: F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
  5566                        
  5567 00:C688: 10 03              BPL   LAB_25C7          ; skip error if +ve
  5568                        
  5569                        LAB_25C4
  5570 00:C68A: 4C C8 BE           JMP   LAB_FCER          ; do function call error then warm start (-ve)
  5571                        
  5572                        LAB_25C7
  5573 00:C68D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5574 00:C68F: E9 7F              SBC   #$7F              ; normalise it
  5575 00:C691: 48                 PHA                     ; save it
  5576 00:C692: A9 80              LDA   #$80              ; set exponent to zero
  5577 00:C694: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5578 00:C696: A9 F9              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
  5579 00:C698: A0 D0              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
  5580 00:C69A: 20 4A C5           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
  5581 00:C69D: A9 FD              LDA   #<LAB_25B1        ; set root2 pointer low byte
  5582 00:C69F: A0 D0              LDY   #>LAB_25B1        ; set root2 pointer high byte
  5583 00:C6A1: 20 87 C7           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
  5584 00:C6A4: A9 70              LDA   #<LAB_259C        ; set 1 pointer low byte
  5585 00:C6A6: A0 D1              LDY   #>LAB_259C        ; set 1 pointer high byte
  5586 00:C6A8: 20 30 C5           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
  5587 00:C6AB: A9 EC              LDA   #<LAB_25A0        ; set pointer low byte to counter
  5588 00:C6AD: A0 D0              LDY   #>LAB_25A0        ; set pointer high byte to counter
  5589 00:C6AF: 20 C8 CB           JSR   LAB_2B6E          ; ^2 then series evaluation
  5590 00:C6B2: A9 01              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
  5591 00:C6B4: A0 D1              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
  5592 00:C6B6: 20 4A C5           JSR   LAB_246C          ; add (AY) to FAC1
  5593 00:C6B9: 68                 PLA                     ; restore FAC1 exponent
  5594 00:C6BA: 20 C1 C9           JSR   LAB_2912          ; evaluate new ASCII digit
  5595 00:C6BD: A9 05              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
  5596 00:C6BF: A0 D1              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
  5597                        
  5598                        ; do convert AY, FCA1*(AY)
  5599                        
  5600                        LAB_25FB
  5601 00:C6C1: 20 11 C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  Mon Feb  8 2021  9:20                                                                                                    Page 90


  5602                        LAB_MULTIPLY
  5603 00:C6C4: F0 4A              BEQ   LAB_264C          ; exit if zero
  5604                        
  5605 00:C6C6: 20 37 C7           JSR   LAB_2673          ; test and adjust accumulators
  5606 00:C6C9: 64 27              STZ   FACt_1            ; clear temp mantissa1
  5607 00:C6CB: 64 28              STZ   FACt_2            ; clear temp mantissa2
  5608 00:C6CD: 64 29              STZ   FACt_3            ; clear temp mantissa3
  5609 00:C6CF: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  5610 00:C6D1: 20 E6 C6           JSR   LAB_2622          ; go do shift/add FAC2
  5611 00:C6D4: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5612 00:C6D6: 20 E6 C6           JSR   LAB_2622          ; go do shift/add FAC2
  5613 00:C6D9: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5614 00:C6DB: 20 E6 C6           JSR   LAB_2622          ; go do shift/add FAC2
  5615 00:C6DE: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5616 00:C6E0: 20 EC C6           JSR   LAB_2627          ; go do shift/add FAC2
  5617 00:C6E3: 4C F3 C7           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
  5618                        
  5619                        LAB_2622
  5620 00:C6E6: D0 04              BNE   LAB_2627          ; branch if byte <> zero
  5621                                                      ; patch 2.22p5
  5622 00:C6E8: 38                 SEC
  5623 00:C6E9: 4C 50 C6           JMP   LAB_2569          ; shift FACtemp << A+8 times
  5624                                                      ; else do shift and add
  5625                        LAB_2627
  5626 00:C6EC: 38                 SEC                     ; set top bit (mark for 8 times)
  5627 00:C6ED: 6A                 ROR
  5628                        
  5629                        LAB_262A
  5630 00:C6EE: A8                 TAY                     ; copy result
  5631 00:C6EF: 90 13              BCC   LAB_2640          ; skip next if bit was zero
  5632                        
  5633 00:C6F1: 18                 CLC                     ; clear carry for add
  5634 00:C6F2: A5 29              LDA   FACt_3            ; get temp mantissa3
  5635 00:C6F4: 65 68              ADC   FAC2_3            ; add FAC2 mantissa3
  5636 00:C6F6: 85 29              STA   FACt_3            ; save temp mantissa3
  5637 00:C6F8: A5 28              LDA   FACt_2            ; get temp mantissa2
  5638 00:C6FA: 65 67              ADC   FAC2_2            ; add FAC2 mantissa2
  5639 00:C6FC: 85 28              STA   FACt_2            ; save temp mantissa2
  5640 00:C6FE: A5 27              LDA   FACt_1            ; get temp mantissa1
  5641 00:C700: 65 66              ADC   FAC2_1            ; add FAC2 mantissa1
  5642 00:C702: 85 27              STA   FACt_1            ; save temp mantissa1
  5643                        LAB_2640
  5644 00:C704: 66 27              ROR   FACt_1            ; shift temp mantissa1
  5645 00:C706: 66 28              ROR   FACt_2            ; shift temp mantissa2
  5646 00:C708: 66 29              ROR   FACt_3            ; shift temp mantissa3
  5647 00:C70A: 66 6B              ROR   FAC1_r            ; shift temp rounding byte
  5648 00:C70C: 98                 TYA                     ; get byte back
  5649 00:C70D: 4A                 LSR                     ; shift byte
  5650 00:C70E: D0 DE              BNE   LAB_262A          ; loop if all bits not done
  5651                        
  5652                        LAB_264C
  5653 00:C710: 60                 RTS
  5654                        
  5655                        ; unpack memory (AY) into FAC2
  5656                        
  5657                        LAB_264D
  5658 00:C711: 85 23              STA   ut1_pl            ; save pointer low byte
  5659 00:C713: 84 24              STY   ut1_ph            ; save pointer high byte
  5660 00:C715: A0 03              LDY   #$03              ; 4 bytes to get (0-3)
  5661 00:C717: B1 23              LDA   (ut1_pl),Y        ; get mantissa3
  5662 00:C719: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  5663 00:C71B: 88                 DEY                     ; decrement index
  5664 00:C71C: B1 23              LDA   (ut1_pl),Y        ; get mantissa2
  Mon Feb  8 2021  9:20                                                                                                    Page 91


  5665 00:C71E: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  5666 00:C720: 88                 DEY                     ; decrement index
  5667 00:C721: B1 23              LDA   (ut1_pl),Y        ; get mantissa1+sign
  5668 00:C723: 85 69              STA   FAC2_s            ; save FAC2 sign (b7)
  5669 00:C725: 45 62              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
  5670 00:C727: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5671 00:C729: A5 69              LDA   FAC2_s            ; recover FAC2 sign (b7)
  5672 00:C72B: 09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
  5673 00:C72D: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  5674 00:C72F: 88                 DEY                     ; decrement index
  5675 00:C730: B1 23              LDA   (ut1_pl),Y        ; get exponent byte
  5676 00:C732: 85 65              STA   FAC2_e            ; save FAC2 exponent
  5677 00:C734: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5678 00:C736: 60                 RTS
  5679                        
  5680                        ; test and adjust accumulators
  5681                        
  5682                        LAB_2673
  5683 00:C737: A5 65              LDA   FAC2_e            ; get FAC2 exponent
  5684                        LAB_2675
  5685 00:C739: F0 1E              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
  5686                        
  5687 00:C73B: 18                 CLC                     ; clear carry for add
  5688 00:C73C: 65 5E              ADC   FAC1_e            ; add FAC1 exponent
  5689 00:C73E: 90 05              BCC   LAB_2680          ; branch if sum of exponents <$0100
  5690                        
  5691 00:C740: 30 32              BMI   LAB_269B          ; do overflow error
  5692                        
  5693 00:C742: 18                 CLC                     ; clear carry for the add
  5694 00:C743: 80 02              BRA   LAB_2680b         ; branch around next instruction, saves one clock cycle
  5695                        LAB_2680
  5696 00:C745: 10 12              BPL   LAB_2696          ; if +ve go handle underflow
  5697                        LAB_2680b
  5698 00:C747: 69 80              ADC   #$80              ; adjust exponent
  5699 00:C749: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5700 00:C74B: D0 03              BNE   LAB_268B          ; branch if not zero
  5701                        
  5702 00:C74D: 4C DC C5           JMP   LAB_24F5          ; save FAC1 sign and return
  5703                        
  5704                        LAB_268B
  5705 00:C750: A5 6A              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
  5706 00:C752: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5707                        LAB_268F
  5708 00:C754: 60                 RTS
  5709                        
  5710                        ; handle overflow and underflow
  5711                        
  5712                        LAB_2690
  5713 00:C755: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5714 00:C757: 10 1B              BPL   LAB_269B          ; do overflow error
  5715                        
  5716                                                      ; handle underflow
  5717                        LAB_2696
  5718 00:C759: 68                 PLA                     ; pop return address low byte
  5719 00:C75A: 68                 PLA                     ; pop return address high byte
  5720 00:C75B: 4C D8 C5           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
  5721                        
  5722                        ; multiply by 10
  5723                        
  5724                        LAB_269E
  5725 00:C75E: 20 4F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  5726 00:C761: AA                 TAX                     ; copy exponent (set the flags)
  5727 00:C762: F0 F0              BEQ   LAB_268F          ; exit if zero
  Mon Feb  8 2021  9:20                                                                                                    Page 92


  5728                        
  5729 00:C764: 18                 CLC                     ; clear carry for add
  5730 00:C765: 69 02              ADC   #$02              ; add two to exponent (*4)
  5731 00:C767: B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
  5732                        
  5733 00:C769: A2 00              LDX   #$00              ; clear byte
  5734 00:C76B: 86 6A              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  5735 00:C76D: 20 67 C5           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
  5736 00:C770: E6 5E              INC   FAC1_e            ; increment FAC1 exponent (*10)
  5737 00:C772: D0 E0              BNE   LAB_268F          ; if non zero just do RTS
  5738                        
  5739                        LAB_269B
  5740 00:C774: 4C 4B C6           JMP   LAB_2564          ; do overflow error and warm start
  5741                        
  5742                        ; divide by 10
  5743                        
  5744                        LAB_26B9
  5745 00:C777: 20 4F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  5746 00:C77A: A9 81              LDA   #<LAB_26B5        ; set pointer to 10d low addr
  5747 00:C77C: A0 D1              LDY   #>LAB_26B5        ; set pointer to 10d high addr
  5748 00:C77E: A2 00              LDX   #$00              ; clear sign
  5749                        
  5750                        ; divide by (AY) (X=sign)
  5751                        
  5752                        LAB_26C2
  5753 00:C780: 86 6A              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5754 00:C782: 20 02 C8           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  5755 00:C785: 80 03              BRA   LAB_DIVIDE        ; do FAC2/FAC1
  5756                        
  5757                                                      ; Perform divide-by
  5758                        ; convert AY and do (AY)/FAC1
  5759                        
  5760                        LAB_26CA
  5761 00:C787: 20 11 C7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5762                        
  5763                                                      ; Perform divide-into
  5764                        LAB_DIVIDE
  5765 00:C78A: F0 62              BEQ   LAB_2737          ; if zero go do /0 error
  5766                        
  5767 00:C78C: 20 5E C8           JSR   LAB_27BA          ; round FAC1
  5768 00:C78F: A9 00              LDA   #$00              ; clear A
  5769 00:C791: 38                 SEC                     ; set carry for subtract
  5770 00:C792: E5 5E              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
  5771 00:C794: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5772 00:C796: 20 37 C7           JSR   LAB_2673          ; test and adjust accumulators
  5773 00:C799: E6 5E              INC   FAC1_e            ; increment FAC1 exponent
  5774 00:C79B: F0 D7              BEQ   LAB_269B          ; if zero do overflow error
  5775                        
  5776 00:C79D: A2 FF              LDX   #$FF              ; set index for pre increment
  5777 00:C79F: A9 01              LDA   #$01              ; set bit to flag byte save
  5778                        LAB_26E4
  5779 00:C7A1: A4 66              LDY   FAC2_1            ; get FAC2 mantissa1
  5780 00:C7A3: C4 5F              CPY   FAC1_1            ; compare FAC1 mantissa1
  5781 00:C7A5: D0 0A              BNE   LAB_26F4          ; branch if <>
  5782                        
  5783 00:C7A7: A4 67              LDY   FAC2_2            ; get FAC2 mantissa2
  5784 00:C7A9: C4 60              CPY   FAC1_2            ; compare FAC1 mantissa2
  5785 00:C7AB: D0 04              BNE   LAB_26F4          ; branch if <>
  5786                        
  5787 00:C7AD: A4 68              LDY   FAC2_3            ; get FAC2 mantissa3
  5788 00:C7AF: C4 61              CPY   FAC1_3            ; compare FAC1 mantissa3
  5789                        LAB_26F4
  5790 00:C7B1: 08                 PHP                     ; save FAC2-FAC1 compare status
  Mon Feb  8 2021  9:20                                                                                                    Page 93


  5791 00:C7B2: 2A                 ROL                     ; shift the result byte
  5792 00:C7B3: 90 0E              BCC   LAB_2702          ; if no carry skip the byte save
  5793                        
  5794 00:C7B5: A0 01              LDY   #$01              ; set bit to flag byte save
  5795 00:C7B7: E8                 INX                     ; else increment the index to FACt
  5796 00:C7B8: E0 02              CPX   #$02              ; compare with the index to FACt_3
  5797 00:C7BA: 30 04              BMI   LAB_2701          ; if not last byte just go save it
  5798                        
  5799 00:C7BC: D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
  5800                                                      ; return
  5801                        
  5802 00:C7BE: A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
  5803                        LAB_2701
  5804 00:C7C0: 95 27              STA   FACt_1,X          ; write result byte to FACt_1 + index
  5805 00:C7C2: 98                 TYA                     ; copy the next save byte flag
  5806                        LAB_2702
  5807 00:C7C3: 28                 PLP                     ; restore FAC2-FAC1 compare status
  5808 00:C7C4: 90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
  5809                        
  5810 00:C7C6: A8                 TAY                     ; save FAC2-FAC1 compare status
  5811 00:C7C7: A5 68              LDA   FAC2_3            ; get FAC2 mantissa3
  5812 00:C7C9: E5 61              SBC   FAC1_3            ; subtract FAC1 mantissa3
  5813 00:C7CB: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  5814 00:C7CD: A5 67              LDA   FAC2_2            ; get FAC2 mantissa2
  5815 00:C7CF: E5 60              SBC   FAC1_2            ; subtract FAC1 mantissa2
  5816 00:C7D1: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  5817 00:C7D3: A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
  5818 00:C7D5: E5 5F              SBC   FAC1_1            ; subtract FAC1 mantissa1
  5819 00:C7D7: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  5820 00:C7D9: 98                 TYA                     ; restore FAC2-FAC1 compare status
  5821                        
  5822                                                      ; FAC2 = FAC2*2
  5823                        LAB_2704
  5824 00:C7DA: 06 68              ASL   FAC2_3            ; shift FAC2 mantissa3
  5825 00:C7DC: 26 67              ROL   FAC2_2            ; shift FAC2 mantissa2
  5826 00:C7DE: 26 66              ROL   FAC2_1            ; shift FAC2 mantissa1
  5827 00:C7E0: B0 CF              BCS   LAB_26F4          ; loop with no compare
  5828                        
  5829 00:C7E2: 30 BD              BMI   LAB_26E4          ; loop with compare
  5830 00:C7E4: 80 CB              BRA   LAB_26F4          ; loop always with no compare
  5831                        
  5832                        ; do A<<6, save as FAC1 rounding byte, normalise and return
  5833                        
  5834                        LAB_272B
  5835 00:C7E6: 4A                 LSR                     ; shift b1 - b0 ..
  5836 00:C7E7: 6A                 ROR                     ; ..
  5837 00:C7E8: 6A                 ROR                     ; .. to b7 - b6
  5838 00:C7E9: 85 6B              STA   FAC1_r            ; save FAC1 rounding byte
  5839 00:C7EB: 28                 PLP                     ; dump FAC2-FAC1 compare status
  5840 00:C7EC: 80 05              BRA   LAB_273C          ; copy temp to FAC1, normalise and return
  5841                        
  5842                        ; do "Divide by zero" error
  5843                        
  5844                        LAB_2737
  5845 00:C7EE: A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
  5846 00:C7F0: 4C 01 B1           JMP   LAB_XERR          ; do error #X, then warm start
  5847                        
  5848                        ; copy temp to FAC1 and normalise
  5849                        
  5850                        LAB_273C
  5851 00:C7F3: A5 27              LDA   FACt_1            ; get temp mantissa1
  5852 00:C7F5: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5853 00:C7F7: A5 28              LDA   FACt_2            ; get temp mantissa2
  Mon Feb  8 2021  9:20                                                                                                    Page 94


  5854 00:C7F9: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5855 00:C7FB: A5 29              LDA   FACt_3            ; get temp mantissa3
  5856 00:C7FD: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5857 00:C7FF: 4C BC C5           JMP   LAB_24D5          ; normalise FAC1 and return
  5858                        
  5859                        ; unpack memory (AY) into FAC1
  5860                        
  5861                        LAB_UFAC
  5862 00:C802: 85 23              STA   ut1_pl            ; save pointer low byte
  5863 00:C804: 84 24              STY   ut1_ph            ; save pointer high byte
  5864 00:C806: A0 03              LDY   #$03              ; 4 bytes to do
  5865 00:C808: B1 23              LDA   (ut1_pl),Y        ; get last byte
  5866 00:C80A: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  5867 00:C80C: 88                 DEY                     ; decrement index
  5868 00:C80D: B1 23              LDA   (ut1_pl),Y        ; get last-1 byte
  5869 00:C80F: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  5870 00:C811: 88                 DEY                     ; decrement index
  5871 00:C812: B1 23              LDA   (ut1_pl),Y        ; get second byte
  5872 00:C814: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  5873 00:C816: 09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
  5874 00:C818: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5875 00:C81A: 88                 DEY                     ; decrement index
  5876 00:C81B: B1 23              LDA   (ut1_pl),Y        ; get first byte (exponent)
  5877 00:C81D: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  5878 00:C81F: 84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
  5879 00:C821: 60                 RTS
  5880                        
  5881                        ; pack FAC1 into Adatal
  5882                        
  5883                        LAB_276E
  5884 00:C822: A2 56              LDX   #<Adatal          ; set pointer low byte
  5885                        LAB_2770
  5886 00:C824: A0 00              LDY   #>Adatal          ; set pointer high byte
  5887 00:C826: F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
  5888                        
  5889                        ; pack FAC1 into (Lvarpl)
  5890                        
  5891                        LAB_PFAC
  5892 00:C828: A6 49              LDX   Lvarpl            ; get destination pointer low byte
  5893 00:C82A: A4 4A              LDY   Lvarph            ; get destination pointer high byte
  5894                        
  5895                        ; pack FAC1 into (XY)
  5896                        
  5897                        LAB_2778
  5898 00:C82C: 20 5E C8           JSR   LAB_27BA          ; round FAC1
  5899 00:C82F: 86 23              STX   ut1_pl            ; save pointer low byte
  5900 00:C831: 84 24              STY   ut1_ph            ; save pointer high byte
  5901 00:C833: A0 03              LDY   #$03              ; set index
  5902 00:C835: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  5903 00:C837: 91 23              STA   (ut1_pl),Y        ; store in destination
  5904 00:C839: 88                 DEY                     ; decrement index
  5905 00:C83A: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  5906 00:C83C: 91 23              STA   (ut1_pl),Y        ; store in destination
  5907 00:C83E: 88                 DEY                     ; decrement index
  5908 00:C83F: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  5909 00:C841: 09 7F              ORA   #$7F              ; set bits x111 1111
  5910 00:C843: 25 5F              AND   FAC1_1            ; AND in FAC1 mantissa1
  5911 00:C845: 91 23              STA   (ut1_pl),Y        ; store in destination
  5912 00:C847: 88                 DEY                     ; decrement index
  5913 00:C848: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5914 00:C84A: 91 23              STA   (ut1_pl),Y        ; store in destination
  5915 00:C84C: 84 6B              STY   FAC1_r            ; clear FAC1 rounding byte
  5916 00:C84E: 60                 RTS
  Mon Feb  8 2021  9:20                                                                                                    Page 95


  5917                        
  5918                        ; round and copy FAC1 to FAC2
  5919                        
  5920                        LAB_27AB
  5921 00:C84F: 20 5E C8           JSR   LAB_27BA          ; round FAC1
  5922                        
  5923                        ; copy FAC1 to FAC2
  5924                        
  5925                        LAB_27AE
  5926 00:C852: A2 05              LDX   #$05              ; 5 bytes to copy
  5927                        LAB_27B0
  5928 00:C854: B5 5D              LDA   FAC1_e-1,X        ; get byte from FAC1,X
  5929 00:C856: 95 64              STA   FAC1_o,X          ; save byte at FAC2,X
  5930 00:C858: CA                 DEX                     ; decrement count
  5931 00:C859: D0 F9              BNE   LAB_27B0          ; loop if not all done
  5932                        
  5933 00:C85B: 86 6B              STX   FAC1_r            ; clear FAC1 rounding byte
  5934                        LAB_27B9
  5935 00:C85D: 60                 RTS
  5936                        
  5937                        ; round FAC1
  5938                        
  5939                        LAB_27BA
  5940 00:C85E: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5941 00:C860: F0 FB              BEQ   LAB_27B9          ; exit if zero
  5942                        
  5943 00:C862: 06 6B              ASL   FAC1_r            ; shift FAC1 rounding byte
  5944 00:C864: 90 F7              BCC   LAB_27B9          ; exit if no overflow
  5945                        
  5946                        ; round FAC1 (no check)
  5947                        
  5948                        LAB_27C2
  5949 00:C866: 20 40 C6           JSR   LAB_2559          ; increment FAC1 mantissa
  5950 00:C869: D0 F2              BNE   LAB_27B9          ; branch if no overflow
  5951                        
  5952 00:C86B: 4C 11 C6           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
  5953                        
  5954                        ; get FAC1 sign
  5955                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5956                        
  5957                        LAB_27CA
  5958 00:C86E: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  5959 00:C870: F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
  5960                        
  5961                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5962                        ; no = 0 check
  5963                        
  5964                        LAB_27CE
  5965 00:C872: A5 62              LDA   FAC1_s            ; else get FAC1 sign (b7)
  5966                        
  5967                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5968                        ; no = 0 check, sign in A
  5969                        
  5970                        LAB_27D0
  5971 00:C874: 2A                 ROL                     ; move sign bit to carry
  5972 00:C875: A9 FF              LDA   #$FF              ; set byte for -ve result
  5973 00:C877: B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
  5974                        
  5975 00:C879: A9 01              LDA   #$01              ; else set byte for +ve result
  5976                        LAB_27D7
  5977 00:C87B: 60                 RTS
  5978                        
  5979                        ; perform SGN()
  Mon Feb  8 2021  9:20                                                                                                    Page 96


  5980                        
  5981                        LAB_SGN
  5982 00:C87C: 20 6E C8           JSR   LAB_27CA          ; get FAC1 sign
  5983                                                      ; return A=$FF/-ve A=$01/+ve
  5984                        ; save A as integer byte
  5985                        
  5986                        LAB_27DB
  5987 00:C87F: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  5988 00:C881: 64 60              STZ   FAC1_2            ; clear FAC1 mantissa2
  5989 00:C883: A2 88              LDX   #$88              ; set exponent
  5990                        
  5991                        ; set exp=X, clearFAC1 mantissa3 and normalise
  5992                        
  5993                        LAB_27E3
  5994 00:C885: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  5995 00:C887: 49 FF              EOR   #$FF              ; complement it
  5996 00:C889: 2A                 ROL                     ; sign bit into carry
  5997                        
  5998                        ; set exp=X, clearFAC1 mantissa3 and normalise
  5999                        
  6000                        LAB_STFA
  6001 00:C88A: 64 61              STZ   FAC1_3            ; clear FAC1 mantissa3
  6002 00:C88C: 86 5E              STX   FAC1_e            ; set FAC1 exponent
  6003 00:C88E: 64 6B              STZ   FAC1_r            ; clear FAC1 rounding byte
  6004 00:C890: 64 62              STZ   FAC1_s            ; clear FAC1 sign (b7)
  6005 00:C892: 4C B7 C5           JMP   LAB_24D0          ; do ABS and normalise FAC1
  6006                        
  6007                        ; perform ABS()
  6008                        
  6009                        LAB_ABS
  6010 00:C895: 46 62              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
  6011 00:C897: 60                 RTS
  6012                        
  6013                        ; compare FAC1 with (AY)
  6014                        ; returns A=$00 if FAC1 = (AY)
  6015                        ; returns A=$01 if FAC1 > (AY)
  6016                        ; returns A=$FF if FAC1 < (AY)
  6017                        
  6018                        LAB_27F8
  6019 00:C898: 85 25              STA   ut2_pl            ; save pointer low byte
  6020                        LAB_27FA
  6021 00:C89A: 84 26              STY   ut2_ph            ; save pointer high byte
  6022 00:C89C: A0 00              LDY   #$00              ; clear index
  6023 00:C89E: B1 25              LDA   (ut2_pl),Y        ; get exponent
  6024 00:C8A0: C8                 INY                     ; increment index
  6025 00:C8A1: AA                 TAX                     ; copy (AY) exponent to X
  6026 00:C8A2: F0 CA              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
  6027                                                      ; A=FF,C=1/-ve A=01,C=0/+ve
  6028                        
  6029 00:C8A4: B1 25              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
  6030 00:C8A6: 45 62              EOR   FAC1_s            ; EOR FAC1 sign (b7)
  6031 00:C8A8: 30 C8              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
  6032                                                      ; A=01,C=0/+ve and return
  6033                        
  6034 00:C8AA: E4 5E              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
  6035 00:C8AC: D0 1A              BNE   LAB_2828          ; branch if different
  6036                        
  6037 00:C8AE: B1 25              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
  6038 00:C8B0: 09 80              ORA   #$80              ; normalise top bit
  6039 00:C8B2: C5 5F              CMP   FAC1_1            ; compare with FAC1 mantissa1
  6040 00:C8B4: D0 12              BNE   LAB_2828          ; branch if different
  6041                        
  6042 00:C8B6: C8                 INY                     ; increment index
  Mon Feb  8 2021  9:20                                                                                                    Page 97


  6043 00:C8B7: B1 25              LDA   (ut2_pl),Y        ; get mantissa2
  6044 00:C8B9: C5 60              CMP   FAC1_2            ; compare with FAC1 mantissa2
  6045 00:C8BB: D0 0B              BNE   LAB_2828          ; branch if different
  6046                        
  6047 00:C8BD: C8                 INY                     ; increment index
  6048 00:C8BE: A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
  6049 00:C8C0: C5 6B              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
  6050 00:C8C2: B1 25              LDA   (ut2_pl),Y        ; get mantissa3
  6051 00:C8C4: E5 61              SBC   FAC1_3            ; subtract FAC1 mantissa3
  6052 00:C8C6: F0 27              BEQ   LAB_2850          ; exit if mantissa3 equal
  6053                        
  6054                        ; gets here if number <> FAC1
  6055                        
  6056                        LAB_2828
  6057 00:C8C8: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6058 00:C8CA: 90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
  6059                        
  6060 00:C8CC: 49 FF              EOR   #$FF              ; else toggle FAC1 sign
  6061                        LAB_282E
  6062 00:C8CE: 80 A4              BRA   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
  6063                        
  6064                        ; convert FAC1 floating-to-fixed
  6065                        
  6066                        LAB_2831
  6067 00:C8D0: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6068 00:C8D2: F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
  6069                        
  6070 00:C8D4: 38                 SEC                     ; set carry for subtract
  6071 00:C8D5: E9 98              SBC   #$98              ; subtract maximum integer range exponent
  6072 00:C8D7: 24 62              BIT   FAC1_s            ; test FAC1 sign (b7)
  6073 00:C8D9: 10 09              BPL   LAB_2845          ; branch if FAC1 +ve
  6074                        
  6075                                                      ; FAC1 was -ve
  6076 00:C8DB: AA                 TAX                     ; copy subtracted exponent
  6077 00:C8DC: A9 FF              LDA   #$FF              ; overflow for -ve number
  6078 00:C8DE: 85 64              STA   FAC1_o            ; set FAC1 overflow byte
  6079 00:C8E0: 20 24 C6           JSR   LAB_253D          ; twos complement FAC1 mantissa
  6080 00:C8E3: 8A                 TXA                     ; restore subtracted exponent
  6081                        LAB_2845
  6082 00:C8E4: A2 5E              LDX   #FAC1_e           ; set index to FAC1
  6083 00:C8E6: C9 F9              CMP   #$F9              ; compare exponent result
  6084 00:C8E8: 10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
  6085                        
  6086 00:C8EA: 20 62 C6           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
  6087 00:C8ED: 84 64              STY   FAC1_o            ; clear FAC1 overflow byte
  6088                        LAB_2850
  6089 00:C8EF: 60                 RTS
  6090                        
  6091                        ; shift FAC1 A times right
  6092                        
  6093                        LAB_2851
  6094 00:C8F0: A8                 TAY                     ; copy shift count
  6095 00:C8F1: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6096 00:C8F3: 29 80              AND   #$80              ; mask sign bit only (x000 0000)
  6097 00:C8F5: 46 5F              LSR   FAC1_1            ; shift FAC1 mantissa1
  6098 00:C8F7: 05 5F              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
  6099 00:C8F9: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  6100 00:C8FB: 20 79 C6           JSR   LAB_2592          ; shift FAC1 Y times right
  6101 00:C8FE: 84 64              STY   FAC1_o            ; clear FAC1 overflow byte
  6102 00:C900: 60                 RTS
  6103                        
  6104                        ; perform INT()
  6105                        
  Mon Feb  8 2021  9:20                                                                                                    Page 98


  6106                        LAB_INT
  6107 00:C901: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6108 00:C903: C9 98              CMP   #$98              ; compare with max int
  6109 00:C905: B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
  6110                        
  6111 00:C907: 20 D0 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  6112 00:C90A: 84 6B              STY   FAC1_r            ; save FAC1 rounding byte
  6113 00:C90C: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6114 00:C90E: 84 62              STY   FAC1_s            ; save FAC1 sign (b7)
  6115 00:C910: 49 80              EOR   #$80              ; toggle FAC1 sign
  6116 00:C912: 2A                 ROL                     ; shift into carry
  6117 00:C913: A9 98              LDA   #$98              ; set new exponent
  6118 00:C915: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  6119 00:C917: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  6120 00:C919: 85 0D              STA   Temp3             ; save for EXP() function
  6121 00:C91B: 4C B7 C5           JMP   LAB_24D0          ; do ABS and normalise FAC1
  6122                        
  6123                        ; clear FAC1 and return
  6124                        
  6125                        LAB_287F
  6126 00:C91E: 85 5F              STA   FAC1_1            ; clear FAC1 mantissa1
  6127 00:C920: 85 60              STA   FAC1_2            ; clear FAC1 mantissa2
  6128 00:C922: 85 61              STA   FAC1_3            ; clear FAC1 mantissa3
  6129 00:C924: A8                 TAY                     ; clear Y
  6130                        LAB_2886
  6131 00:C925: 60                 RTS
  6132                        
  6133                        ; get FAC1 from string
  6134                        ; this routine now handles hex and binary values from strings
  6135                        ; starting with "$" and "%" respectively
  6136                        
  6137                        LAB_2887
  6138 00:C926: 64 11              STZ   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  6139 00:C928: A2 09              LDX   #$09              ; set index
  6140                        LAB_288B
  6141 00:C92A: 74 5A              STZ   numexp,X          ; clear byte
  6142 00:C92C: CA                 DEX                     ; decrement index
  6143 00:C92D: 10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
  6144 00:C92F: 90 7E              BCC   LAB_28FE          ; branch if 1st character numeric
  6145                        
  6146                        ; get FAC1 from string .. first character wasn't numeric
  6147                        
  6148 00:C931: C9 2D              CMP   #'-'              ; else compare with "-"
  6149 00:C933: D0 04              BNE   LAB_289A          ; branch if not "-"
  6150                        
  6151 00:C935: 86 63              STX   negnum            ; set flag for -ve number (X = $FF)
  6152 00:C937: 80 04              BRA   LAB_289C          ; branch always (go scan and check for hex/bin)
  6153                        
  6154                        ; get FAC1 from string .. first character wasn't numeric or -
  6155                        
  6156                        LAB_289A
  6157 00:C939: C9 2B              CMP   #'+'              ; else compare with "+"
  6158 00:C93B: D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
  6159                        
  6160                        ; was "+" or "-" to start, so get next character
  6161                        
  6162                        LAB_289C
  6163 00:C93D: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  6164 00:C940: 90 6D              BCC   LAB_28FE          ; branch if numeric character
  6165                        
  6166                        ; code here for hex and binary numbers
  6167                        
  6168                        LAB_289D
  Mon Feb  8 2021  9:20                                                                                                    Page 99


  6169 00:C942: C9 24              CMP   #'$'              ; else compare with "$"
  6170 00:C944: D0 03              BNE   LAB_NHEX          ; branch if not "$"
  6171                        
  6172 00:C946: 4C E0 CD           JMP   LAB_CHEX          ; branch if "$"
  6173                        
  6174                        LAB_NHEX
  6175 00:C949: C9 25              CMP   #'%'              ; else compare with "%"
  6176 00:C94B: D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
  6177                        
  6178 00:C94D: 4C 0E CE           JMP   LAB_CBIN          ; branch if "%"
  6179                        
  6180                        LAB_289E
  6181 00:C950: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
  6182                        LAB_28A1
  6183 00:C953: 90 5A              BCC   LAB_28FE          ; branch if numeric character
  6184                        
  6185                        ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
  6186                        
  6187                        LAB_28A3
  6188 00:C955: C9 2E              CMP   #'.'              ; else compare with "."
  6189 00:C957: F0 2D              BEQ   LAB_28D5          ; branch if "."
  6190                        
  6191                        ; get FAC1 from string .. character wasn't numeric, -, + or .
  6192                        
  6193 00:C959: C9 45              CMP   #'E'              ; else compare with "E"
  6194 00:C95B: D0 2F              BNE   LAB_28DB          ; branch if not "E"
  6195                        
  6196                                                      ; was "E" so evaluate exponential part
  6197 00:C95D: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  6198 00:C960: 90 17              BCC   LAB_28C7          ; branch if numeric character
  6199                        
  6200 00:C962: C9 B3              CMP   #TK_MINUS         ; else compare with token for -
  6201 00:C964: F0 0E              BEQ   LAB_28C2          ; branch if token for -
  6202                        
  6203 00:C966: C9 2D              CMP   #'-'              ; else compare with "-"
  6204 00:C968: F0 0A              BEQ   LAB_28C2          ; branch if "-"
  6205                        
  6206 00:C96A: C9 B2              CMP   #TK_PLUS          ; else compare with token for +
  6207 00:C96C: F0 08              BEQ   LAB_28C4          ; branch if token for +
  6208                        
  6209 00:C96E: C9 2B              CMP   #'+'              ; else compare with "+"
  6210 00:C970: F0 04              BEQ   LAB_28C4          ; branch if "+"
  6211 00:C972: 80 07              BRA   LAB_28C9          ; branch always
  6212                        
  6213                        LAB_28C2
  6214 00:C974: 66 5D              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
  6215                        LAB_28C4
  6216 00:C976: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  6217                        LAB_28C7
  6218 00:C979: 90 59              BCC   LAB_2925          ; branch if numeric character
  6219                        
  6220                        LAB_28C9
  6221 00:C97B: 24 5D              BIT   expneg            ; test exponent -ve flag
  6222 00:C97D: 10 0D              BPL   LAB_28DB          ; if +ve go evaluate exponent
  6223                        
  6224                                                      ; else do exponent = -exponent
  6225 00:C97F: A9 00              LDA   #$00              ; clear result
  6226 00:C981: 38                 SEC                     ; set carry for subtract
  6227 00:C982: E5 5B              SBC   expcnt            ; subtract exponent byte
  6228 00:C984: 80 08              BRA   LAB_28DD          ; go evaluate exponent
  6229                        
  6230                        LAB_28D5
  6231 00:C986: 66 5C              ROR   numdpf            ; set decimal point flag
  Mon Feb  8 2021  9:20                                                                                                    Page 100


  6232 00:C988: 24 5C              BIT   numdpf            ; test decimal point flag
  6233 00:C98A: 50 C4              BVC   LAB_289E          ; branch if only one decimal point so far
  6234                        
  6235                                                      ; evaluate exponent
  6236                        LAB_28DB
  6237 00:C98C: A5 5B              LDA   expcnt            ; get exponent count byte
  6238                        LAB_28DD
  6239 00:C98E: 38                 SEC                     ; set carry for subtract
  6240 00:C98F: E5 5A              SBC   numexp            ; subtract numerator exponent
  6241 00:C991: 85 5B              STA   expcnt            ; save exponent count byte
  6242 00:C993: F0 12              BEQ   LAB_28F6          ; branch if no adjustment
  6243 00:C995: 10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
  6244                        
  6245                                                      ; else go do FAC1/10^(0-expcnt)
  6246                        LAB_28E6
  6247 00:C997: 20 77 C7           JSR   LAB_26B9          ; divide by 10
  6248 00:C99A: E6 5B              INC   expcnt            ; increment exponent count byte
  6249 00:C99C: D0 F9              BNE   LAB_28E6          ; loop until all done
  6250 00:C99E: 80 07              BRA   LAB_28F6          ; branch always
  6251                        
  6252                        LAB_28EF
  6253 00:C9A0: 20 5E C7           JSR   LAB_269E          ; multiply by 10
  6254 00:C9A3: C6 5B              DEC   expcnt            ; decrement exponent count byte
  6255 00:C9A5: D0 F9              BNE   LAB_28EF          ; loop until all done
  6256                        
  6257                        LAB_28F6
  6258 00:C9A7: A5 63              LDA   negnum            ; get -ve flag
  6259 00:C9A9: 30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
  6260 00:C9AB: 60                 RTS
  6261                        
  6262                        ; do - FAC1 and return
  6263                        
  6264                        LAB_28FB
  6265 00:C9AC: 4C 6D CB           JMP   LAB_GTHAN         ; do - FAC1 and return
  6266                        
  6267                        ; do unsigned FAC1*10+number
  6268                        
  6269                        LAB_28FE
  6270 00:C9AF: 48                 PHA                     ; save character
  6271 00:C9B0: 24 5C              BIT   numdpf            ; test decimal point flag
  6272 00:C9B2: 10 02              BPL   LAB_2905          ; skip exponent increment if not set
  6273                        
  6274 00:C9B4: E6 5A              INC   numexp            ; else increment number exponent
  6275                        LAB_2905
  6276 00:C9B6: 20 5E C7           JSR   LAB_269E          ; multiply FAC1 by 10
  6277 00:C9B9: 68                 PLA                     ; restore character
  6278 00:C9BA: 29 0F              AND   #$0F              ; convert to binary
  6279 00:C9BC: 20 C1 C9           JSR   LAB_2912          ; evaluate new ASCII digit
  6280 00:C9BF: 80 8F              BRA   LAB_289E          ; go do next character
  6281                        
  6282                        ; evaluate new ASCII digit
  6283                        
  6284                        LAB_2912
  6285 00:C9C1: 48                 PHA                     ; save digit
  6286 00:C9C2: 20 4F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6287 00:C9C5: 68                 PLA                     ; restore digit
  6288 00:C9C6: 20 7F C8           JSR   LAB_27DB          ; save A as integer byte
  6289 00:C9C9: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  6290 00:C9CB: 45 62              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
  6291 00:C9CD: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  6292 00:C9CF: A6 5E              LDX   FAC1_e            ; get FAC1 exponent
  6293 00:C9D1: 4C 4D C5           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
  6294                        
  Mon Feb  8 2021  9:20                                                                                                    Page 101


  6295                        ; evaluate next character of exponential part of number
  6296                        
  6297                        LAB_2925
  6298 00:C9D4: A5 5B              LDA   expcnt            ; get exponent count byte
  6299 00:C9D6: C9 0A              CMP   #$0A              ; compare with 10 decimal
  6300 00:C9D8: 90 09              BCC   LAB_2934          ; branch if less
  6301                        
  6302 00:C9DA: A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
  6303 00:C9DC: 24 5D              BIT   expneg            ; test exponent -ve flag
  6304 00:C9DE: 30 0C              BMI   LAB_2942          ; branch if -ve
  6305                        
  6306 00:C9E0: 4C 4B C6           JMP   LAB_2564          ; else do overflow error
  6307                        
  6308                        LAB_2934
  6309 00:C9E3: 0A                 ASL                     ; * 2
  6310 00:C9E4: 0A                 ASL                     ; * 4
  6311 00:C9E5: 65 5B              ADC   expcnt            ; * 5
  6312 00:C9E7: 0A                 ASL                     ; * 10
  6313 00:C9E8: 72 6E              ADC   (Bpntrl)          ; add character (will be $30 too much!)
  6314 00:C9EA: E9 2F              SBC   #'0'-1            ; convert character to binary
  6315                        LAB_2942
  6316 00:C9EC: 85 5B              STA   expcnt            ; save exponent count byte
  6317 00:C9EE: 80 86              BRA   LAB_28C4          ; go get next character
  6318                        
  6319                        ; print " in line [LINE #]"
  6320                        
  6321                        LAB_2953
  6322 00:C9F0: A9 56              LDA   #<LAB_LMSG        ; point to " in line " message low byte
  6323 00:C9F2: A0 D7              LDY   #>LAB_LMSG        ; point to " in line " message high byte
  6324 00:C9F4: 20 73 B8           JSR   LAB_18C3          ; print null terminated string from memory
  6325                        
  6326                                                      ; print Basic line #
  6327 00:C9F7: A5 3A              LDA   Clineh            ; get current line high byte
  6328 00:C9F9: A6 39              LDX   Clinel            ; get current line low byte
  6329                        
  6330                        ; print XA as unsigned integer
  6331                        
  6332                        LAB_295E
  6333 00:C9FB: 85 5F              STA   FAC1_1            ; save low byte as FAC1 mantissa1
  6334 00:C9FD: 86 60              STX   FAC1_2            ; save high byte as FAC1 mantissa2
  6335 00:C9FF: A2 90              LDX   #$90              ; set exponent to 16d bits
  6336 00:CA01: 38                 SEC                     ; set integer is +ve flag
  6337 00:CA02: 20 8A C8           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
  6338 00:CA05: A0 00              LDY   #$00              ; clear index
  6339 00:CA07: 98                 TYA                     ; clear A
  6340 00:CA08: 20 1B CA           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
  6341 00:CA0B: 4C 73 B8           JMP   LAB_18C3          ; print null terminated string from memory and return
  6342                        
  6343                        ; convert FAC1 to ASCII string result in (AY)
  6344                        ; not any more, moved scratchpad to page 0
  6345                        
  6346                        LAB_296E
  6347 00:CA0E: A0 01              LDY   #$01              ; set index = 1
  6348 00:CA10: A9 20              LDA   #$20              ; character = " " (assume +ve)
  6349 00:CA12: 24 62              BIT   FAC1_s            ; test FAC1 sign (b7)
  6350 00:CA14: 10 02              BPL   LAB_2978          ; branch if +ve
  6351                        
  6352 00:CA16: A9 2D              LDA   #$2D              ; else character = "-"
  6353                        LAB_2978
  6354 00:CA18: 99 74 00           STA   Decss,Y           ; save leading character (" " or "-")
  6355                        LAB_297B
  6356 00:CA1B: 85 62              STA   FAC1_s            ; clear FAC1 sign (b7)
  6357 00:CA1D: 84 6C              STY   Sendl             ; save index
  Mon Feb  8 2021  9:20                                                                                                    Page 102


  6358 00:CA1F: C8                 INY                     ; increment index
  6359 00:CA20: A6 5E              LDX   FAC1_e            ; get FAC1 exponent
  6360 00:CA22: D0 05              BNE   LAB_2989          ; branch if FAC1<>0
  6361                        
  6362                                                      ; exponent was $00 so FAC1 is 0
  6363 00:CA24: A9 30              LDA   #'0'              ; set character = "0"
  6364 00:CA26: 4C 27 CB           JMP   LAB_2A89          ; save last character, [EOT] and exit
  6365                        
  6366                                                      ; FAC1 is some non zero value
  6367                        LAB_2989
  6368 00:CA29: A9 00              LDA   #$00              ; clear (number exponent count)
  6369 00:CA2B: E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
  6370                        
  6371 00:CA2D: B0 09              BCS   LAB_299A          ; branch if FAC1=>1
  6372                        
  6373                                                      ; FAC1<1
  6374 00:CA2F: A9 11              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
  6375 00:CA31: A0 D1              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
  6376 00:CA33: 20 C1 C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6377 00:CA36: A9 FA              LDA   #$FA              ; set number exponent count (-6)
  6378                        LAB_299A
  6379 00:CA38: 85 5A              STA   numexp            ; save number exponent count
  6380                        LAB_299C
  6381 00:CA3A: A9 0D              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
  6382 00:CA3C: A0 D1              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
  6383 00:CA3E: 20 98 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6384 00:CA41: F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
  6385                        
  6386 00:CA43: 10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
  6387                        
  6388                                                      ; FAC1 < (AY)
  6389                        LAB_29A7
  6390 00:CA45: A9 09              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
  6391 00:CA47: A0 D1              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
  6392 00:CA49: 20 98 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6393 00:CA4C: F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
  6394 00:CA4E: 10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
  6395                        
  6396                                                      ; FAC1 <= (AY)
  6397                        LAB_29B2
  6398 00:CA50: 20 5E C7           JSR   LAB_269E          ; multiply by 10
  6399 00:CA53: C6 5A              DEC   numexp            ; decrement number exponent count
  6400 00:CA55: 80 EE              BRA   LAB_29A7          ; go test again (branch always)
  6401                        
  6402                        LAB_29B9
  6403 00:CA57: 20 77 C7           JSR   LAB_26B9          ; divide by 10
  6404 00:CA5A: E6 5A              INC   numexp            ; increment number exponent count
  6405 00:CA5C: 80 DC              BRA   LAB_299C          ; go test again (branch always)
  6406                        
  6407                        ; now we have just the digits to do
  6408                        
  6409                        LAB_29C0
  6410 00:CA5E: 20 46 C5           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
  6411                        LAB_29C3
  6412 00:CA61: 20 D0 C8           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  6413 00:CA64: A2 01              LDX   #$01              ; set default digits before dp = 1
  6414 00:CA66: A5 5A              LDA   numexp            ; get number exponent count
  6415 00:CA68: 18                 CLC                     ; clear carry for add
  6416 00:CA69: 69 07              ADC   #$07              ; up to 6 digits before point
  6417 00:CA6B: 30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
  6418                        
  6419 00:CA6D: C9 08              CMP   #$08              ; A>=8 if n>=1E6
  6420 00:CA6F: B0 06              BCS   LAB_29D9          ; branch if >= $08
  Mon Feb  8 2021  9:20                                                                                                    Page 103


  6421                        
  6422                                                      ; carry is clear
  6423 00:CA71: 69 FF              ADC   #$FF              ; take 1 from digit count
  6424 00:CA73: AA                 TAX                     ; copy to A
  6425 00:CA74: A9 02              LDA   #$02              ;.set exponent adjust
  6426                        LAB_29D8
  6427 00:CA76: 38                 SEC                     ; set carry for subtract
  6428                        LAB_29D9
  6429 00:CA77: E9 02              SBC   #$02              ; -2
  6430 00:CA79: 85 5B              STA   expcnt            ; save exponent adjust
  6431 00:CA7B: 86 5A              STX   numexp            ; save digits before dp count
  6432 00:CA7D: 8A                 TXA                     ; copy to A
  6433 00:CA7E: F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
  6434 00:CA80: 10 13              BPL   LAB_29F7          ; branch if digits before dp
  6435                        
  6436                        LAB_29E4
  6437 00:CA82: A4 6C              LDY   Sendl             ; get output string index
  6438 00:CA84: A9 2E              LDA   #$2E              ; character "."
  6439 00:CA86: C8                 INY                     ; increment index
  6440 00:CA87: 99 74 00           STA   Decss,Y           ; save to output string
  6441 00:CA8A: 8A                 TXA                     ;
  6442 00:CA8B: F0 06              BEQ   LAB_29F5          ;
  6443                        
  6444 00:CA8D: A9 30              LDA   #'0'              ; character "0"
  6445 00:CA8F: C8                 INY                     ; increment index
  6446 00:CA90: 99 74 00           STA   Decss,Y           ; save to output string
  6447                        LAB_29F5
  6448 00:CA93: 84 6C              STY   Sendl             ; save output string index
  6449                        LAB_29F7
  6450 00:CA95: A0 00              LDY   #$00              ; clear index (point to 100,000)
  6451 00:CA97: A2 80              LDX   #$80              ;
  6452                        LAB_29FB
  6453 00:CA99: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  6454 00:CA9B: 18                 CLC                     ; clear carry for add
  6455 00:CA9C: 79 87 D1           ADC   LAB_2A9C,Y        ; add -ve LSB
  6456 00:CA9F: 85 61              STA   FAC1_3            ; save FAC1 mantissa3
  6457 00:CAA1: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  6458 00:CAA3: 79 86 D1           ADC   LAB_2A9B,Y        ; add -ve NMSB
  6459 00:CAA6: 85 60              STA   FAC1_2            ; save FAC1 mantissa2
  6460 00:CAA8: A5 5F              LDA   FAC1_1            ; get FAC1 mantissa1
  6461 00:CAAA: 79 85 D1           ADC   LAB_2A9A,Y        ; add -ve MSB
  6462 00:CAAD: 85 5F              STA   FAC1_1            ; save FAC1 mantissa1
  6463 00:CAAF: E8                 INX                     ;
  6464 00:CAB0: B0 04              BCS   LAB_2A18          ;
  6465                        
  6466 00:CAB2: 10 E5              BPL   LAB_29FB          ; not -ve so try again
  6467                        
  6468 00:CAB4: 30 02              BMI   LAB_2A1A          ;
  6469                        
  6470                        LAB_2A18
  6471 00:CAB6: 30 E1              BMI   LAB_29FB          ;
  6472                        
  6473                        LAB_2A1A
  6474 00:CAB8: 8A                 TXA                     ;
  6475 00:CAB9: 90 04              BCC   LAB_2A21          ;
  6476                        
  6477 00:CABB: 49 FF              EOR   #$FF              ;
  6478 00:CABD: 69 0A              ADC   #$0A              ;
  6479                        LAB_2A21
  6480 00:CABF: 69 2F              ADC   #'0'-1            ; add "0"-1 to result
  6481 00:CAC1: C8                 INY                     ; increment index ..
  6482 00:CAC2: C8                 INY                     ; .. to next less ..
  6483 00:CAC3: C8                 INY                     ; .. power of ten
  Mon Feb  8 2021  9:20                                                                                                    Page 104


  6484 00:CAC4: 84 47              STY   Cvaral            ; save as current var address low byte
  6485 00:CAC6: A4 6C              LDY   Sendl             ; get output string index
  6486 00:CAC8: C8                 INY                     ; increment output string index
  6487 00:CAC9: AA                 TAX                     ; copy character to X
  6488 00:CACA: 29 7F              AND   #$7F              ; mask out top bit
  6489 00:CACC: 99 74 00           STA   Decss,Y           ; save to output string
  6490 00:CACF: C6 5A              DEC   numexp            ; decrement # of characters before the dp
  6491 00:CAD1: D0 06              BNE   LAB_2A3B          ; branch if still characters to do
  6492                        
  6493                                                      ; else output the point
  6494 00:CAD3: A9 2E              LDA   #$2E              ; character "."
  6495 00:CAD5: C8                 INY                     ; increment output string index
  6496 00:CAD6: 99 74 00           STA   Decss,Y           ; save to output string
  6497                        LAB_2A3B
  6498 00:CAD9: 84 6C              STY   Sendl             ; save output string index
  6499 00:CADB: A4 47              LDY   Cvaral            ; get current var address low byte
  6500 00:CADD: 8A                 TXA                     ; get character back
  6501 00:CADE: 49 FF              EOR   #$FF              ;
  6502 00:CAE0: 29 80              AND   #$80              ;
  6503 00:CAE2: AA                 TAX                     ;
  6504 00:CAE3: C0 12              CPY   #$12              ; compare index with max
  6505 00:CAE5: D0 B2              BNE   LAB_29FB          ; loop if not max
  6506                        
  6507                                                      ; now remove trailing zeroes
  6508 00:CAE7: A4 6C              LDY   Sendl             ; get output string index
  6509                        LAB_2A4B
  6510 00:CAE9: B9 74 00           LDA   Decss,Y           ; get character from output string
  6511 00:CAEC: 88                 DEY                     ; decrement output string index
  6512 00:CAED: C9 30              CMP   #'0'              ; compare with "0"
  6513 00:CAEF: F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
  6514                        
  6515 00:CAF1: C9 2E              CMP   #'.'              ; compare with "."
  6516 00:CAF3: F0 01              BEQ   LAB_2A58          ; branch if was dp
  6517                        
  6518                                                      ; restore last character
  6519 00:CAF5: C8                 INY                     ; increment output string index
  6520                        LAB_2A58
  6521 00:CAF6: A9 2B              LDA   #$2B              ; character "+"
  6522 00:CAF8: A6 5B              LDX   expcnt            ; get exponent count
  6523 00:CAFA: F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
  6524                        
  6525                                                      ; exponent isn't zero so write exponent
  6526 00:CAFC: 10 08              BPL   LAB_2A68          ; branch if exponent count +ve
  6527                        
  6528 00:CAFE: A9 00              LDA   #$00              ; clear A
  6529 00:CB00: 38                 SEC                     ; set carry for subtract
  6530 00:CB01: E5 5B              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
  6531 00:CB03: AA                 TAX                     ; copy exponent count to X
  6532 00:CB04: A9 2D              LDA   #'-'              ; character "-"
  6533                        LAB_2A68
  6534 00:CB06: 99 76 00           STA   Decss+2,Y         ; save to output string
  6535 00:CB09: A9 45              LDA   #$45              ; character "E"
  6536 00:CB0B: 99 75 00           STA   Decss+1,Y         ; save exponent sign to output string
  6537 00:CB0E: 8A                 TXA                     ; get exponent count back
  6538 00:CB0F: A2 2F              LDX   #'0'-1            ; one less than "0" character
  6539 00:CB11: 38                 SEC                     ; set carry for subtract
  6540                        LAB_2A74
  6541 00:CB12: E8                 INX                     ; increment 10's character
  6542 00:CB13: E9 0A              SBC   #$0A              ; subtract 10 from exponent count
  6543 00:CB15: B0 FB              BCS   LAB_2A74          ; loop while still >= 0
  6544                        
  6545 00:CB17: 69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
  6546 00:CB19: 99 78 00           STA   Decss+4,Y         ; save to output string
  Mon Feb  8 2021  9:20                                                                                                    Page 105


  6547 00:CB1C: 8A                 TXA                     ; copy 10's character
  6548 00:CB1D: 99 77 00           STA   Decss+3,Y         ; save to output string
  6549 00:CB20: A9 00              LDA   #$00              ; set null terminator
  6550 00:CB22: 99 79 00           STA   Decss+5,Y         ; save to output string
  6551 00:CB25: 80 08              BRA   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
  6552                        
  6553                                                      ; save last character, [EOT] and exit
  6554                        LAB_2A89
  6555 00:CB27: 99 74 00           STA   Decss,Y           ; save last character to output string
  6556                        
  6557                                                      ; set null terminator and exit
  6558                        LAB_2A8C
  6559 00:CB2A: A9 00              LDA   #$00              ; set null terminator
  6560 00:CB2C: 99 75 00           STA   Decss+1,Y         ; save after last character
  6561                        
  6562                                                      ; set string pointer (AY) and exit
  6563                        LAB_2A91
  6564 00:CB2F: A9 75              LDA   #<Decssp1         ; set result string low pointer
  6565 00:CB31: A0 00              LDY   #>Decssp1         ; set result string high pointer
  6566 00:CB33: 60                 RTS
  6567                        
  6568                        ; perform power function
  6569                        
  6570                        LAB_POWER
  6571 00:CB34: F0 42              BEQ   LAB_EXP           ; go do  EXP()
  6572                        
  6573 00:CB36: A5 65              LDA   FAC2_e            ; get FAC2 exponent
  6574 00:CB38: D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
  6575                        
  6576 00:CB3A: 4C DA C5           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
  6577                        
  6578                        LAB_2ABF
  6579 00:CB3D: A2 4E              LDX   #<func_l          ; set destination pointer low byte
  6580 00:CB3F: A0 00              LDY   #>func_l          ; set destination pointer high byte
  6581 00:CB41: 20 2C C8           JSR   LAB_2778          ; pack FAC1 into (XY)
  6582 00:CB44: A5 69              LDA   FAC2_s            ; get FAC2 sign (b7)
  6583 00:CB46: 10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
  6584                        
  6585                                                      ; else FAC2 is -ve and can only be raised to an
  6586                                                      ; integer power which gives an x +j0 result
  6587 00:CB48: 20 01 C9           JSR   LAB_INT           ; perform INT
  6588 00:CB4B: A9 4E              LDA   #<func_l          ; set source pointer low byte
  6589 00:CB4D: A0 00              LDY   #>func_l          ; set source pointer high byte
  6590 00:CB4F: 20 98 C8           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6591 00:CB52: D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
  6592                                                      ; this will leave FAC1 -ve and cause a Function Call
  6593                                                      ; error when LOG() is called
  6594                        
  6595 00:CB54: 98                 TYA                     ; clear sign b7
  6596 00:CB55: A4 0D              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
  6597                                                      ; for possible later negation, b0
  6598                        LAB_2AD9
  6599 00:CB57: 20 51 C5           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
  6600 00:CB5A: 98                 TYA                     ; copy sign back ..
  6601 00:CB5B: 48                 PHA                     ; .. and save it
  6602 00:CB5C: 20 83 C6           JSR   LAB_LOG           ; do LOG(n)
  6603 00:CB5F: A9 4E              LDA   #<garb_l          ; set pointer low byte
  6604 00:CB61: A0 00              LDY   #>garb_l          ; set pointer high byte
  6605 00:CB63: 20 C1 C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
  6606 00:CB66: 20 78 CB           JSR   LAB_EXP           ; go do EXP(n)
  6607 00:CB69: 68                 PLA                     ; pull sign from stack
  6608 00:CB6A: 4A                 LSR                     ; b0 is to be tested, shift to Cb
  6609 00:CB6B: 90 0A              BCC   LAB_2AF9          ; if no bit then exit
  Mon Feb  8 2021  9:20                                                                                                    Page 106


  6610                        
  6611                                                      ; Perform negation
  6612                        ; do - FAC1
  6613                        
  6614                        LAB_GTHAN
  6615 00:CB6D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6616 00:CB6F: F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
  6617                        
  6618 00:CB71: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6619 00:CB73: 49 FF              EOR   #$FF              ; complement it
  6620 00:CB75: 85 62              STA   FAC1_s            ; save FAC1 sign (b7)
  6621                        LAB_2AF9
  6622 00:CB77: 60                 RTS
  6623                        
  6624                        ; perform EXP()   (x^e)
  6625                        
  6626                        LAB_EXP
  6627 00:CB78: A9 15              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
  6628 00:CB7A: A0 D1              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
  6629 00:CB7C: 20 C1 C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6630 00:CB7F: A5 6B              LDA   FAC1_r            ; get FAC1 rounding byte
  6631 00:CB81: 69 50              ADC   #$50              ; +$50/$100
  6632 00:CB83: 90 03              BCC   LAB_2B2B          ; skip rounding if no carry
  6633                        
  6634 00:CB85: 20 66 C8           JSR   LAB_27C2          ; round FAC1 (no check)
  6635                        LAB_2B2B
  6636 00:CB88: 85 55              STA   FAC2_r            ; save FAC2 rounding byte
  6637 00:CB8A: 20 52 C8           JSR   LAB_27AE          ; copy FAC1 to FAC2
  6638 00:CB8D: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6639 00:CB8F: C9 88              CMP   #$88              ; compare with EXP limit (256d)
  6640 00:CB91: 90 03              BCC   LAB_2B39          ; branch if less
  6641                        
  6642                        LAB_2B36
  6643 00:CB93: 20 55 C7           JSR   LAB_2690          ; handle overflow and underflow
  6644                        LAB_2B39
  6645 00:CB96: 20 01 C9           JSR   LAB_INT           ; perform INT
  6646 00:CB99: A5 0D              LDA   Temp3             ; get mantissa 3 from INT() function
  6647 00:CB9B: 18                 CLC                     ; clear carry for add
  6648 00:CB9C: 69 81              ADC   #$81              ; normalise +1
  6649 00:CB9E: F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
  6650                        
  6651 00:CBA0: 38                 SEC                     ; set carry for subtract
  6652 00:CBA1: E9 01              SBC   #$01              ; now correct for exponent
  6653 00:CBA3: 48                 PHA                     ; save FAC2 exponent
  6654                        
  6655                                                      ; swap FAC1 and FAC2
  6656 00:CBA4: A2 04              LDX   #$04              ; 4 bytes to do
  6657                        LAB_2B49
  6658 00:CBA6: B5 65              LDA   FAC2_e,X          ; get FAC2,X
  6659 00:CBA8: B4 5E              LDY   FAC1_e,X          ; get FAC1,X
  6660 00:CBAA: 95 5E              STA   FAC1_e,X          ; save FAC1,X
  6661 00:CBAC: 94 65              STY   FAC2_e,X          ; save FAC2,X
  6662 00:CBAE: CA                 DEX                     ; decrement count/index
  6663 00:CBAF: 10 F5              BPL   LAB_2B49          ; loop if not all done
  6664                        
  6665 00:CBB1: A5 55              LDA   FAC2_r            ; get FAC2 rounding byte
  6666 00:CBB3: 85 6B              STA   FAC1_r            ; save as FAC1 rounding byte
  6667 00:CBB5: 20 33 C5           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
  6668 00:CBB8: 20 6D CB           JSR   LAB_GTHAN         ; do - FAC1
  6669 00:CBBB: A9 19              LDA   #<LAB_2AFE        ; set counter pointer low byte
  6670 00:CBBD: A0 D1              LDY   #>LAB_2AFE        ; set counter pointer high byte
  6671 00:CBBF: 20 DE CB           JSR   LAB_2B84          ; go do series evaluation
  6672 00:CBC2: 64 6A              STZ   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  Mon Feb  8 2021  9:20                                                                                                    Page 107


  6673 00:CBC4: 68                 PLA                     ;.get saved FAC2 exponent
  6674 00:CBC5: 4C 39 C7           JMP   LAB_2675          ; test and adjust accumulators and return
  6675                        
  6676                        ; ^2 then series evaluation
  6677                        
  6678                        LAB_2B6E
  6679 00:CBC8: 85 6C              STA   Cptrl             ; save count pointer low byte
  6680 00:CBCA: 84 6D              STY   Cptrh             ; save count pointer high byte
  6681 00:CBCC: 20 22 C8           JSR   LAB_276E          ; pack FAC1 into Adatal
  6682 00:CBCF: A9 56              LDA   #<Adatal          ; set pointer low byte (Y already $00)
  6683 00:CBD1: 20 C1 C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6684 00:CBD4: 20 E2 CB           JSR   LAB_2B88          ; go do series evaluation
  6685 00:CBD7: A9 56              LDA   #<Adatal          ; pointer to original # low byte
  6686 00:CBD9: A0 00              LDY   #>Adatal          ; pointer to original # high byte
  6687 00:CBDB: 4C C1 C6           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
  6688                        
  6689                        ; series evaluation
  6690                        
  6691                        LAB_2B84
  6692 00:CBDE: 85 6C              STA   Cptrl             ; save count pointer low byte
  6693 00:CBE0: 84 6D              STY   Cptrh             ; save count pointer high byte
  6694                        LAB_2B88
  6695 00:CBE2: A2 5A              LDX   #<numexp          ; set pointer low byte
  6696 00:CBE4: 20 24 C8           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
  6697 00:CBE7: B1 6C              LDA   (Cptrl),Y         ; get constants count
  6698 00:CBE9: 85 63              STA   numcon            ; save constants count
  6699 00:CBEB: A4 6C              LDY   Cptrl             ; get count pointer low byte
  6700 00:CBED: C8                 INY                     ; increment it (now constants pointer)
  6701 00:CBEE: 98                 TYA                     ; copy it
  6702 00:CBEF: D0 02              BNE   LAB_2B97          ; skip next if no overflow
  6703                        
  6704 00:CBF1: E6 6D              INC   Cptrh             ; else increment high byte
  6705                        LAB_2B97
  6706 00:CBF3: 85 6C              STA   Cptrl             ; save low byte
  6707 00:CBF5: A4 6D              LDY   Cptrh             ; get high byte
  6708                        LAB_2B9B
  6709 00:CBF7: 20 C1 C6           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6710 00:CBFA: A5 6C              LDA   Cptrl             ; get constants pointer low byte
  6711 00:CBFC: A4 6D              LDY   Cptrh             ; get constants pointer high byte
  6712 00:CBFE: 18                 CLC                     ; clear carry for add
  6713 00:CBFF: 69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
  6714 00:CC01: 90 01              BCC   LAB_2BA8          ; skip next if no overflow
  6715                        
  6716 00:CC03: C8                 INY                     ; increment high byte
  6717                        LAB_2BA8
  6718 00:CC04: 85 6C              STA   Cptrl             ; save pointer low byte
  6719 00:CC06: 84 6D              STY   Cptrh             ; save pointer high byte
  6720 00:CC08: 20 4A C5           JSR   LAB_246C          ; add (AY) to FAC1
  6721 00:CC0B: A9 5A              LDA   #<numexp          ; set pointer low byte to partial @ numexp
  6722 00:CC0D: A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
  6723 00:CC0F: C6 63              DEC   numcon            ; decrement constants count
  6724 00:CC11: D0 E4              BNE   LAB_2B9B          ; loop until all done
  6725 00:CC13: 60                 RTS
  6726                        
  6727                        ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
  6728                        ; to get 19th next number in sequence after seed n. This version of the PRNG uses
  6729                        ; the Galois method and a sample of 65536 bytes produced gives the following values.
  6730                        
  6731                        ; Entropy = 7.997442 bits per byte
  6732                        ; Optimum compression would reduce these 65536 bytes by 0 percent
  6733                        
  6734                        ; Chi square distribution for 65536 samples is 232.01, and
  6735                        ; randomly would exceed this value 75.00 percent of the time
  Mon Feb  8 2021  9:20                                                                                                    Page 108


  6736                        
  6737                        ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
  6738                        ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
  6739                        ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
  6740                        
  6741                        LAB_RND
  6742 00:CC14: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6743 00:CC16: F0 07              BEQ   NextPRN           ; do next random # if zero
  6744                        
  6745                                                      ; else get seed into random number store
  6746 00:CC18: A2 70              LDX   #Rbyte4           ; set PRNG pointer low byte
  6747 00:CC1A: A0 00              LDY   #$00              ; set PRNG pointer high byte
  6748 00:CC1C: 20 2C C8           JSR   LAB_2778          ; pack FAC1 into (XY)
  6749                        NextPRN
  6750 00:CC1F: A2 AF              LDX   #$AF              ; set EOR byte
  6751 00:CC21: A0 13              LDY   #$13              ; do this nineteen times
  6752                        LoopPRN
  6753 00:CC23: 06 71              ASL   Rbyte1            ; shift PRNG most significant byte
  6754 00:CC25: 26 72              ROL   Rbyte2            ; shift PRNG middle byte
  6755 00:CC27: 26 73              ROL   Rbyte3            ; shift PRNG least significant byte
  6756 00:CC29: 26 70              ROL   Rbyte4            ; shift PRNG extra byte
  6757 00:CC2B: 90 05              BCC   Ninc1             ; branch if bit 32 clear
  6758                        
  6759 00:CC2D: 8A                 TXA                     ; set EOR byte
  6760 00:CC2E: 45 71              EOR   Rbyte1            ; EOR PRNG extra byte
  6761 00:CC30: 85 71              STA   Rbyte1            ; save new PRNG extra byte
  6762                        Ninc1
  6763 00:CC32: 88                 DEY                     ; decrement loop count
  6764 00:CC33: D0 EE              BNE   LoopPRN           ; loop if not all done
  6765                        
  6766 00:CC35: A2 02              LDX   #$02              ; three bytes to copy
  6767                        CopyPRNG
  6768 00:CC37: B5 71              LDA   Rbyte1,X          ; get PRNG byte
  6769 00:CC39: 95 5F              STA   FAC1_1,X          ; save FAC1 byte
  6770 00:CC3B: CA                 DEX
  6771 00:CC3C: 10 F9              BPL   CopyPRNG          ; loop if not complete
  6772                        
  6773 00:CC3E: A9 80              LDA   #$80              ; set the exponent
  6774 00:CC40: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  6775                        
  6776 00:CC42: 0A                 ASL                     ; clear A
  6777 00:CC43: 85 62              STA   FAC1_s            ; save FAC1 sign
  6778                        
  6779 00:CC45: 4C BC C5           JMP   LAB_24D5          ; normalise FAC1 and return
  6780                        
  6781                        ; perform COS()
  6782                        
  6783                        LAB_COS
  6784 00:CC48: A9 36              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
  6785 00:CC4A: A0 D1              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
  6786 00:CC4C: 20 4A C5           JSR   LAB_246C          ; add (AY) to FAC1
  6787                        
  6788                        ; perform SIN()
  6789                        
  6790                        LAB_SIN
  6791 00:CC4F: 20 4F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6792 00:CC52: A9 4B              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  6793 00:CC54: A0 D1              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  6794 00:CC56: A6 69              LDX   FAC2_s            ; get FAC2 sign (b7)
  6795 00:CC58: 20 80 C7           JSR   LAB_26C2          ; divide by (AY) (X=sign)
  6796 00:CC5B: 20 4F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6797 00:CC5E: 20 01 C9           JSR   LAB_INT           ; perform INT
  6798 00:CC61: 64 6A              STZ   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  Mon Feb  8 2021  9:20                                                                                                    Page 109


  6799 00:CC63: 20 33 C5           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
  6800 00:CC66: A9 7D              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
  6801 00:CC68: A0 D1              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
  6802 00:CC6A: 20 30 C5           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
  6803 00:CC6D: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6804 00:CC6F: 48                 PHA                     ; save FAC1 sign
  6805 00:CC70: 10 0D              BPL   LAB_2C35          ; branch if +ve
  6806                        
  6807                                                      ; FAC1 sign was -ve
  6808 00:CC72: 20 46 C5           JSR   LAB_244E          ; add 0.5 to FAC1
  6809 00:CC75: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6810 00:CC77: 30 09              BMI   LAB_2C38          ; branch if -ve
  6811                        
  6812 00:CC79: A5 15              LDA   Cflag             ; get comparison evaluation flag
  6813 00:CC7B: 49 FF              EOR   #$FF              ; toggle flag
  6814 00:CC7D: 85 15              STA   Cflag             ; save comparison evaluation flag
  6815                        LAB_2C35
  6816 00:CC7F: 20 6D CB           JSR   LAB_GTHAN         ; do - FAC1
  6817                        LAB_2C38
  6818 00:CC82: A9 7D              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
  6819 00:CC84: A0 D1              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
  6820 00:CC86: 20 4A C5           JSR   LAB_246C          ; add (AY) to FAC1
  6821 00:CC89: 68                 PLA                     ; restore FAC1 sign
  6822 00:CC8A: 10 03              BPL   LAB_2C45          ; branch if was +ve
  6823                        
  6824                                                      ; else correct FAC1
  6825 00:CC8C: 20 6D CB           JSR   LAB_GTHAN         ; do - FAC1
  6826                        LAB_2C45
  6827 00:CC8F: A9 3A              LDA   #<LAB_2C84        ; set pointer low byte to counter
  6828 00:CC91: A0 D1              LDY   #>LAB_2C84        ; set pointer high byte to counter
  6829 00:CC93: 4C C8 CB           JMP   LAB_2B6E          ; ^2 then series evaluation and return
  6830                        
  6831                        ; perform TAN()
  6832                        
  6833                        LAB_TAN
  6834 00:CC96: 20 22 C8           JSR   LAB_276E          ; pack FAC1 into Adatal
  6835 00:CC99: 64 15              STZ   Cflag             ; clear comparison evaluation flag
  6836 00:CC9B: 20 4F CC           JSR   LAB_SIN           ; go do SIN(n)
  6837 00:CC9E: A2 4E              LDX   #<func_l          ; set sin(n) pointer low byte
  6838 00:CCA0: A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
  6839 00:CCA2: 20 2C C8           JSR   LAB_2778          ; pack FAC1 into (XY)
  6840 00:CCA5: A9 56              LDA   #<Adatal          ; set n pointer low addr
  6841 00:CCA7: A0 00              LDY   #>Adatal          ; set n pointer high addr
  6842 00:CCA9: 20 02 C8           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  6843 00:CCAC: 64 62              STZ   FAC1_s            ; clear FAC1 sign (b7)
  6844 00:CCAE: A5 15              LDA   Cflag             ; get comparison evaluation flag
  6845 00:CCB0: 20 BA CC           JSR   LAB_2C74          ; save flag and go do series evaluation
  6846                        
  6847 00:CCB3: A9 4E              LDA   #<func_l          ; set sin(n) pointer low byte
  6848 00:CCB5: A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
  6849 00:CCB7: 4C 87 C7           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
  6850                        
  6851                        LAB_2C74
  6852 00:CCBA: 48                 PHA                     ; save comparison evaluation flag
  6853 00:CCBB: 80 C2              BRA   LAB_2C35          ; go do series evaluation
  6854                        
  6855                        ; perform USR()
  6856                        
  6857                        LAB_USR
  6858 00:CCBD: 20 03 00           JSR   Usrjmp            ; call user code
  6859 00:CCC0: 4C 8B BB           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  6860                        
  6861                        ; perform ATN()
  Mon Feb  8 2021  9:20                                                                                                    Page 110


  6862                        
  6863                        LAB_ATN
  6864 00:CCC3: A5 62              LDA   FAC1_s            ; get FAC1 sign (b7)
  6865 00:CCC5: 48                 PHA                     ; save sign
  6866 00:CCC6: 10 03              BPL   LAB_2CA1          ; branch if +ve
  6867                        
  6868 00:CCC8: 20 6D CB           JSR   LAB_GTHAN         ; else do - FAC1
  6869                        LAB_2CA1
  6870 00:CCCB: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  6871 00:CCCD: 48                 PHA                     ; push exponent
  6872 00:CCCE: C9 81              CMP   #$81              ; compare with 1
  6873 00:CCD0: 90 07              BCC   LAB_2CAF          ; branch if FAC1<1
  6874                        
  6875 00:CCD2: A9 70              LDA   #<LAB_259C        ; set 1 pointer low byte
  6876 00:CCD4: A0 D1              LDY   #>LAB_259C        ; set 1 pointer high byte
  6877 00:CCD6: 20 87 C7           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
  6878                        LAB_2CAF
  6879 00:CCD9: A9 4F              LDA   #<LAB_2CC9        ; set pointer low byte to counter
  6880 00:CCDB: A0 D1              LDY   #>LAB_2CC9        ; set pointer high byte to counter
  6881 00:CCDD: 20 C8 CB           JSR   LAB_2B6E          ; ^2 then series evaluation
  6882 00:CCE0: 68                 PLA                     ; restore old FAC1 exponent
  6883 00:CCE1: C9 81              CMP   #$81              ; compare with 1
  6884 00:CCE3: 90 07              BCC   LAB_2CC2          ; branch if FAC1<1
  6885                        
  6886 00:CCE5: A9 36              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
  6887 00:CCE7: A0 D1              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
  6888 00:CCE9: 20 30 C5           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
  6889                        LAB_2CC2
  6890 00:CCEC: 68                 PLA                     ; restore FAC1 sign
  6891 00:CCED: 10 16              BPL   LAB_2D04          ; exit if was +ve
  6892                        
  6893 00:CCEF: 4C 6D CB           JMP   LAB_GTHAN         ; else do - FAC1 and return
  6894                        
  6895                        ; perform BITSET
  6896                        
  6897                        LAB_BITSET
  6898 00:CCF2: 20 65 C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  6899 00:CCF5: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  6900 00:CCF7: B0 20              BCS   FCError           ; branch if > 7
  6901                        
  6902 00:CCF9: A9 00              LDA   #$00              ; clear A
  6903 00:CCFB: 38                 SEC                     ; set the carry
  6904                        S_Bits
  6905 00:CCFC: 2A                 ROL                     ; shift bit
  6906 00:CCFD: CA                 DEX                     ; decrement bit number
  6907 00:CCFE: 10 FC              BPL   S_Bits            ; loop if still +ve
  6908                        
  6909 00:CD00: E8                 INX                     ; make X = $00
  6910 00:CD01: 01 0A              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
  6911 00:CD03: 81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  6912                        LAB_2D04
  6913 00:CD05: 60                 RTS
  6914                        
  6915                        ; perform BITCLR
  6916                        
  6917                        LAB_BITCLR
  6918 00:CD06: 20 65 C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  6919 00:CD09: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  6920 00:CD0B: B0 0C              BCS   FCError           ; branch if > 7
  6921                        
  6922 00:CD0D: A9 FF              LDA   #$FF              ; set A
  6923                        S_Bitc
  6924 00:CD0F: 2A                 ROL                     ; shift bit
  Mon Feb  8 2021  9:20                                                                                                    Page 111


  6925 00:CD10: CA                 DEX                     ; decrement bit number
  6926 00:CD11: 10 FC              BPL   S_Bitc            ; loop if still +ve
  6927                        
  6928 00:CD13: E8                 INX                     ; make X = $00
  6929 00:CD14: 21 0A              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
  6930 00:CD16: 81 0A              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  6931 00:CD18: 60                 RTS
  6932                        
  6933                        FCError
  6934 00:CD19: 4C C8 BE           JMP   LAB_FCER          ; do function call error then warm start
  6935                        
  6936                        ; perform BITTST()
  6937                        
  6938                        LAB_BTST
  6939 00:CD1C: 20 B5 CF           JSR   LAB_IGBY          ; increment BASIC pointer
  6940 00:CD1F: 20 65 C4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  6941 00:CD22: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  6942 00:CD24: B0 F3              BCS   FCError           ; branch if > 7
  6943                        
  6944 00:CD26: 20 BB CF           JSR   LAB_GBYT          ; get next BASIC byte
  6945 00:CD29: C9 29              CMP   #')'              ; is next character ")"
  6946 00:CD2B: F0 03              BEQ   TST_OK            ; if ")" go do rest of function
  6947                        
  6948 00:CD2D: 4C 9C BB           JMP   LAB_SNER          ; do syntax error then warm start
  6949                        
  6950                        TST_OK
  6951 00:CD30: 20 B5 CF           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
  6952 00:CD33: A9 00              LDA   #$00              ; clear A
  6953 00:CD35: 38                 SEC                     ; set the carry
  6954                        T_Bits
  6955 00:CD36: 2A                 ROL                     ; shift bit
  6956 00:CD37: CA                 DEX                     ; decrement bit number
  6957 00:CD38: 10 FC              BPL   T_Bits            ; loop if still +ve
  6958                        
  6959 00:CD3A: E8                 INX                     ; make X = $00
  6960 00:CD3B: 21 0A              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
  6961 00:CD3D: F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
  6962                        
  6963 00:CD3F: A9 FF              LDA   #$FF              ; set for -1 result
  6964                        LAB_NOTT
  6965 00:CD41: 4C 7F C8           JMP   LAB_27DB          ; go do SGN tail
  6966                        
  6967                        ; perform BIN$()
  6968                        
  6969                        LAB_BINS
  6970 00:CD44: E0 19              CPX   #$19              ; max + 1
  6971 00:CD46: B0 48              BCS   BinFErr           ; exit if too big ( > or = )
  6972                        
  6973 00:CD48: 86 2A              STX   TempB             ; save # of characters ($00 = leading zero remove)
  6974 00:CD4A: A9 18              LDA   #$18              ; need A byte long space
  6975 00:CD4C: 20 D5 C0           JSR   LAB_MSSP          ; make string space A bytes long
  6976 00:CD4F: A0 17              LDY   #$17              ; set index
  6977 00:CD51: A2 18              LDX   #$18              ; character count
  6978                        NextB1
  6979 00:CD53: 46 0A              LSR   nums_1            ; shift highest byte
  6980 00:CD55: 66 0B              ROR   nums_2            ; shift middle byte
  6981 00:CD57: 66 0C              ROR   nums_3            ; shift lowest byte bit 0 to carry
  6982 00:CD59: 8A                 TXA                     ; load with "0"/2
  6983 00:CD5A: 2A                 ROL                     ; shift in carry
  6984 00:CD5B: 91 5F              STA   (str_pl),Y        ; save to temp string + index
  6985 00:CD5D: 88                 DEY                     ; decrement index
  6986 00:CD5E: 10 F3              BPL   NextB1            ; loop if not done
  6987                        
  Mon Feb  8 2021  9:20                                                                                                    Page 112


  6988 00:CD60: A5 2A              LDA   TempB             ; get # of characters
  6989 00:CD62: F0 0A              BEQ   EndBHS            ; branch if truncate
  6990                        
  6991 00:CD64: AA                 TAX                     ; copy length to X
  6992 00:CD65: 38                 SEC                     ; set carry for add !
  6993 00:CD66: 49 FF              EOR   #$FF              ; 1's complement
  6994 00:CD68: 69 18              ADC   #$18              ; add 24d
  6995 00:CD6A: F0 1C              BEQ   GoPr2             ; if zero print whole string
  6996 00:CD6C: 80 0F              BRA   GoPr1             ; else go make output string
  6997                        
  6998                        ; this is the exit code and is also used by HEX$()
  6999                        ; truncate string to remove leading "0"s
  7000                        
  7001                        EndBHS
  7002 00:CD6E: A8                 TAY                     ; clear index (A=0, X=length here)
  7003                        NextB2
  7004 00:CD6F: B1 5F              LDA   (str_pl),Y        ; get character from string
  7005 00:CD71: C9 30              CMP   #'0'              ; compare with "0"
  7006 00:CD73: D0 07              BNE   GoPr              ; if not "0" then go print string from here
  7007                        
  7008 00:CD75: CA                 DEX                     ; decrement character count
  7009 00:CD76: F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
  7010                        
  7011 00:CD78: C8                 INY                     ; else increment index
  7012 00:CD79: 80 F4              BRA   NextB2            ; loop always
  7013                        
  7014                        ; make fixed length output string - ignore overflows!
  7015                        
  7016                        GoPr3
  7017 00:CD7B: E8                 INX                     ; need at least 1 character
  7018                        GoPr
  7019 00:CD7C: 98                 TYA                     ; copy result
  7020                        GoPr1
  7021 00:CD7D: 18                 CLC                     ; clear carry for add
  7022 00:CD7E: 65 5F              ADC   str_pl            ; add low address
  7023 00:CD80: 85 5F              STA   str_pl            ; save low address
  7024 00:CD82: A9 00              LDA   #$00              ; do high byte
  7025 00:CD84: 65 60              ADC   str_ph            ; add high address
  7026 00:CD86: 85 60              STA   str_ph            ; save high address
  7027                        GoPr2
  7028 00:CD88: 86 5E              STX   str_ln            ; X holds string length
  7029 00:CD8A: 20 B5 CF           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
  7030 00:CD8D: 4C 22 C1           JMP   LAB_RTST          ; check for space on descriptor stack then put address
  7031                                                      ; and length on descriptor stack and update stack pointers
  7032                        
  7033                        BinFErr
  7034 00:CD90: 4C C8 BE           JMP   LAB_FCER          ; do function call error then warm start
  7035                        
  7036                        ; perform HEX$()
  7037                        
  7038                        LAB_HEXS
  7039 00:CD93: E0 07              CPX   #$07              ; max + 1
  7040 00:CD95: B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
  7041                        
  7042 00:CD97: 86 2A              STX   TempB             ; save # of characters
  7043                        
  7044 00:CD99: A9 06              LDA   #$06              ; need 6 bytes for string
  7045 00:CD9B: 20 D5 C0           JSR   LAB_MSSP          ; make string space A bytes long
  7046 00:CD9E: A0 05              LDY   #$05              ; set string index
  7047                        
  7048 00:CDA0: A5 0C              LDA   nums_3            ; get lowest byte
  7049 00:CDA2: 20 BF CD           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  7050 00:CDA5: A5 0B              LDA   nums_2            ; get middle byte
  Mon Feb  8 2021  9:20                                                                                                    Page 113


  7051 00:CDA7: 20 BF CD           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  7052 00:CDAA: A5 0A              LDA   nums_1            ; get highest byte
  7053 00:CDAC: 20 BF CD           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  7054                        
  7055 00:CDAF: A2 06              LDX   #$06              ; character count
  7056 00:CDB1: A5 2A              LDA   TempB             ; get # of characters
  7057 00:CDB3: F0 B9              BEQ   EndBHS            ; branch if truncate
  7058                        
  7059 00:CDB5: AA                 TAX                     ; copy length to X
  7060 00:CDB6: 38                 SEC                     ; set carry for add !
  7061 00:CDB7: 49 FF              EOR   #$FF              ; 1's complement
  7062 00:CDB9: 69 06              ADC   #$06              ; add 6d
  7063 00:CDBB: F0 CB              BEQ   GoPr2             ; if zero print whole string
  7064 00:CDBD: 80 BE              BRA   GoPr1             ; else go make output string (branch always)
  7065                        
  7066                        ; convert A to ASCII hex byte and output .. note set decimal mode before calling
  7067                        
  7068                        LAB_A2HX
  7069 00:CDBF: AA                 TAX                     ; save byte
  7070 00:CDC0: 29 0F              AND   #$0F              ; mask off top bits
  7071 00:CDC2: 20 CA CD           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
  7072 00:CDC5: 8A                 TXA                     ; get byte back
  7073 00:CDC6: 4A                 LSR                     ; /2  shift high nibble to low nibble
  7074 00:CDC7: 4A                 LSR                     ; /4
  7075 00:CDC8: 4A                 LSR                     ; /8
  7076 00:CDC9: 4A                 LSR                     ; /16
  7077                        LAB_AL2X
  7078 00:CDCA: C9 0A              CMP   #$0A              ; set carry for +1 if >9
  7079 00:CDCC: 90 02              BCC   LAB_AL20          ; skip adjust if <= 9
  7080 00:CDCE: 69 06              ADC   #$06              ; adjust for A to F
  7081                        LAB_AL20
  7082 00:CDD0: 69 30              ADC   #'0'              ; add ASCII "0"
  7083 00:CDD2: 91 5F              STA   (str_pl),Y        ; save to temp string
  7084 00:CDD4: 88                 DEY                     ; decrement counter
  7085 00:CDD5: 60                 RTS
  7086                        
  7087                        LAB_NLTO
  7088 00:CDD6: 85 5E              STA   FAC1_e            ; save FAC1 exponent
  7089 00:CDD8: A9 00              LDA   #$00              ; clear sign compare
  7090                        LAB_MLTE
  7091 00:CDDA: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  7092 00:CDDC: 8A                 TXA                     ; restore character
  7093 00:CDDD: 20 C1 C9           JSR   LAB_2912          ; evaluate new ASCII digit
  7094                        
  7095                        ; gets here if the first character was "$" for hex
  7096                        ; get hex number
  7097                        
  7098                        LAB_CHEX
  7099 00:CDE0: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  7100 00:CDE3: 90 0A              BCC   LAB_ISHN          ; branch if numeric character
  7101                        
  7102 00:CDE5: 09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
  7103 00:CDE7: E9 61              SBC   #'a'              ; subtract "a" (carry set here)
  7104 00:CDE9: C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
  7105 00:CDEB: B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
  7106                        
  7107 00:CDED: 69 0A              ADC   #$0A              ; convert to nibble
  7108                        LAB_ISHN
  7109 00:CDEF: 29 0F              AND   #$0F              ; convert to binary
  7110 00:CDF1: AA                 TAX                     ; save nibble
  7111 00:CDF2: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  7112 00:CDF4: F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
  7113                        
  Mon Feb  8 2021  9:20                                                                                                    Page 114


  7114 00:CDF6: 69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
  7115 00:CDF8: 90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
  7116                        
  7117                        LAB_MLTO
  7118 00:CDFA: 4C 4B C6           JMP   LAB_2564          ; do overflow error and warm start
  7119                        
  7120                        LAB_NXCH
  7121 00:CDFD: AA                 TAX                     ; save bit
  7122 00:CDFE: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  7123 00:CE00: F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
  7124                        
  7125 00:CE02: E6 5E              INC   FAC1_e            ; increment FAC1 exponent (*2)
  7126 00:CE04: F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
  7127                        
  7128 00:CE06: A9 00              LDA   #$00              ; clear sign compare
  7129                        LAB_MLBT
  7130 00:CE08: 85 6A              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  7131 00:CE0A: 8A                 TXA                     ; restore bit
  7132 00:CE0B: 20 C1 C9           JSR   LAB_2912          ; evaluate new ASCII digit
  7133                        
  7134                        ; gets here if the first character was  "%" for binary
  7135                        ; get binary number
  7136                        
  7137                        LAB_CBIN
  7138 00:CE0E: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  7139 00:CE11: 49 30              EOR   #'0'              ; convert "0" to 0 etc.
  7140 00:CE13: C9 02              CMP   #$02              ; compare with max+1
  7141 00:CE15: 90 E6              BCC   LAB_NXCH          ; branch exit if < 2
  7142                        
  7143                        LAB_EXCH
  7144 00:CE17: 4C A7 C9           JMP   LAB_28F6          ; evaluate -ve flag and return
  7145                        
  7146                        ; ctrl-c check routine. includes limited "life" byte save for INGET routine
  7147                        
  7148                        CTRLC
  7149 00:CE1A: AD 7F 05           LDA   ccflag            ; get [CTRL-C] check flag
  7150 00:CE1D: D0 18              BNE   LAB_FBA2          ; exit if inhibited
  7151                        
  7152 00:CE1F: 20 3E D0           JSR   V_INPT            ; scan input device
  7153 00:CE22: 90 0B              BCC   LAB_FBA0          ; exit if buffer empty
  7154                        
  7155 00:CE24: 8D 80 05           STA   ccbyte            ; save received byte
  7156 00:CE27: A2 20              LDX   #$20              ; "life" timer for bytes
  7157 00:CE29: 8E 81 05           STX   ccnull            ; set countdown
  7158 00:CE2C: 4C DC B4           JMP   LAB_1636          ; return to BASIC
  7159                        
  7160                        LAB_FBA0
  7161 00:CE2F: AE 81 05           LDX   ccnull            ; get countdown byte
  7162 00:CE32: F0 03              BEQ   LAB_FBA2          ; exit if finished
  7163                        
  7164 00:CE34: CE 81 05           DEC   ccnull            ; else decrement countdown
  7165                        LAB_FBA2
  7166 00:CE37: 60                 RTS
  7167                        
  7168                        INGET
  7169 00:CE38: 20 3E D0           JSR   V_INPT            ; call scan input device
  7170 00:CE3B: B0 09              BCS   LAB_FB95          ; if byte go reset timer
  7171                        
  7172 00:CE3D: AD 81 05           LDA   ccnull            ; get countdown
  7173 00:CE40: F0 07              BEQ   LAB_FB96          ; exit if empty
  7174                        
  7175 00:CE42: AD 80 05           LDA   ccbyte            ; get last received byte
  7176 00:CE45: 38                 SEC                     ; flag we got a byte
  Mon Feb  8 2021  9:20                                                                                                    Page 115


  7177                        LAB_FB95
  7178 00:CE46: 9C 81 05           STZ   ccnull            ; clear timer because we got a byte
  7179                        LAB_FB96
  7180 00:CE49: 60                 RTS
  7181                        
  7182                        ; MAX() MIN() pre process
  7183                        
  7184                        LAB_MMPP
  7185 00:CE4A: 20 84 BA           JSR   LAB_EVEZ          ; process expression
  7186 00:CE4D: 4C 6A BA           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
  7187                        
  7188                        ; perform MAX()
  7189                        
  7190                        LAB_MAX
  7191 00:CE50: 20 7E CE           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
  7192                                                      ; pull FAC2 and compare with FAC1
  7193 00:CE53: 10 FB              BPL   LAB_MAX           ; branch if no swap to do
  7194                        
  7195 00:CE55: A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
  7196 00:CE57: 09 80              ORA   #$80              ; set top bit (clear sign from compare)
  7197 00:CE59: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  7198 00:CE5B: 20 4F C5           JSR   LAB_279B          ; copy FAC2 to FAC1
  7199 00:CE5E: 80 F0              BRA   LAB_MAX           ; go do next (branch always)
  7200                        
  7201                        ; perform MIN()
  7202                        
  7203                        LAB_MIN
  7204 00:CE60: 20 7E CE           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
  7205                                                      ; pull FAC2 and compare with FAC1
  7206 00:CE63: 30 FB              BMI   LAB_MIN           ; branch if no swap to do
  7207 00:CE65: F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
  7208                        
  7209 00:CE67: A5 66              LDA   FAC2_1            ; get FAC2 mantissa1
  7210 00:CE69: 09 80              ORA   #$80              ; set top bit (clear sign from compare)
  7211 00:CE6B: 85 66              STA   FAC2_1            ; save FAC2 mantissa1
  7212 00:CE6D: 20 4F C5           JSR   LAB_279B          ; copy FAC2 to FAC1
  7213 00:CE70: 80 EE              BRA   LAB_MIN           ; go do next (branch always)
  7214                        
  7215                        ; exit routine. don't bother returning to the loop code
  7216                        ; check for correct exit, else so syntax error
  7217                        
  7218                        LAB_MMEC
  7219 00:CE72: C9 29              CMP   #')'              ; is it end of function?
  7220 00:CE74: D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
  7221                        
  7222 00:CE76: 68                 PLA                     ; dump return address low byte
  7223 00:CE77: 68                 PLA                     ; dump return address high byte
  7224 00:CE78: 4C B5 CF           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
  7225                        
  7226                        LAB_MMSE
  7227 00:CE7B: 4C 9C BB           JMP   LAB_SNER          ; do syntax error then warm start
  7228                        
  7229                        ; check for next, evaluate and return or exit
  7230                        ; this is the routine that does most of the work
  7231                        
  7232                        LAB_PHFA
  7233 00:CE7E: 20 BB CF           JSR   LAB_GBYT          ; get next BASIC byte
  7234 00:CE81: C9 2C              CMP   #','              ; is there more ?
  7235 00:CE83: D0 ED              BNE   LAB_MMEC          ; if not go do end check
  7236                        
  7237                                                      ; push FAC1
  7238 00:CE85: 20 5E C8           JSR   LAB_27BA          ; round FAC1
  7239 00:CE88: A5 62              LDA   FAC1_s            ; get FAC1 sign
  Mon Feb  8 2021  9:20                                                                                                    Page 116


  7240 00:CE8A: 09 7F              ORA   #$7F              ; set all non sign bits
  7241 00:CE8C: 25 5F              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
  7242 00:CE8E: 48                 PHA                     ; push on stack
  7243 00:CE8F: A5 60              LDA   FAC1_2            ; get FAC1 mantissa2
  7244 00:CE91: 48                 PHA                     ; push on stack
  7245 00:CE92: A5 61              LDA   FAC1_3            ; get FAC1 mantissa3
  7246 00:CE94: 48                 PHA                     ; push on stack
  7247 00:CE95: A5 5E              LDA   FAC1_e            ; get FAC1 exponent
  7248 00:CE97: 48                 PHA                     ; push on stack
  7249                        
  7250 00:CE98: 20 B5 CF           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
  7251 00:CE9B: 20 67 BA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  7252                                                      ; else do type mismatch
  7253                        
  7254                                                      ; pop FAC2 (MAX/MIN expression so far)
  7255 00:CE9E: 68                 PLA                     ; pop exponent
  7256 00:CE9F: 85 65              STA   FAC2_e            ; save FAC2 exponent
  7257 00:CEA1: 68                 PLA                     ; pop mantissa3
  7258 00:CEA2: 85 68              STA   FAC2_3            ; save FAC2 mantissa3
  7259 00:CEA4: 68                 PLA                     ; pop mantissa1
  7260 00:CEA5: 85 67              STA   FAC2_2            ; save FAC2 mantissa2
  7261 00:CEA7: 68                 PLA                     ; pop sign/mantissa1
  7262 00:CEA8: 85 66              STA   FAC2_1            ; save FAC2 sign/mantissa1
  7263 00:CEAA: 85 69              STA   FAC2_s            ; save FAC2 sign
  7264                        
  7265                                                      ; compare FAC1 with (packed) FAC2
  7266 00:CEAC: A9 65              LDA   #<FAC2_e          ; set pointer low byte to FAC2
  7267 00:CEAE: A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
  7268 00:CEB0: 4C 98 C8           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
  7269                                                      ; returns A=$00 if FAC1 = (AY)
  7270                                                      ; returns A=$01 if FAC1 > (AY)
  7271                                                      ; returns A=$FF if FAC1 < (AY)
  7272                        
  7273                        ; perform WIDTH
  7274                        
  7275                        LAB_WDTH
  7276 00:CEB3: C9 2C              CMP   #','              ; is next byte ","
  7277 00:CEB5: F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
  7278                        
  7279 00:CEB7: 20 21 C4           JSR   LAB_GTBY          ; get byte parameter
  7280 00:CEBA: 8A                 TXA                     ; copy width to A
  7281 00:CEBB: F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
  7282                        
  7283 00:CEBD: E0 10              CPX   #$10              ; else make min width = 16d
  7284 00:CEBF: 90 45              BCC   TabErr            ; if less do function call error and exit
  7285                        
  7286                        ; this next compare ensures that we can't exit WIDTH via an error leaving the
  7287                        ; tab size greater than the line length.
  7288                        
  7289 00:CEC1: E4 16              CPX   TabSiz            ; compare with tab size
  7290 00:CEC3: B0 02              BCS   LAB_NSTT          ; branch if >= tab size
  7291                        
  7292 00:CEC5: 86 16              STX   TabSiz            ; else make tab size = terminal width
  7293                        LAB_NSTT
  7294 00:CEC7: 86 08              STX   TWidth            ; set the terminal width
  7295 00:CEC9: 20 BB CF           JSR   LAB_GBYT          ; get BASIC byte back
  7296 00:CECC: F0 1A              BEQ   WExit             ; exit if no following
  7297                        
  7298 00:CECE: C9 2C              CMP   #','              ; else is it ","
  7299 00:CED0: D0 A9              BNE   LAB_MMSE          ; if not do syntax error
  7300                        
  7301                        LAB_TBSZ
  7302 00:CED2: 20 1E C4           JSR   LAB_SGBY          ; scan and get byte parameter
  Mon Feb  8 2021  9:20                                                                                                    Page 117


  7303 00:CED5: 8A                 TXA                     ; copy TAB size
  7304 00:CED6: 30 2E              BMI   TabErr            ; if >127 do function call error and exit
  7305                        
  7306 00:CED8: E0 01              CPX   #$01              ; compare with min-1
  7307 00:CEDA: 90 2A              BCC   TabErr            ; if <=1 do function call error and exit
  7308                        
  7309 00:CEDC: A5 08              LDA   TWidth            ; set flags for width
  7310 00:CEDE: F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
  7311                        
  7312 00:CEE0: E4 08              CPX   TWidth            ; compare TAB with width
  7313 00:CEE2: F0 02              BEQ   LAB_SVTB          ; ok if =
  7314 00:CEE4: B0 20              BCS   TabErr            ; branch if too big
  7315                        
  7316                        LAB_SVTB
  7317 00:CEE6: 86 16              STX   TabSiz            ; save TAB size
  7318                        
  7319                        ; calculate tab column limit from TAB size. The Iclim is set to the last tab
  7320                        ; position on a line that still has at least one whole tab width between it
  7321                        ; and the end of the line.
  7322                        
  7323                        WExit
  7324 00:CEE8: A5 08              LDA   TWidth            ; get width
  7325 00:CEEA: F0 06              BEQ   LAB_SULP          ; branch if infinite line
  7326                        
  7327 00:CEEC: C5 16              CMP   TabSiz            ; compare with tab size
  7328 00:CEEE: B0 03              BCS   LAB_WDLP          ; branch if >= tab size
  7329                        
  7330 00:CEF0: 85 16              STA   TabSiz            ; else make tab size = terminal width
  7331                        LAB_SULP
  7332 00:CEF2: 38                 SEC                     ; set carry for subtract
  7333                        LAB_WDLP
  7334 00:CEF3: E5 16              SBC   TabSiz            ; subtract tab size
  7335 00:CEF5: B0 FC              BCS   LAB_WDLP          ; loop while no borrow
  7336                        
  7337 00:CEF7: 65 16              ADC   TabSiz            ; add tab size back
  7338 00:CEF9: 18                 CLC                     ; clear carry for add
  7339 00:CEFA: 65 16              ADC   TabSiz            ; add tab size back again
  7340 00:CEFC: 85 09              STA   Iclim             ; save for now
  7341 00:CEFE: A5 08              LDA   TWidth            ; get width back
  7342 00:CF00: 38                 SEC                     ; set carry for subtract
  7343 00:CF01: E5 09              SBC   Iclim             ; subtract remainder
  7344 00:CF03: 85 09              STA   Iclim             ; save tab column limit
  7345                        LAB_NOSQ
  7346 00:CF05: 60                 RTS
  7347                        
  7348                        TabErr
  7349 00:CF06: 4C C8 BE           JMP   LAB_FCER          ; do function call error then warm start
  7350                        
  7351                        ; perform SQR()
  7352                        
  7353                        LAB_SQR
  7354 00:CF09: A5 62              LDA   FAC1_s            ; get FAC1 sign
  7355 00:CF0B: 30 F9              BMI   TabErr            ; if -ve do function call error
  7356                        
  7357 00:CF0D: A5 5E              LDA   FAC1_e            ; get exponent
  7358 00:CF0F: F0 F4              BEQ   LAB_NOSQ          ; if zero just return
  7359                        
  7360                                                      ; else do root
  7361 00:CF11: 20 4F C8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  7362                        
  7363 00:CF14: 64 29              STZ   FACt_3            ; clear remainder
  7364 00:CF16: 64 28              STZ   FACt_2            ; ..
  7365 00:CF18: 64 27              STZ   FACt_1            ; ..
  Mon Feb  8 2021  9:20                                                                                                    Page 118


  7366 00:CF1A: 64 2A              STZ   TempB             ; ..
  7367                        
  7368 00:CF1C: 64 61              STZ   FAC1_3            ; clear root
  7369 00:CF1E: 64 60              STZ   FAC1_2            ; ..
  7370 00:CF20: 64 5F              STZ   FAC1_1            ; ..
  7371                        
  7372 00:CF22: A2 18              LDX   #$18              ; 24 pairs of bits to do
  7373 00:CF24: A5 65              LDA   FAC2_e            ; get exponent
  7374 00:CF26: 4A                 LSR                     ; check odd/even
  7375 00:CF27: B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
  7376                        
  7377                        LAB_SQE1
  7378 00:CF29: 06 68              ASL   FAC2_3            ; shift highest bit of number ..
  7379 00:CF2B: 26 67              ROL   FAC2_2            ; ..
  7380 00:CF2D: 26 66              ROL   FAC2_1            ; ..
  7381 00:CF2F: 26 29              ROL   FACt_3            ; .. into remainder
  7382 00:CF31: 26 28              ROL   FACt_2            ; ..
  7383 00:CF33: 26 27              ROL   FACt_1            ; ..
  7384 00:CF35: 26 2A              ROL   TempB             ; .. never overflows
  7385                        LAB_SQE2
  7386 00:CF37: 06 68              ASL   FAC2_3            ; shift highest bit of number ..
  7387 00:CF39: 26 67              ROL   FAC2_2            ; ..
  7388 00:CF3B: 26 66              ROL   FAC2_1            ; ..
  7389 00:CF3D: 26 29              ROL   FACt_3            ; .. into remainder
  7390 00:CF3F: 26 28              ROL   FACt_2            ; ..
  7391 00:CF41: 26 27              ROL   FACt_1            ; ..
  7392 00:CF43: 26 2A              ROL   TempB             ; .. never overflows
  7393                        
  7394 00:CF45: 06 61              ASL   FAC1_3            ; root = root * 2
  7395 00:CF47: 26 60              ROL   FAC1_2            ; ..
  7396 00:CF49: 26 5F              ROL   FAC1_1            ; .. never overflows
  7397                        
  7398 00:CF4B: A5 61              LDA   FAC1_3            ; get root low byte
  7399 00:CF4D: 2A                 ROL                     ; *2
  7400 00:CF4E: 85 0D              STA   Temp3             ; save partial low byte
  7401 00:CF50: A5 60              LDA   FAC1_2            ; get root low mid byte
  7402 00:CF52: 2A                 ROL                     ; *2
  7403 00:CF53: 85 0E              STA   Temp3+1           ; save partial low mid byte
  7404 00:CF55: A5 5F              LDA   FAC1_1            ; get root high mid byte
  7405 00:CF57: 2A                 ROL                     ; *2
  7406 00:CF58: 85 0F              STA   Temp3+2           ; save partial high mid byte
  7407 00:CF5A: A9 00              LDA   #$00              ; get root high byte (always $00)
  7408 00:CF5C: 2A                 ROL                     ; *2
  7409 00:CF5D: 85 10              STA   Temp3+3           ; save partial high byte
  7410                        
  7411                                                      ; carry clear for subtract +1
  7412 00:CF5F: A5 29              LDA   FACt_3            ; get remainder low byte
  7413 00:CF61: E5 0D              SBC   Temp3             ; subtract partial low byte
  7414 00:CF63: 85 0D              STA   Temp3             ; save partial low byte
  7415                        
  7416 00:CF65: A5 28              LDA   FACt_2            ; get remainder low mid byte
  7417 00:CF67: E5 0E              SBC   Temp3+1           ; subtract partial low mid byte
  7418 00:CF69: 85 0E              STA   Temp3+1           ; save partial low mid byte
  7419                        
  7420 00:CF6B: A5 27              LDA   FACt_1            ; get remainder high mid byte
  7421 00:CF6D: E5 0F              SBC   Temp3+2           ; subtract partial high mid byte
  7422 00:CF6F: A8                 TAY                     ; copy partial high mid byte
  7423                        
  7424 00:CF70: A5 2A              LDA   TempB             ; get remainder high byte
  7425 00:CF72: E5 10              SBC   Temp3+3           ; subtract partial high byte
  7426 00:CF74: 90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
  7427                        
  7428 00:CF76: 85 2A              STA   TempB             ; save remainder high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 119


  7429                        
  7430 00:CF78: 84 27              STY   FACt_1            ; save remainder high mid byte
  7431                        
  7432 00:CF7A: A5 0E              LDA   Temp3+1           ; get remainder low mid byte
  7433 00:CF7C: 85 28              STA   FACt_2            ; save remainder low mid byte
  7434                        
  7435 00:CF7E: A5 0D              LDA   Temp3             ; get partial low byte
  7436 00:CF80: 85 29              STA   FACt_3            ; save remainder low byte
  7437                        
  7438 00:CF82: E6 61              INC   FAC1_3            ; increment root low byte (never any rollover)
  7439                        LAB_SQNS
  7440 00:CF84: CA                 DEX                     ; decrement bit pair count
  7441 00:CF85: D0 A2              BNE   LAB_SQE1          ; loop if not all done
  7442                        
  7443 00:CF87: 38                 SEC                     ; set carry for subtract
  7444 00:CF88: A5 65              LDA   FAC2_e            ; get exponent
  7445 00:CF8A: E9 80              SBC   #$80              ; normalise
  7446 00:CF8C: 6A                 ROR                     ; /2 and re-bias to $80
  7447 00:CF8D: 69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
  7448 00:CF8F: 85 5E              STA   FAC1_e            ; save it
  7449 00:CF91: 4C BC C5           JMP   LAB_24D5          ; normalise FAC1 and return
  7450                        
  7451                        ; perform VARPTR()
  7452                        
  7453                        LAB_VARPTR
  7454 00:CF94: 20 B5 CF           JSR   LAB_IGBY          ; increment and scan memory
  7455 00:CF97: 20 4C BD           JSR   LAB_GVAR          ; get var address
  7456 00:CF9A: 20 8B BB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  7457 00:CF9D: A4 47              LDY   Cvaral            ; get var address low byte
  7458 00:CF9F: A5 48              LDA   Cvarah            ; get var address high byte
  7459 00:CFA1: 4C F8 BF           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  7460                        
  7461                        ; perform PI
  7462                        
  7463                        LAB_PI
  7464 00:CFA4: A9 4B              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  7465 00:CFA6: A0 D1              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  7466 00:CFA8: 20 02 C8           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  7467 00:CFAB: C6 5E              DEC   FAC1_e            ; make result = PI
  7468 00:CFAD: 60                 RTS
  7469                        
  7470                        ; perform TWOPI
  7471                        
  7472                        LAB_TWOPI
  7473 00:CFAE: A9 4B              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  7474 00:CFB0: A0 D1              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  7475 00:CFB2: 4C 02 C8           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
  7476                        
  7477                        ; character get subroutine - ROM based
  7478                        
  7479                        ; the target address for the LDA at LAB_GBYT is the BASIC execute pointer.
  7480                        ; block is no longer copied to page zero and uses a CMOS instruction/address mode.
  7481                        ; 16-bit pointer is located in page zero.
  7482                        
  7483                        ; increment and scan memory
  7484                        LAB_IGBY
  7485 00:CFB5: E6 6E              INC   Bpntrl            ; increment BASIC execute pointer low byte
  7486 00:CFB7: D0 02              BNE   LAB_GBYT          ; branch if no carry, else
  7487 00:CFB9: E6 6F              INC   Bpntrh            ; increment BASIC execute pointer high byte
  7488                        
  7489                        ; scan memory
  7490                        LAB_GBYT
  7491 00:CFBB: B2 6E              LDA   (Bpntrl)          ; get byte to scan (addr set by call routine)
  Mon Feb  8 2021  9:20                                                                                                    Page 120


  7492 00:CFBD: C9 A9              CMP   #TK_ELSE          ; compare with the token for ELSE
  7493 00:CFBF: F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
  7494                        
  7495 00:CFC1: C9 3A              CMP   #':'              ; compare with ":"
  7496 00:CFC3: B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
  7497                        
  7498 00:CFC5: C9 20              CMP   #' '              ; compare with " "
  7499 00:CFC7: F0 EC              BEQ   LAB_IGBY          ; if " " go do next
  7500                        
  7501                        ; changes per Mike Barry, saves a couple clock cycles
  7502 00:CFC9: 49 30              EOR #'0'                ; convert to binary
  7503 00:CFCB: C9 0A              CMP #10                 ; clear carry if decimal digit
  7504 00:CFCD: 49 30              EOR #'0'                ; convert back to ASCII
  7505                        
  7506                        LAB_2D05
  7507 00:CFCF: 60                 RTS
  7508                        
  7509                        LAB_LOAD
  7510                        ; To Load a program you need to start loading at Smeml/h
  7511                        ; then find the end of program (two $00), using Itempl/h,
  7512                        ; then clear other variables and call BASIC cleanup
  7513                        ;
  7514                        ; The variables used by the C02 Monitor are:
  7515                        ; PTRL/H, plus set the Block count to 1 and clear the OPXMDM flag
  7516                        ;
  7517                        ; LOAD command
  7518                        
  7519 00:CFD0: A5 2B             LDA     Smeml            ; get start address
  7520 00:CFD2: 85 CA             STA     PTRL             ; put it in XMODEM pointer
  7521 00:CFD4: A5 2C             LDA     Smemh            ;
  7522 00:CFD6: 85 CB             STA     PTRH             ;
  7523                        
  7524 00:CFD8: A9 01             LDA    #$01              ; get count of one
  7525 00:CFDA: 85 CC             STA    BLKNO             ; set Xmodem block count
  7526 00:CFDC: 64 C6             STZ    OPXMDM            ; clear OPXMDM flag
  7527 00:CFDE: 20 44 D0          JSR    V_LOAD            ; call XMODEM receive vector
  7528                        
  7529                        ; Program loaded into memory, likely padded with $1A from Xmodem protocol
  7530                        ; use get_basmem routine to find the end program memory, then reset the pointers
  7531                        ; and call LAB_1319 to cleanup EhBasic.
  7532                        ; NOTE: Modified routine using OPXMDM Bit7 to indicate a LOAD was done and
  7533                        ; print the Ready message after cleanup.
  7534                        
  7535 00:CFE1: 20 19 D0          JSR     get_basmem       ; find end of program space
  7536 00:CFE4: A5 0A             LDA     Itempl           ; get start of free memory low byte address
  7537 00:CFE6: A4 0B             LDY     Itemph           ; get start of free memory high byte address
  7538 00:CFE8: 85 2D             STA     Svarl            ; and set variables and strings pointers
  7539 00:CFEA: 85 2F             STA     Sarryl           ; to the start of free memory
  7540 00:CFEC: 85 31             STA     Earryl           ;
  7541 00:CFEE: 84 2E             STY     Svarh            ;
  7542 00:CFF0: 84 30             STY     Sarryh           ;
  7543 00:CFF2: 84 32             STY     Earryh           ;
  7544 00:CFF4: F7 C6             SMB7    OPXMDM           ; set upper bit in flag (print Ready msg)
  7545 00:CFF6: 4C D3 B1          JMP     LAB_1319         ; cleanup and Return to BASIC
  7546                        
  7547                        LAB_SAVE
  7548                        ; To Save a program you need to save start to end of program
  7549                        ; marked by two consecutive $00.
  7550                        ;
  7551                        ; The Xmodem Save routine in the C02 Monitor expects it's variables
  7552                        ; to be set before making the call via the JMP to V_SAVE.
  7553                        
  7554                        ; The variables used by the C02 Monitor are:
  Mon Feb  8 2021  9:20                                                                                                    Page 121


  7555                        ; - Source address (SCRL/H), Length (LENL/H), plus
  7556                        ; - the Block count set to one and the OPXMDM flag cleared.
  7557                        ;
  7558                        ; SAVE command
  7559                        
  7560 00:CFF9: 20 19 D0          JSR    get_basmem        ; find end of program space
  7561 00:CFFC: A6 2B             LDX    Smeml             ;
  7562 00:CFFE: A5 2C             LDA    Smemh             ; get start address of BASIC program
  7563 00:D000: 86 B8             STX    SRCL              ;
  7564 00:D002: 85 B9             STA    SRCH              ; save in xmodem pointer
  7565                        
  7566 00:D004: A5 0A             LDA    Itempl            ; get end of memory low byte
  7567 00:D006: 38                SEC                      ; set carry flag for subtract
  7568 00:D007: E5 2B             SBC    Smeml             ; subtract start of memory low byte
  7569 00:D009: 85 BC             STA    LENL              ; store to Monitor length low byte
  7570                        
  7571 00:D00B: A5 0B             LDA    Itemph            ; get end of memory high byte
  7572 00:D00D: E5 2C             SBC    Smemh             ; subtract start of memory high byte
  7573 00:D00F: 85 BD             STA    LENH              ; save to Monitor length high byte
  7574                        
  7575 00:D011: A9 01             LDA    #$01              ; get count of one
  7576 00:D013: 85 CC             STA    BLKNO             ; set Xmodem block count
  7577 00:D015: 64 C6             STZ    OPXMDM            ; clear OPXMDM flag
  7578                        
  7579 00:D017: 80 2E             BRA    V_SAVE            ; call Xmodem SAVE vector and return
  7580                        
  7581                        ; Basic program code links line numbers via the first two bytes of
  7582                        ; the program code starting at (Smeml) pointing to the next line of
  7583                        ; Basic code. The end is marked by two consecutive $00 bytes.
  7584                        ;
  7585                        ; This routine, starts at (smeml) which points to the next line of
  7586                        ; Basic code, then calculates the address to the next line after that
  7587                        ; and continues till it locates the last line.
  7588                        ;
  7589                        ; Once the end of Basic program space is found, (Itempl) is updated
  7590                        ; by two, which points to the start of free memory.
  7591                        
  7592                        get_basmem
  7593 00:D019: A5 2B             LDA     Smeml            ; get start address
  7594 00:D01B: 85 0A             STA     Itempl           ; and save to
  7595 00:D01D: A5 2C             LDA     Smemh            ; temp pointer
  7596 00:D01F: 85 0B             STA     Itemph           ; high and low byte
  7597 00:D021: A0 01             LDY     #$01             ; set Y reg for offset of 1
  7598                        
  7599                        scan_bas
  7600 00:D023: B2 0A             LDA     (Itempl)         ; get BASIC low byte line address
  7601 00:D025: AA                TAX                      ; save to X reg (could be next line low address)
  7602 00:D026: F0 08             BEQ     chk_next         ; if zero, might be end, branch and check
  7603 00:D028: B1 0A             LDA     (Itempl),y       ; else, get high byte line address
  7604                        upd_bas
  7605 00:D02A: 85 0B             STA     Itemph           ; update high byte line address
  7606 00:D02C: 86 0A             STX     Itempl           ; update low byte line address
  7607 00:D02E: 80 F3             BRA     scan_bas         ; branch back to find next line
  7608                        
  7609                        chk_next
  7610 00:D030: B1 0A             LDA     (Itempl),y       ; get next byte, BASIC high byte line address
  7611 00:D032: D0 F6             BNE     upd_bas          ; if non-zero, branch to update line address
  7612                        
  7613 00:D034: 20 37 D0          JSR     inc_line         ; else increment line address twice
  7614                        inc_line
  7615 00:D037: E6 0A             INC     Itempl           ; increment low byte count
  7616 00:D039: D0 02             BNE     skp_ith          ; if not zero, skip high byte increment
  7617 00:D03B: E6 0B             INC     Itemph           ; else, increment high byte count
  Mon Feb  8 2021  9:20                                                                                                    Page 122


  7618                        skp_ith
  7619 00:D03D: 60                RTS                      ; return to caller
  7620                        
  7621                        ; system dependant I/O vectors
  7622                        ; these are in RAM and are set by the monitor at start-up
  7623                        
  7624                        V_INPT
  7625 00:D03E: 6C 84 05           JMP   (VEC_IN)          ; non halting scan input device
  7626                        V_OUTP
  7627 00:D041: 6C 86 05           JMP   (VEC_OUT)         ; send byte to output device
  7628                        V_LOAD
  7629 00:D044: 6C 88 05           JMP   (VEC_LD)          ; load BASIC program
  7630                        V_SAVE
  7631 00:D047: 6C 8A 05           JMP   (VEC_SV)          ; save BASIC program
  7632                        V_EXIT
  7633 00:D04A: 6C 8C 05           JMP   (VEC_EXIT)        ; warm start C02 Monitor
  7634                        
  7635                        ; The rest are tables messages and code for RAM
  7636                        
  7637                        ; the rest of the code is tables and BASIC start-up code
  7638                        ; monitor routines required are added below for initialization
  7639                        
  7640                        PG4_TABS
  7641 00:D04D: 00                 .byte $00               ; ctrl-c flag - $00 = enabled
  7642 00:D04E: 00                 .byte $00               ; ctrl-c byte - GET needs this
  7643 00:D04F: 00                 .byte $00               ; ctrl-c byte timeout - GET needs this
  7644 00:D050: 1A CE              .word CTRLC             ; ctrl-c check vector
  7645                        ;
  7646 00:D052: 36 FF              .word B_CHRIN_NW        ; byte in from C02BIOS (no waiting)
  7647 00:D054: 3C FF              .word B_CHROUT          ; byte out from C02BIOS
  7648 00:D056: 15 E0              .word M_LOAD            ; Xmodem LOAD for C02 Monitor
  7649 00:D058: 12 E0              .word M_SAVE            ; Xmodem SAVE for C02 Monitor
  7650 00:D05A: 03 E0              .word M_EXIT            ; Warm start for C02 Monitor
  7651                        
  7652                        PG4_TABE
  7653                        
  7654                        ; page zero initialisation table $00-$0B inclusive
  7655                        
  7656                        StrTab
  7657 00:D05C: 4C                 .byte $4C               ; JMP opcode
  7658 00:D05D: 1F B1              .word LAB_1274          ; warm start vector
  7659                        
  7660 00:D05F: 4C                 .byte $4C               ; JMP opcode
  7661 00:D060: C8 BE              .word LAB_FCER          ; initial user function vector ("Function call" error)
  7662                        
  7663 00:D062: 00                 .byte $00               ; default NULL count
  7664 00:D063: 00                 .byte $00               ; clear terminal position
  7665 00:D064: 50                 .byte $50               ; default terminal width byte = 80
  7666 00:D065: F2                 .byte $F2               ; default limit for TAB = 14
  7667 00:D066: 00 08              .word Ram_base          ; start of user RAM
  7668                        EndTab
  7669                        
  7670                        BOOT_BASIC
  7671                        ; To conserve some space in the C02Monitor allocated EEPROM space, the startup
  7672                        ; routine has been moved here. The goal is to ensure that EnHanced Basic is
  7673                        ; fully self contained and requires nothing but the ROM vectors to function.
  7674                        ; This adds some additional coding, but still ensures total allocated space
  7675                        ; is within 10KB (10240 bytes) of EEPROM space.
  7676                        
  7677 00:D068: A9 9F              LDA   #<LAB_CSMSG          ; point to init message (low addr)
  7678 00:D06A: A0 D0              LDY   #>LAB_CSMSG          ; point to init message (high addr)
  7679 00:D06C: 85 B6              STA   PROMPTL              ; Store low byte
  7680 00:D06E: 84 B7              STY   PROMPTH              ; Store high byte
  Mon Feb  8 2021  9:20                                                                                                    Page 123


  7681                        PROMPT2
  7682 00:D070: B2 B6              LDA   (PROMPTL)            ; Get string data
  7683 00:D072: F0 0B              BEQ   EHB_TRY2             ; If null character, branch to user entry
  7684 00:D074: 20 3C FF           JSR   B_CHROUT             ; Send character to terminal
  7685 00:D077: E6 B6              INC   PROMPTL              ; Increment low byte index
  7686 00:D079: D0 F5              BNE   PROMPT2              ; Loop back for next character
  7687 00:D07B: E6 B7              INC   PROMPTH              ; Increment high byte index
  7688 00:D07D: 80 F1              BRA   PROMPT2              ; Loop back and continue printing
  7689                        
  7690                        EHB_TRY2
  7691 00:D07F: 20 36 FF           JSR   B_CHRIN_NW           ; Request keystroke input from terminal
  7692 00:D082: 90 FB              BCC   EHB_TRY2             ; If carry clear, nothing entered, loop back
  7693 00:D084: C9 61              CMP   #$61                 ; Check for lower case value range
  7694 00:D086: 90 02              BCC   UCOK                 ; Branch if < $61, control code/upper-case/numeric
  7695 00:D088: E9 20              SBC   #$20                 ; Subtract $20 to convert to upper case
  7696                        UCOK
  7697 00:D08A: C9 43              CMP   #"C"                 ; Check for Cold start
  7698 00:D08C: F0 0E              BEQ   EHB_COLD             ; If yes, go Cold Start
  7699 00:D08E: C9 57              CMP   #"W"                 ; Check for Warm start
  7700 00:D090: F0 07              BEQ   EHB_WARM             ; If yes, go Warm start
  7701 00:D092: A9 07              LDA   #$07                 ; Get bell character
  7702 00:D094: 20 3C FF           JSR   B_CHROUT             ; Else, beep for entry error
  7703 00:D097: 80 E6              BRA   EHB_TRY2             ; Branch back and try again
  7704                        
  7705                        EHB_WARM
  7706 00:D099: 4C 00 00           JMP   $0000                ; Warm start soft vector
  7707                        
  7708                        EHB_COLD
  7709 00:D09C: 4C 03 B0           JMP   LAB_COLD             ; Cold start routine
  7710                        
  7711                        LAB_CSMSG
  7712 00:D09F: 0D 0A              .byte $0D,$0A
  7713 00:D0A1: 36 35 43 30        .byte "65C02 Enhanced BASIC Version 2.22p5C02"
       00:D0A5: 32 20 45 6E 
       00:D0A9: 68 61 6E 63 
       00:D0AD: 65 64 20 42 
       00:D0B1: 41 53 49 43 
       00:D0B5: 20 56 65 72 
       00:D0B9: 73 69 6F 6E 
       00:D0BD: 20 32 2E 32 
       00:D0C1: 32 70 35 43 
       00:D0C5: 30 32 
  7714 00:D0C7: 0D 0A              .byte $0D,$0A
  7715 00:D0C9: 20 5B 43 5D        .byte " [C]old/[W]arm start? ",$00
       00:D0CD: 6F 6C 64 2F 
       00:D0D1: 5B 57 5D 61 
       00:D0D5: 72 6D 20 73 
       00:D0D9: 74 61 72 74 
       00:D0DD: 3F 20 00 
  7716                        
  7717                        LAB_SMSG
  7718 00:D0E0: 20 42 79 74        .byte " Bytes free",$00
       00:D0E4: 65 73 20 66 
       00:D0E8: 72 65 65 00 
  7719                        
  7720                        ; numeric constants and series
  7721                        ; cleaned up to removed commented lines which were replaced
  7722                        
  7723                                                      ; constants and series for LOG(n)
  7724                        LAB_25A0
  7725 00:D0EC: 02                 .byte $02               ; counter
  7726 00:D0ED: 80 19 56 62        .byte $80,$19,$56,$62   ; 0.59898
  7727 00:D0F1: 80 76 22 F3        .byte $80,$76,$22,$F3   ; 0.96147
  Mon Feb  8 2021  9:20                                                                                                    Page 124


  7728 00:D0F5: 82 38 AA 40        .byte $82,$38,$AA,$40   ; 2.88539
  7729                        
  7730                        LAB_25AD
  7731 00:D0F9: 80 35 04 F3        .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
  7732                        LAB_25B1
  7733 00:D0FD: 81 35 04 F3        .byte $81,$35,$04,$F3   ; 1.41421   root 2
  7734                        LAB_25B5
  7735 00:D101: 80 80 00 00        .byte $80,$80,$00,$00   ; -0.5
  7736                        LAB_25B9
  7737 00:D105: 80 31 72 18        .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
  7738                        
  7739                                                      ; numeric PRINT constants
  7740                        LAB_2947
  7741 00:D109: 91 43 4F F8        .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
  7742                        LAB_294B
  7743 00:D10D: 94 74 23 F7        .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
  7744                        LAB_294F
  7745 00:D111: 94 74 24 00        .byte $94,$74,$24,$00   ; 1000000
  7746                        
  7747                                                      ; EXP(n) constants and series
  7748                        LAB_2AFA
  7749 00:D115: 81 38 AA 3B        .byte $81,$38,$AA,$3B   ; 1.4427 (1/LOG base 2 e)
  7750                        LAB_2AFE
  7751 00:D119: 06                 .byte $06               ; counter
  7752 00:D11A: 74 63 90 8C        .byte $74,$63,$90,$8C   ; 2.17023e-4
  7753 00:D11E: 77 23 0C AB        .byte $77,$23,$0C,$AB   ; 0.00124
  7754 00:D122: 7A 1E 94 00        .byte $7A,$1E,$94,$00   ; 0.00968
  7755 00:D126: 7C 63 42 80        .byte $7C,$63,$42,$80   ; 0.05548
  7756 00:D12A: 7E 75 FE D0        .byte $7E,$75,$FE,$D0   ; 0.24023
  7757 00:D12E: 80 31 72 15        .byte $80,$31,$72,$15   ; 0.69315
  7758 00:D132: 81 00 00 00        .byte $81,$00,$00,$00   ; 1.00000
  7759                        
  7760                                                      ; trigonometric constants and series
  7761                        LAB_2C78
  7762 00:D136: 81 49 0F DB        .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
  7763                        LAB_2C84
  7764 00:D13A: 04                 .byte $04               ; counter
  7765 00:D13B: 86 1E D7 FB        .byte $86,$1E,$D7,$FB   ; 39.7109
  7766 00:D13F: 87 99 26 65        .byte $87,$99,$26,$65   ;-76.575
  7767 00:D143: 87 23 34 58        .byte $87,$23,$34,$58   ; 81.6022
  7768 00:D147: 86 A5 5D E1        .byte $86,$A5,$5D,$E1   ;-41.3417
  7769                        LAB_2C7C
  7770 00:D14B: 83 49 0F DB        .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
  7771                        
  7772                        LAB_2CC9
  7773 00:D14F: 08                 .byte $08               ; counter
  7774 00:D150: 78 3A C5 37        .byte $78,$3A,$C5,$37   ; 0.00285
  7775 00:D154: 7B 83 A2 5C        .byte $7B,$83,$A2,$5C   ;-0.0160686
  7776 00:D158: 7C 2E DD 4D        .byte $7C,$2E,$DD,$4D   ; 0.0426915
  7777 00:D15C: 7D 99 B0 1E        .byte $7D,$99,$B0,$1E   ;-0.0750429
  7778 00:D160: 7D 59 ED 24        .byte $7D,$59,$ED,$24   ; 0.106409
  7779 00:D164: 7E 91 72 00        .byte $7E,$91,$72,$00   ;-0.142036
  7780 00:D168: 7E 4C B9 73        .byte $7E,$4C,$B9,$73   ; 0.199926
  7781 00:D16C: 7F AA AA 53        .byte $7F,$AA,$AA,$53   ;-0.333331
  7782                        
  7783             0000D171   LAB_1D96    .EQU *+1          ; $00,$00 used for undefined variables
  7784                        LAB_259C
  7785 00:D170: 81 00 00 00        .byte $81,$00,$00,$00   ; 1.000000, used for INC
  7786                        LAB_2AFD
  7787 00:D174: 81 80 00 00        .byte $81,$80,$00,$00   ; -1.00000, used for DEC, must be on the same page as +1.00
  7788                        
  7789                                                      ; misc constants
  7790                        LAB_1DF7
  Mon Feb  8 2021  9:20                                                                                                    Page 125


  7791 00:D178: 90                 .byte $90               ;-32768 (uses first three bytes from 0.5)
  7792                        LAB_2A96
  7793 00:D179: 80 00 00 00        .byte $80,$00,$00,$00   ; 0.5
  7794                        LAB_2C80
  7795 00:D17D: 7F 00 00 00        .byte $7F,$00,$00,$00   ; 0.25
  7796                        LAB_26B5
  7797 00:D181: 84 20 00 00        .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
  7798                        
  7799                        ; This table is used in converting numbers to ASCII.
  7800                        
  7801                        LAB_2A9A
  7802             0000D186   LAB_2A9B .EQU LAB_2A9A+1
  7803             0000D187   LAB_2A9C .EQU LAB_2A9B+1
  7804 00:D185: FE 79 60           .byte $FE,$79,$60       ; -100000
  7805 00:D188: 00 27 10           .byte $00,$27,$10       ; 10000
  7806 00:D18B: FF FC 18           .byte $FF,$FC,$18       ; -1000
  7807 00:D18E: 00 00 64           .byte $00,$00,$64       ; 100
  7808 00:D191: FF FF F6           .byte $FF,$FF,$F6       ; -10
  7809 00:D194: 00 00 01           .byte $00,$00,$01       ; 1
  7810                        
  7811                        LAB_CTBL
  7812 00:D197: DF B4              .word LAB_END-1         ; END
  7813 00:D199: 20 B4              .word LAB_FOR-1         ; FOR
  7814 00:D19B: FE B9              .word LAB_NEXT-1        ; NEXT
  7815 00:D19D: 42 B6              .word LAB_DATA-1        ; DATA
  7816 00:D19F: E6 B8              .word LAB_INPUT-1       ; INPUT
  7817 00:D1A1: 00 BD              .word LAB_DIM-1         ; DIM
  7818 00:D1A3: 05 B9              .word LAB_READ-1        ; READ
  7819 00:D1A5: 5D B7              .word LAB_LET-1         ; LET
  7820 00:D1A7: 2F B7              .word LAB_DEC-1         ; DEC new command
  7821 00:D1A9: A1 B5              .word LAB_GOTO-1        ; GOTO
  7822 00:D1AB: 60 B5              .word LAB_RUN-1         ; RUN
  7823 00:D1AD: 71 B6              .word LAB_IF-1          ; IF
  7824 00:D1AF: 00 B5              .word LAB_RESTORE-1     ; RESTORE modified command
  7825 00:D1B1: 84 B5              .word LAB_GOSUB-1       ; GOSUB
  7826 00:D1B3: 2D B6              .word LAB_RETURN-1      ; RETURN
  7827 00:D1B5: D6 B6              .word LAB_REM-1         ; REM
  7828 00:D1B7: DD B4              .word LAB_STOP-1        ; STOP
  7829 00:D1B9: DF B6              .word LAB_ON-1          ; ON modified command
  7830 00:D1BB: 3E B5              .word LAB_NULL-1        ; NULL modified command
  7831 00:D1BD: 33 B7              .word LAB_INC-1         ; INC new command
  7832 00:D1BF: 15 C5              .word LAB_WAIT-1        ; WAIT
  7833 00:D1C1: CF CF              .word LAB_LOAD-1        ; LOAD
  7834 00:D1C3: F8 CF              .word LAB_SAVE-1        ; SAVE
  7835 00:D1C5: 12 C0              .word LAB_DEF-1         ; DEF
  7836 00:D1C7: 9A C4              .word LAB_POKE-1        ; POKE
  7837 00:D1C9: B6 C4              .word LAB_DOKE-1        ; DOKE new command
  7838 00:D1CB: 03 C5              .word LAB_CALL-1        ; CALL new command
  7839 00:D1CD: 6A B5              .word LAB_DO-1          ; DO new command
  7840 00:D1CF: D3 B5              .word LAB_LOOP-1        ; LOOP new command
  7841 00:D1D1: F8 B7              .word LAB_PRINT-1       ; PRINT
  7842 00:D1D3: 44 B5              .word LAB_CONT-1        ; CONT
  7843 00:D1D5: 6B B3              .word LAB_LIST-1        ; LIST
  7844 00:D1D7: 68 B3              .word LAB_CLEAR-1       ; CLEAR
  7845 00:D1D9: 1B B3              .word LAB_NEW-1         ; NEW
  7846 00:D1DB: B2 CE              .word LAB_WDTH-1        ; WIDTH new command
  7847 00:D1DD: CA B7              .word LAB_GET-1         ; GET new command
  7848 00:D1DF: DB C4              .word LAB_SWAP-1        ; SWAP new command
  7849 00:D1E1: F1 CC              .word LAB_BITSET-1      ; BITSET new command
  7850 00:D1E3: 05 CD              .word LAB_BITCLR-1      ; BITCLR new command
  7851 00:D1E5: 49 D0              .word V_EXIT-1          ; EXIT new command (exits to C02 Monitor)
  7852                        
  7853                        ; function pre process routine table
  Mon Feb  8 2021  9:20                                                                                                    Page 126


  7854                        
  7855                        LAB_FTPL
  7856             0000D1E8   LAB_FTPM    .EQU LAB_FTPL+$01
  7857 00:D1E7: 0B BC              .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
  7858 00:D1E9: 0B BC              .word LAB_PPFN-1        ; INT(n)          "
  7859 00:D1EB: 0B BC              .word LAB_PPFN-1        ; ABS(n)          "
  7860 00:D1ED: 83 BA              .word LAB_EVEZ-1        ; USR(x)    process any expression
  7861 00:D1EF: 87 BB              .word LAB_1BF7-1        ; FRE(x)          "
  7862 00:D1F1: 87 BB              .word LAB_1BF7-1        ; POS(x)          "
  7863 00:D1F3: 0B BC              .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
  7864 00:D1F5: 0B BC              .word LAB_PPFN-1        ; RND(n)          "
  7865 00:D1F7: 0B BC              .word LAB_PPFN-1        ; LOG(n)          "
  7866 00:D1F9: 0B BC              .word LAB_PPFN-1        ; EXP(n)          "
  7867 00:D1FB: 0B BC              .word LAB_PPFN-1        ; COS(n)          "
  7868 00:D1FD: 0B BC              .word LAB_PPFN-1        ; SIN(n)          "
  7869 00:D1FF: 0B BC              .word LAB_PPFN-1        ; TAN(n)          "
  7870 00:D201: 0B BC              .word LAB_PPFN-1        ; ATN(n)          "
  7871 00:D203: 0B BC              .word LAB_PPFN-1        ; PEEK(n)         "
  7872 00:D205: 0B BC              .word LAB_PPFN-1        ; DEEK(n)         "
  7873 00:D207: 00 00              .word $0000             ; SADD()    none
  7874 00:D209: 05 BC              .word LAB_PPFS-1        ; LEN($)    process string expression in ()
  7875 00:D20B: 0B BC              .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
  7876 00:D20D: 05 BC              .word LAB_PPFS-1        ; VAL($)    process string expression in ()
  7877 00:D20F: 05 BC              .word LAB_PPFS-1        ; ASC($)          "
  7878 00:D211: 05 BC              .word LAB_PPFS-1        ; UCASE$($)       "
  7879 00:D213: 05 BC              .word LAB_PPFS-1        ; LCASE$($)       "
  7880 00:D215: 0B BC              .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
  7881 00:D217: 2E BC              .word LAB_BHSS-1        ; HEX$(n)         "
  7882 00:D219: 2E BC              .word LAB_BHSS-1        ; BIN$(n)         "
  7883 00:D21B: 00 00              .word $0000             ; BITTST()  none
  7884 00:D21D: 49 CE              .word LAB_MMPP-1        ; MAX()     process numeric expression
  7885 00:D21F: 49 CE              .word LAB_MMPP-1        ; MIN()           "
  7886 00:D221: 11 BC              .word LAB_PPBI-1        ; PI        advance pointer
  7887 00:D223: 11 BC              .word LAB_PPBI-1        ; TWOPI           "
  7888 00:D225: 00 00              .word $0000             ; VARPTR()  none
  7889 00:D227: 16 BC              .word LAB_LRMS-1        ; LEFT$()   process string expression
  7890 00:D229: 16 BC              .word LAB_LRMS-1        ; RIGHT$()        "
  7891 00:D22B: 16 BC              .word LAB_LRMS-1        ; MID$()          "
  7892                        
  7893                        ; action addresses for functions
  7894                        
  7895                        LAB_FTBL
  7896             0000D22E   LAB_FTBM    .EQU LAB_FTBL+$01
  7897 00:D22D: 7B C8              .word LAB_SGN-1         ; SGN()
  7898 00:D22F: 00 C9              .word LAB_INT-1         ; INT()
  7899 00:D231: 94 C8              .word LAB_ABS-1         ; ABS()
  7900 00:D233: BC CC              .word LAB_USR-1         ; USR()
  7901 00:D235: E3 BF              .word LAB_FRE-1         ; FRE()
  7902 00:D237: 02 C0              .word LAB_POS-1         ; POS()
  7903 00:D239: 08 CF              .word LAB_SQR-1         ; SQR()
  7904 00:D23B: 13 CC              .word LAB_RND-1         ; RND() modified function
  7905 00:D23D: 82 C6              .word LAB_LOG-1         ; LOG()
  7906 00:D23F: 77 CB              .word LAB_EXP-1         ; EXP()
  7907 00:D241: 47 CC              .word LAB_COS-1         ; COS()
  7908 00:D243: 4E CC              .word LAB_SIN-1         ; SIN()
  7909 00:D245: 95 CC              .word LAB_TAN-1         ; TAN()
  7910 00:D247: C2 CC              .word LAB_ATN-1         ; ATN()
  7911 00:D249: 8F C4              .word LAB_PEEK-1        ; PEEK()
  7912 00:D24B: A3 C4              .word LAB_DEEK-1        ; DEEK() new function
  7913 00:D24D: EB C3              .word LAB_SADD-1        ; SADD() new function
  7914 00:D24F: 04 C4              .word LAB_LENS-1        ; LEN()
  7915 00:D251: C0 C0              .word LAB_STRS-1        ; STR$()
  7916 00:D253: 2F C4              .word LAB_VAL-1         ; VAL()
  Mon Feb  8 2021  9:20                                                                                                    Page 127


  7917 00:D255: 0F C4              .word LAB_ASC-1         ; ASC()
  7918 00:D257: C9 C3              .word LAB_UCASE-1       ; UCASE$() new function
  7919 00:D259: A8 C3              .word LAB_LCASE-1       ; LCASE$()  new function
  7920 00:D25B: 1F C3              .word LAB_CHRS-1        ; CHR$()
  7921 00:D25D: 92 CD              .word LAB_HEXS-1        ; HEX$() new function
  7922 00:D25F: 43 CD              .word LAB_BINS-1        ; BIN$() new function
  7923 00:D261: 1B CD              .word LAB_BTST-1        ; BITTST() new function
  7924 00:D263: 4F CE              .word LAB_MAX-1         ; MAX() new function
  7925 00:D265: 5F CE              .word LAB_MIN-1         ; MIN() new function
  7926 00:D267: A3 CF              .word LAB_PI-1          ; PI new function
  7927 00:D269: AD CF              .word LAB_TWOPI-1       ; TWOPI new function
  7928 00:D26B: 93 CF              .word LAB_VARPTR-1      ; VARPTR() new function
  7929 00:D26D: 2E C3              .word LAB_LEFT-1        ; LEFT$()
  7930 00:D26F: 37 C3              .word LAB_RIGHT-1       ; RIGHT$()
  7931 00:D271: 65 C3              .word LAB_MIDS-1        ; MID$()
  7932                        
  7933                        ; hierarchy and action addresses for operator
  7934                        
  7935                        LAB_OPPT
  7936 00:D273: 79                 .byte $79               ; +
  7937 00:D274: 4C C5              .word LAB_ADD-1
  7938 00:D276: 79                 .byte $79               ; -
  7939 00:D277: 32 C5              .word LAB_SUBTRACT-1
  7940 00:D279: 7B                 .byte $7B               ; *
  7941 00:D27A: C3 C6              .word LAB_MULTIPLY-1
  7942 00:D27C: 7B                 .byte $7B               ; /
  7943 00:D27D: 89 C7              .word LAB_DIVIDE-1
  7944 00:D27F: 7F                 .byte $7F               ; ^
  7945 00:D280: 33 CB              .word LAB_POWER-1
  7946 00:D282: 50                 .byte $50               ; AND
  7947 00:D283: 77 BC              .word LAB_AND-1
  7948 00:D285: 46                 .byte $46               ; EOR new operator
  7949 00:D286: 5D BC              .word LAB_EOR-1
  7950 00:D288: 46                 .byte $46               ; OR
  7951 00:D289: 6A BC              .word LAB_OR-1
  7952 00:D28B: 56                 .byte $56               ; >> new operator
  7953 00:D28C: 22 BD              .word LAB_RSHIFT-1
  7954 00:D28E: 56                 .byte $56               ; << new operator
  7955 00:D28F: 0A BD              .word LAB_LSHIFT-1
  7956 00:D291: 7D                 .byte $7D               ; >
  7957 00:D292: 6C CB              .word LAB_GTHAN-1
  7958 00:D294: 5A                 .byte $5A               ; =
  7959 00:D295: B0 BB              .word LAB_EQUAL-1
  7960 00:D297: 64                 .byte $64               ; <
  7961 00:D298: 98 BC              .word LAB_LTHAN-1
  7962                        
  7963                        ; keywords start with ..
  7964                        ; this is the first character table and must be in alphabetic order
  7965                        
  7966                        TAB_1STC
  7967 00:D29A: 2A                 .byte "*"
  7968 00:D29B: 2B                 .byte "+"
  7969 00:D29C: 2D                 .byte "-"
  7970 00:D29D: 2F                 .byte "/"
  7971 00:D29E: 3C                 .byte "<"
  7972 00:D29F: 3D                 .byte "="
  7973 00:D2A0: 3E                 .byte ">"
  7974 00:D2A1: 3F                 .byte "?"
  7975 00:D2A2: 41                 .byte "A"
  7976 00:D2A3: 42                 .byte "B"
  7977 00:D2A4: 43                 .byte "C"
  7978 00:D2A5: 44                 .byte "D"
  7979 00:D2A6: 45                 .byte "E"
  Mon Feb  8 2021  9:20                                                                                                    Page 128


  7980 00:D2A7: 46                 .byte "F"
  7981 00:D2A8: 47                 .byte "G"
  7982 00:D2A9: 48                 .byte "H"
  7983 00:D2AA: 49                 .byte "I"
  7984 00:D2AB: 4C                 .byte "L"
  7985 00:D2AC: 4D                 .byte "M"
  7986 00:D2AD: 4E                 .byte "N"
  7987 00:D2AE: 4F                 .byte "O"
  7988 00:D2AF: 50                 .byte "P"
  7989 00:D2B0: 52                 .byte "R"
  7990 00:D2B1: 53                 .byte "S"
  7991 00:D2B2: 54                 .byte "T"
  7992 00:D2B3: 55                 .byte "U"
  7993 00:D2B4: 56                 .byte "V"
  7994 00:D2B5: 57                 .byte "W"
  7995 00:D2B6: 5E                 .byte "^"
  7996 00:D2B7: 00                 .byte $00               ; table terminator
  7997                        
  7998                        ; pointers to keyword tables
  7999                        
  8000                        TAB_CHRT
  8001 00:D2B8: F2 D2              .word TAB_STAR          ; table for "*"
  8002 00:D2BA: F4 D2              .word TAB_PLUS          ; table for "+"
  8003 00:D2BC: F6 D2              .word TAB_MNUS          ; table for "-"
  8004 00:D2BE: F8 D2              .word TAB_SLAS          ; table for "/"
  8005 00:D2C0: FA D2              .word TAB_LESS          ; table for "<"
  8006 00:D2C2: FE D2              .word TAB_EQUL          ; table for "="
  8007 00:D2C4: 00 D3              .word TAB_MORE          ; table for ">"
  8008 00:D2C6: 04 D3              .word TAB_QEST          ; table for "?"
  8009 00:D2C8: 06 D3              .word TAB_ASCA          ; table for "A"
  8010 00:D2CA: 16 D3              .word TAB_ASCB          ; table for "B"
  8011 00:D2CC: 2F D3              .word TAB_ASCC          ; table for "C"
  8012 00:D2CE: 46 D3              .word TAB_ASCD          ; table for "D"
  8013 00:D2D0: 5F D3              .word TAB_ASCE          ; table for "E"
  8014 00:D2D2: 72 D3              .word TAB_ASCF          ; table for "F"
  8015 00:D2D4: 7C D3              .word TAB_ASCG          ; table for "G"
  8016 00:D2D6: 89 D3              .word TAB_ASCH          ; table for "H"
  8017 00:D2D8: 8F D3              .word TAB_ASCI          ; table for "I"
  8018 00:D2DA: 9E D3              .word TAB_ASCL          ; table for "L"
  8019 00:D2DC: C3 D3              .word TAB_ASCM          ; table for "M"
  8020 00:D2DE: D1 D3              .word TAB_ASCN          ; table for "N"
  8021 00:D2E0: E0 D3              .word TAB_ASCO          ; table for "O"
  8022 00:D2E2: E5 D3              .word TAB_ASCP          ; table for "P"
  8023 00:D2E4: FA D3              .word TAB_ASCR          ; table for "R"
  8024 00:D2E6: 1D D4              .word TAB_ASCS          ; table for "S"
  8025 00:D2E8: 48 D4              .word TAB_ASCT          ; table for "T"
  8026 00:D2EA: 5C D4              .word TAB_ASCU          ; table for "U"
  8027 00:D2EC: 6D D4              .word TAB_ASCV          ; table for "V"
  8028 00:D2EE: 79 D4              .word TAB_ASCW          ; table for "W"
  8029 00:D2F0: 88 D4              .word TAB_POWR          ; table for "^"
  8030                        
  8031                        ; tables for each start character, note if a longer keyword with the same start
  8032                        ; letters as a shorter one exists then it must come first, else the list is in
  8033                        ; alphabetical order as follows ..
  8034                        
  8035                        ; [keyword,token
  8036                        ; [keyword,token]]
  8037                        ; end marker (#$00)
  8038                        
  8039                        TAB_STAR
  8040 00:D2F2: B4 00              .byte TK_MUL,$00        ; *
  8041                        TAB_PLUS
  8042 00:D2F4: B2 00              .byte TK_PLUS,$00       ; +
  Mon Feb  8 2021  9:20                                                                                                    Page 129


  8043                        TAB_MNUS
  8044 00:D2F6: B3 00              .byte TK_MINUS,$00      ; -
  8045                        TAB_SLAS
  8046 00:D2F8: B5 00              .byte TK_DIV,$00        ; /
  8047                        TAB_LESS
  8048                        LBB_LSHIFT
  8049 00:D2FA: 3C BB              .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
  8050 00:D2FC: BE                 .byte TK_LT             ; <
  8051 00:D2FD: 00                 .byte $00
  8052                        TAB_EQUL
  8053 00:D2FE: BD 00              .byte TK_EQUAL,$00      ; =
  8054                        TAB_MORE
  8055                        LBB_RSHIFT
  8056 00:D300: 3E BA              .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
  8057 00:D302: BC                 .byte TK_GT             ; >
  8058 00:D303: 00                 .byte $00
  8059                        TAB_QEST
  8060 00:D304: 9D 00              .byte TK_PRINT,$00      ; ?
  8061                        TAB_ASCA
  8062                        LBB_ABS
  8063 00:D306: 42 53 28 C1        .byte "BS(",TK_ABS      ; ABS(
  8064                        LBB_AND
  8065 00:D30A: 4E 44 B7           .byte "ND",TK_AND       ; AND
  8066                        LBB_ASC
  8067 00:D30D: 53 43 28 D3        .byte "SC(",TK_ASC      ; ASC(
  8068                        LBB_ATN
  8069 00:D311: 54 4E 28 CC        .byte "TN(",TK_ATN      ; ATN(
  8070 00:D315: 00                 .byte $00
  8071                        TAB_ASCB
  8072                        LBB_BINS
  8073 00:D316: 49 4E 24 28        .byte "IN$(",TK_BINS    ; BIN$(
       00:D31A: D8 
  8074                        LBB_BITCLR
  8075 00:D31B: 49 54 43 4C        .byte "ITCLR",TK_BITCLR ; BITCLR
       00:D31F: 52 A6 
  8076                        LBB_BITSET
  8077 00:D321: 49 54 53 45        .byte "ITSET",TK_BITSET ; BITSET
       00:D325: 54 A5 
  8078                        LBB_BITTST
  8079 00:D327: 49 54 54 53        .byte "ITTST(",TK_BITTST
       00:D32B: 54 28 D9 
  8080                                                      ; BITTST(
  8081 00:D32E: 00                 .byte $00
  8082                        TAB_ASCC
  8083                        LBB_CALL
  8084 00:D32F: 41 4C 4C 9A        .byte "ALL",TK_CALL     ; CALL
  8085                        LBB_CHRS
  8086 00:D333: 48 52 24 28        .byte "HR$(",TK_CHRS    ; CHR$(
       00:D337: D6 
  8087                        LBB_CLEAR
  8088 00:D338: 4C 45 41 52        .byte "LEAR",TK_CLEAR   ; CLEAR
       00:D33C: A0 
  8089                        LBB_CONT
  8090 00:D33D: 4F 4E 54 9E        .byte "ONT",TK_CONT     ; CONT
  8091                        LBB_COS
  8092 00:D341: 4F 53 28 C9        .byte "OS(",TK_COS      ; COS(
  8093 00:D345: 00                 .byte $00
  8094                        TAB_ASCD
  8095                        LBB_DATA
  8096 00:D346: 41 54 41 83        .byte "ATA",TK_DATA     ; DATA
  8097                        LBB_DEC
  8098 00:D34A: 45 43 88           .byte "EC",TK_DEC       ; DEC
  8099                        LBB_DEEK
  Mon Feb  8 2021  9:20                                                                                                    Page 130


  8100 00:D34D: 45 45 4B 28        .byte "EEK(",TK_DEEK    ; DEEK(
       00:D351: CE 
  8101                        LBB_DEF
  8102 00:D352: 45 46 97           .byte "EF",TK_DEF       ; DEF
  8103                        LBB_DIM
  8104 00:D355: 49 4D 85           .byte "IM",TK_DIM       ; DIM
  8105                        LBB_DOKE
  8106 00:D358: 4F 4B 45 99        .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
  8107                        LBB_DO
  8108 00:D35C: 4F 9B              .byte "O",TK_DO         ; DO
  8109 00:D35E: 00                 .byte $00
  8110                        TAB_ASCE
  8111                        LBB_ELSE
  8112 00:D35F: 4C 53 45 A9        .byte "LSE",TK_ELSE     ; ELSE
  8113                        LBB_END
  8114 00:D363: 4E 44 80           .byte "ND",TK_END       ; END
  8115                        LBB_EOR
  8116 00:D366: 4F 52 B8           .byte "OR",TK_EOR       ; EOR
  8117                        LBB_EXP
  8118 00:D369: 58 50 28 C8        .byte "XP(",TK_EXP      ; EXP(
  8119                        LBB_EXIT
  8120 00:D36D: 58 49 54 A7        .byte "XIT",TK_EXIT     ; EXIT
  8121 00:D371: 00                 .byte $00
  8122                        TAB_ASCF
  8123                        LBB_FN
  8124 00:D372: 4E AB              .byte "N",TK_FN         ; FN
  8125                        LBB_FOR
  8126 00:D374: 4F 52 81           .byte "OR",TK_FOR       ; FOR
  8127                        LBB_FRE
  8128 00:D377: 52 45 28 C3        .byte "RE(",TK_FRE      ; FRE(
  8129 00:D37B: 00                 .byte $00
  8130                        TAB_ASCG
  8131                        LBB_GET
  8132 00:D37C: 45 54 A3           .byte "ET",TK_GET       ; GET
  8133                        LBB_GOSUB
  8134 00:D37F: 4F 53 55 42        .byte "OSUB",TK_GOSUB   ; GOSUB
       00:D383: 8D 
  8135                        LBB_GOTO
  8136 00:D384: 4F 54 4F 89        .byte "OTO",TK_GOTO     ; GOTO
  8137 00:D388: 00                 .byte $00
  8138                        TAB_ASCH
  8139                        LBB_HEXS
  8140 00:D389: 45 58 24 28        .byte "EX$(",TK_HEXS    ; HEX$(
       00:D38D: D7 
  8141 00:D38E: 00                 .byte $00
  8142                        TAB_ASCI
  8143                        LBB_IF
  8144 00:D38F: 46 8B              .byte "F",TK_IF         ; IF
  8145                        LBB_INC
  8146 00:D391: 4E 43 93           .byte "NC",TK_INC       ; INC
  8147                        LBB_INPUT
  8148 00:D394: 4E 50 55 54        .byte "NPUT",TK_INPUT   ; INPUT
       00:D398: 84 
  8149                        LBB_INT
  8150 00:D399: 4E 54 28 C0        .byte "NT(",TK_INT      ; INT(
  8151 00:D39D: 00                 .byte $00
  8152                        TAB_ASCL
  8153                        LBB_LCASES
  8154 00:D39E: 43 41 53 45        .byte "CASE$(",TK_LCASES
       00:D3A2: 24 28 D5 
  8155                                                      ; LCASE$(
  8156                        LBB_LEFTS
  8157 00:D3A5: 45 46 54 24        .byte "EFT$(",TK_LEFTS  ; LEFT$(
  Mon Feb  8 2021  9:20                                                                                                    Page 131


       00:D3A9: 28 DF 
  8158                        LBB_LEN
  8159 00:D3AB: 45 4E 28 D0        .byte "EN(",TK_LEN      ; LEN(
  8160                        LBB_LET
  8161 00:D3AF: 45 54 87           .byte "ET",TK_LET       ; LET
  8162                        LBB_LIST
  8163 00:D3B2: 49 53 54 9F        .byte "IST",TK_LIST     ; LIST
  8164                        LBB_LOAD
  8165 00:D3B6: 4F 41 44 95        .byte "OAD",TK_LOAD     ; LOAD
  8166                        LBB_LOG
  8167 00:D3BA: 4F 47 28 C7        .byte "OG(",TK_LOG      ; LOG(
  8168                        LBB_LOOP
  8169 00:D3BE: 4F 4F 50 9C        .byte "OOP",TK_LOOP     ; LOOP
  8170 00:D3C2: 00                 .byte $00
  8171                        TAB_ASCM
  8172                        LBB_MAX
  8173 00:D3C3: 41 58 28 DA        .byte "AX(",TK_MAX      ; MAX(
  8174                        LBB_MIDS
  8175 00:D3C7: 49 44 24 28        .byte "ID$(",TK_MIDS    ; MID$(
       00:D3CB: E1 
  8176                        LBB_MIN
  8177 00:D3CC: 49 4E 28 DB        .byte "IN(",TK_MIN      ; MIN(
  8178 00:D3D0: 00                 .byte $00
  8179                        TAB_ASCN
  8180                        LBB_NEW
  8181 00:D3D1: 45 57 A1           .byte "EW",TK_NEW       ; NEW
  8182                        LBB_NEXT
  8183 00:D3D4: 45 58 54 82        .byte "EXT",TK_NEXT     ; NEXT
  8184                        LBB_NOT
  8185 00:D3D8: 4F 54 AE           .byte "OT",TK_NOT       ; NOT
  8186                        LBB_NULL
  8187 00:D3DB: 55 4C 4C 92        .byte "ULL",TK_NULL     ; NULL
  8188 00:D3DF: 00                 .byte $00
  8189                        TAB_ASCO
  8190                        LBB_ON
  8191 00:D3E0: 4E 91              .byte "N",TK_ON         ; ON
  8192                        LBB_OR
  8193 00:D3E2: 52 B9              .byte "R",TK_OR         ; OR
  8194 00:D3E4: 00                 .byte $00
  8195                        TAB_ASCP
  8196                        LBB_PEEK
  8197 00:D3E5: 45 45 4B 28        .byte "EEK(",TK_PEEK    ; PEEK(
       00:D3E9: CD 
  8198                        LBB_PI
  8199 00:D3EA: 49 DC              .byte "I",TK_PI         ; PI
  8200                        LBB_POKE
  8201 00:D3EC: 4F 4B 45 98        .byte "OKE",TK_POKE     ; POKE
  8202                        LBB_POS
  8203 00:D3F0: 4F 53 28 C4        .byte "OS(",TK_POS      ; POS(
  8204                        LBB_PRINT
  8205 00:D3F4: 52 49 4E 54        .byte "RINT",TK_PRINT   ; PRINT
       00:D3F8: 9D 
  8206 00:D3F9: 00                 .byte $00
  8207                        TAB_ASCR
  8208                        LBB_READ
  8209 00:D3FA: 45 41 44 86        .byte "EAD",TK_READ     ; READ
  8210                        LBB_REM
  8211 00:D3FE: 45 4D 8F           .byte "EM",TK_REM       ; REM
  8212                        LBB_RESTORE
  8213 00:D401: 45 53 54 4F        .byte "ESTORE",TK_RESTORE
       00:D405: 52 45 8C 
  8214                                                      ; RESTORE
  8215                        LBB_RETURN
  Mon Feb  8 2021  9:20                                                                                                    Page 132


  8216 00:D408: 45 54 55 52        .byte "ETURN",TK_RETURN ; RETURN
       00:D40C: 4E 8E 
  8217                        LBB_RIGHTS
  8218 00:D40E: 49 47 48 54        .byte "IGHT$(",TK_RIGHTS
       00:D412: 24 28 E0 
  8219                                                      ; RIGHT$(
  8220                        LBB_RND
  8221 00:D415: 4E 44 28 C6        .byte "ND(",TK_RND      ; RND(
  8222                        LBB_RUN
  8223 00:D419: 55 4E 8A           .byte "UN",TK_RUN       ; RUN
  8224 00:D41C: 00                 .byte $00
  8225                        TAB_ASCS
  8226                        LBB_SADD
  8227 00:D41D: 41 44 44 28        .byte "ADD(",TK_SADD    ; SADD(
       00:D421: CF 
  8228                        LBB_SAVE
  8229 00:D422: 41 56 45 96        .byte "AVE",TK_SAVE     ; SAVE
  8230                        LBB_SGN
  8231 00:D426: 47 4E 28 BF        .byte "GN(",TK_SGN      ; SGN(
  8232                        LBB_SIN
  8233 00:D42A: 49 4E 28 CA        .byte "IN(",TK_SIN      ; SIN(
  8234                        LBB_SPC
  8235 00:D42E: 50 43 28 AC        .byte "PC(",TK_SPC      ; SPC(
  8236                        LBB_SQR
  8237 00:D432: 51 52 28 C5        .byte "QR(",TK_SQR      ; SQR(
  8238                        LBB_STEP
  8239 00:D436: 54 45 50 AF        .byte "TEP",TK_STEP     ; STEP
  8240                        LBB_STOP
  8241 00:D43A: 54 4F 50 90        .byte "TOP",TK_STOP     ; STOP
  8242                        LBB_STRS
  8243 00:D43E: 54 52 24 28        .byte "TR$(",TK_STRS    ; STR$(
       00:D442: D1 
  8244                        LBB_SWAP
  8245 00:D443: 57 41 50 A4        .byte "WAP",TK_SWAP     ; SWAP
  8246 00:D447: 00                 .byte $00
  8247                        TAB_ASCT
  8248                        LBB_TAB
  8249 00:D448: 41 42 28 A8        .byte "AB(",TK_TAB      ; TAB(
  8250                        LBB_TAN
  8251 00:D44C: 41 4E 28 CB        .byte "AN(",TK_TAN      ; TAN(
  8252                        LBB_THEN
  8253 00:D450: 48 45 4E AD        .byte "HEN",TK_THEN     ; THEN
  8254                        LBB_TO
  8255 00:D454: 4F AA              .byte "O",TK_TO         ; TO
  8256                        LBB_TWOPI
  8257 00:D456: 57 4F 50 49        .byte "WOPI",TK_TWOPI   ; TWOPI
       00:D45A: DD 
  8258 00:D45B: 00                 .byte $00
  8259                        TAB_ASCU
  8260                        LBB_UCASES
  8261 00:D45C: 43 41 53 45        .byte "CASE$(",TK_UCASES
       00:D460: 24 28 D4 
  8262                                                      ; UCASE$(
  8263                        LBB_UNTIL
  8264 00:D463: 4E 54 49 4C        .byte "NTIL",TK_UNTIL   ; UNTIL
       00:D467: B0 
  8265                        LBB_USR
  8266 00:D468: 53 52 28 C2        .byte "SR(",TK_USR      ; USR(
  8267 00:D46C: 00                 .byte $00
  8268                        TAB_ASCV
  8269                        LBB_VAL
  8270 00:D46D: 41 4C 28 D2        .byte "AL(",TK_VAL      ; VAL(
  8271                        LBB_VPTR
  Mon Feb  8 2021  9:20                                                                                                    Page 133


  8272 00:D471: 41 52 50 54        .byte "ARPTR(",TK_VPTR  ; VARPTR(
       00:D475: 52 28 DE 
  8273 00:D478: 00                 .byte $00
  8274                        TAB_ASCW
  8275                        LBB_WAIT
  8276 00:D479: 41 49 54 94        .byte "AIT",TK_WAIT     ; WAIT
  8277                        LBB_WHILE
  8278 00:D47D: 48 49 4C 45        .byte "HILE",TK_WHILE   ; WHILE
       00:D481: B1 
  8279                        LBB_WIDTH
  8280 00:D482: 49 44 54 48        .byte "IDTH",TK_WIDTH   ; WIDTH
       00:D486: A2 
  8281 00:D487: 00                 .byte $00
  8282                        TAB_POWR
  8283 00:D488: B6 00              .byte TK_POWER,$00      ; ^
  8284                        
  8285                        ; new decode table for LIST
  8286                        ; Table is ..
  8287                        ; byte - keyword length, keyword first character
  8288                        ; word - pointer to rest of keyword from dictionary
  8289                        
  8290                        ; note if length is 1 then the pointer is ignored
  8291                        
  8292                        LAB_KEYT
  8293 00:D48A: 03 45              .byte 3,'E'
  8294 00:D48C: 63 D3              .word LBB_END           ; END
  8295 00:D48E: 03 46              .byte 3,'F'
  8296 00:D490: 74 D3              .word LBB_FOR           ; FOR
  8297 00:D492: 04 4E              .byte 4,'N'
  8298 00:D494: D4 D3              .word LBB_NEXT          ; NEXT
  8299 00:D496: 04 44              .byte 4,'D'
  8300 00:D498: 46 D3              .word LBB_DATA          ; DATA
  8301 00:D49A: 05 49              .byte 5,'I'
  8302 00:D49C: 94 D3              .word LBB_INPUT         ; INPUT
  8303 00:D49E: 03 44              .byte 3,'D'
  8304 00:D4A0: 55 D3              .word LBB_DIM           ; DIM
  8305 00:D4A2: 04 52              .byte 4,'R'
  8306 00:D4A4: FA D3              .word LBB_READ          ; READ
  8307 00:D4A6: 03 4C              .byte 3,'L'
  8308 00:D4A8: AF D3              .word LBB_LET           ; LET
  8309 00:D4AA: 03 44              .byte 3,'D'
  8310 00:D4AC: 4A D3              .word LBB_DEC           ; DEC
  8311 00:D4AE: 04 47              .byte 4,'G'
  8312 00:D4B0: 84 D3              .word LBB_GOTO          ; GOTO
  8313 00:D4B2: 03 52              .byte 3,'R'
  8314 00:D4B4: 19 D4              .word LBB_RUN           ; RUN
  8315 00:D4B6: 02 49              .byte 2,'I'
  8316 00:D4B8: 8F D3              .word LBB_IF            ; IF
  8317 00:D4BA: 07 52              .byte 7,'R'
  8318 00:D4BC: 01 D4              .word LBB_RESTORE       ; RESTORE
  8319 00:D4BE: 05 47              .byte 5,'G'
  8320 00:D4C0: 7F D3              .word LBB_GOSUB         ; GOSUB
  8321 00:D4C2: 06 52              .byte 6,'R'
  8322 00:D4C4: 08 D4              .word LBB_RETURN        ; RETURN
  8323 00:D4C6: 03 52              .byte 3,'R'
  8324 00:D4C8: FE D3              .word LBB_REM           ; REM
  8325 00:D4CA: 04 53              .byte 4,'S'
  8326 00:D4CC: 3A D4              .word LBB_STOP          ; STOP
  8327 00:D4CE: 02 4F              .byte 2,'O'
  8328 00:D4D0: E0 D3              .word LBB_ON            ; ON
  8329 00:D4D2: 04 4E              .byte 4,'N'
  8330 00:D4D4: DB D3              .word LBB_NULL          ; NULL
  8331 00:D4D6: 03 49              .byte 3,'I'
  Mon Feb  8 2021  9:20                                                                                                    Page 134


  8332 00:D4D8: 91 D3              .word LBB_INC           ; INC
  8333 00:D4DA: 04 57              .byte 4,'W'
  8334 00:D4DC: 79 D4              .word LBB_WAIT          ; WAIT
  8335 00:D4DE: 04 4C              .byte 4,'L'
  8336 00:D4E0: B6 D3              .word LBB_LOAD          ; LOAD
  8337 00:D4E2: 04 53              .byte 4,'S'
  8338 00:D4E4: 22 D4              .word LBB_SAVE          ; SAVE
  8339 00:D4E6: 03 44              .byte 3,'D'
  8340 00:D4E8: 52 D3              .word LBB_DEF           ; DEF
  8341 00:D4EA: 04 50              .byte 4,'P'
  8342 00:D4EC: EC D3              .word LBB_POKE          ; POKE
  8343 00:D4EE: 04 44              .byte 4,'D'
  8344 00:D4F0: 58 D3              .word LBB_DOKE          ; DOKE
  8345 00:D4F2: 04 43              .byte 4,'C'
  8346 00:D4F4: 2F D3              .word LBB_CALL          ; CALL
  8347 00:D4F6: 02 44              .byte 2,'D'
  8348 00:D4F8: 5C D3              .word LBB_DO            ; DO
  8349 00:D4FA: 04 4C              .byte 4,'L'
  8350 00:D4FC: BE D3              .word LBB_LOOP          ; LOOP
  8351 00:D4FE: 05 50              .byte 5,'P'
  8352 00:D500: F4 D3              .word LBB_PRINT         ; PRINT
  8353 00:D502: 04 43              .byte 4,'C'
  8354 00:D504: 3D D3              .word LBB_CONT          ; CONT
  8355 00:D506: 04 4C              .byte 4,'L'
  8356 00:D508: B2 D3              .word LBB_LIST          ; LIST
  8357 00:D50A: 05 43              .byte 5,'C'
  8358 00:D50C: 38 D3              .word LBB_CLEAR         ; CLEAR
  8359 00:D50E: 03 4E              .byte 3,'N'
  8360 00:D510: D1 D3              .word LBB_NEW           ; NEW
  8361 00:D512: 05 57              .byte 5,'W'
  8362 00:D514: 82 D4              .word LBB_WIDTH         ; WIDTH
  8363 00:D516: 03 47              .byte 3,'G'
  8364 00:D518: 7C D3              .word LBB_GET           ; GET
  8365 00:D51A: 04 53              .byte 4,'S'
  8366 00:D51C: 43 D4              .word LBB_SWAP          ; SWAP
  8367 00:D51E: 06 42              .byte 6,'B'
  8368 00:D520: 21 D3              .word LBB_BITSET        ; BITSET
  8369 00:D522: 06 42              .byte 6,'B'
  8370 00:D524: 1B D3              .word LBB_BITCLR        ; BITCLR
  8371 00:D526: 04 45              .byte 4,"E"
  8372 00:D528: 6D D3              .word LBB_EXIT          ; EXIT
  8373                        
  8374                        ; secondary commands (can't start a statement)
  8375                        
  8376 00:D52A: 04 54              .byte 4,'T'
  8377 00:D52C: 48 D4              .word LBB_TAB           ; TAB
  8378 00:D52E: 04 45              .byte 4,'E'
  8379 00:D530: 5F D3              .word LBB_ELSE          ; ELSE
  8380 00:D532: 02 54              .byte 2,'T'
  8381 00:D534: 54 D4              .word LBB_TO            ; TO
  8382 00:D536: 02 46              .byte 2,'F'
  8383 00:D538: 72 D3              .word LBB_FN            ; FN
  8384 00:D53A: 04 53              .byte 4,'S'
  8385 00:D53C: 2E D4              .word LBB_SPC           ; SPC
  8386 00:D53E: 04 54              .byte 4,'T'
  8387 00:D540: 50 D4              .word LBB_THEN          ; THEN
  8388 00:D542: 03 4E              .byte 3,'N'
  8389 00:D544: D8 D3              .word LBB_NOT           ; NOT
  8390 00:D546: 04 53              .byte 4,'S'
  8391 00:D548: 36 D4              .word LBB_STEP          ; STEP
  8392 00:D54A: 05 55              .byte 5,'U'
  8393 00:D54C: 63 D4              .word LBB_UNTIL         ; UNTIL
  8394 00:D54E: 05 57              .byte 5,'W'
  Mon Feb  8 2021  9:20                                                                                                    Page 135


  8395 00:D550: 7D D4              .word LBB_WHILE         ; WHILE
  8396                        
  8397                        ; opperators
  8398                        
  8399 00:D552: 01 2B              .byte 1,'+'
  8400 00:D554: 00 00              .word $0000             ; +
  8401 00:D556: 01 2D              .byte 1,'-'
  8402 00:D558: 00 00              .word $0000             ; -
  8403 00:D55A: 01 2A              .byte 1,'*'
  8404 00:D55C: 00 00              .word $0000             ; *
  8405 00:D55E: 01 2F              .byte 1,'/'
  8406 00:D560: 00 00              .word $0000             ; /
  8407 00:D562: 01 5E              .byte 1,'^'
  8408 00:D564: 00 00              .word $0000             ; ^
  8409 00:D566: 03 41              .byte 3,'A'
  8410 00:D568: 0A D3              .word LBB_AND           ; AND
  8411 00:D56A: 03 45              .byte 3,'E'
  8412 00:D56C: 66 D3              .word LBB_EOR           ; EOR
  8413 00:D56E: 02 4F              .byte 2,'O'
  8414 00:D570: E2 D3              .word LBB_OR            ; OR
  8415 00:D572: 02 3E              .byte 2,'>'
  8416 00:D574: 00 D3              .word LBB_RSHIFT        ; >>
  8417 00:D576: 02 3C              .byte 2,'<'
  8418 00:D578: FA D2              .word LBB_LSHIFT        ; <<
  8419 00:D57A: 01 3E              .byte 1,'>'
  8420 00:D57C: 00 00              .word $0000             ; >
  8421 00:D57E: 01 3D              .byte 1,'='
  8422 00:D580: 00 00              .word $0000             ; =
  8423 00:D582: 01 3C              .byte 1,'<'
  8424 00:D584: 00 00              .word $0000             ; <
  8425                        
  8426                        ; functions
  8427                        
  8428 00:D586: 04 53              .byte 4,'S'             ;
  8429 00:D588: 26 D4              .word LBB_SGN           ; SGN
  8430 00:D58A: 04 49              .byte 4,'I'             ;
  8431 00:D58C: 99 D3              .word LBB_INT           ; INT
  8432 00:D58E: 04 41              .byte 4,'A'             ;
  8433 00:D590: 06 D3              .word LBB_ABS           ; ABS
  8434 00:D592: 04 55              .byte 4,'U'             ;
  8435 00:D594: 68 D4              .word LBB_USR           ; USR
  8436 00:D596: 04 46              .byte 4,'F'             ;
  8437 00:D598: 77 D3              .word LBB_FRE           ; FRE
  8438 00:D59A: 04 50              .byte 4,'P'             ;
  8439 00:D59C: F0 D3              .word LBB_POS           ; POS
  8440 00:D59E: 04 53              .byte 4,'S'             ;
  8441 00:D5A0: 32 D4              .word LBB_SQR           ; SQR
  8442 00:D5A2: 04 52              .byte 4,'R'             ;
  8443 00:D5A4: 15 D4              .word LBB_RND           ; RND
  8444 00:D5A6: 04 4C              .byte 4,'L'             ;
  8445 00:D5A8: BA D3              .word LBB_LOG           ; LOG
  8446 00:D5AA: 04 45              .byte 4,'E'             ;
  8447 00:D5AC: 69 D3              .word LBB_EXP           ; EXP
  8448 00:D5AE: 04 43              .byte 4,'C'             ;
  8449 00:D5B0: 41 D3              .word LBB_COS           ; COS
  8450 00:D5B2: 04 53              .byte 4,'S'             ;
  8451 00:D5B4: 2A D4              .word LBB_SIN           ; SIN
  8452 00:D5B6: 04 54              .byte 4,'T'             ;
  8453 00:D5B8: 4C D4              .word LBB_TAN           ; TAN
  8454 00:D5BA: 04 41              .byte 4,'A'             ;
  8455 00:D5BC: 11 D3              .word LBB_ATN           ; ATN
  8456 00:D5BE: 05 50              .byte 5,'P'             ;
  8457 00:D5C0: E5 D3              .word LBB_PEEK          ; PEEK
  Mon Feb  8 2021  9:20                                                                                                    Page 136


  8458 00:D5C2: 05 44              .byte 5,'D'             ;
  8459 00:D5C4: 4D D3              .word LBB_DEEK          ; DEEK
  8460 00:D5C6: 05 53              .byte 5,'S'             ;
  8461 00:D5C8: 1D D4              .word LBB_SADD          ; SADD
  8462 00:D5CA: 04 4C              .byte 4,'L'             ;
  8463 00:D5CC: AB D3              .word LBB_LEN           ; LEN
  8464 00:D5CE: 05 53              .byte 5,'S'             ;
  8465 00:D5D0: 3E D4              .word LBB_STRS          ; STR$
  8466 00:D5D2: 04 56              .byte 4,'V'             ;
  8467 00:D5D4: 6D D4              .word LBB_VAL           ; VAL
  8468 00:D5D6: 04 41              .byte 4,'A'             ;
  8469 00:D5D8: 0D D3              .word LBB_ASC           ; ASC
  8470 00:D5DA: 07 55              .byte 7,'U'             ;
  8471 00:D5DC: 5C D4              .word LBB_UCASES        ; UCASE$
  8472 00:D5DE: 07 4C              .byte 7,'L'             ;
  8473 00:D5E0: 9E D3              .word LBB_LCASES        ; LCASE$
  8474 00:D5E2: 05 43              .byte 5,'C'             ;
  8475 00:D5E4: 33 D3              .word LBB_CHRS          ; CHR$
  8476 00:D5E6: 05 48              .byte 5,'H'             ;
  8477 00:D5E8: 89 D3              .word LBB_HEXS          ; HEX$
  8478 00:D5EA: 05 42              .byte 5,'B'             ;
  8479 00:D5EC: 16 D3              .word LBB_BINS          ; BIN$
  8480 00:D5EE: 07 42              .byte 7,'B'             ;
  8481 00:D5F0: 27 D3              .word LBB_BITTST        ; BITTST
  8482 00:D5F2: 04 4D              .byte 4,'M'             ;
  8483 00:D5F4: C3 D3              .word LBB_MAX           ; MAX
  8484 00:D5F6: 04 4D              .byte 4,'M'             ;
  8485 00:D5F8: CC D3              .word LBB_MIN           ; MIN
  8486 00:D5FA: 02 50              .byte 2,'P'             ;
  8487 00:D5FC: EA D3              .word LBB_PI            ; PI
  8488 00:D5FE: 05 54              .byte 5,'T'             ;
  8489 00:D600: 56 D4              .word LBB_TWOPI         ; TWOPI
  8490 00:D602: 07 56              .byte 7,'V'             ;
  8491 00:D604: 71 D4              .word LBB_VPTR          ; VARPTR
  8492 00:D606: 06 4C              .byte 6,'L'             ;
  8493 00:D608: A5 D3              .word LBB_LEFTS         ; LEFT$
  8494 00:D60A: 07 52              .byte 7,'R'             ;
  8495 00:D60C: 0E D4              .word LBB_RIGHTS        ; RIGHT$
  8496 00:D60E: 05 4D              .byte 5,'M'             ;
  8497 00:D610: C7 D3              .word LBB_MIDS          ; MID$
  8498                        
  8499                        ; BASIC messages, mostly error messages
  8500                        
  8501                        LAB_BAER
  8502 00:D612: 36 D6              .word ERR_NF            ;$00 NEXT without FOR
  8503 00:D614: 47 D6              .word ERR_SN            ;$02 syntax
  8504 00:D616: 4E D6              .word ERR_RG            ;$04 RETURN without GOSUB
  8505 00:D618: 63 D6              .word ERR_OD            ;$06 out of data
  8506 00:D61A: 6F D6              .word ERR_FC            ;$08 function call
  8507 00:D61C: 7D D6              .word ERR_OV            ;$0A overflow
  8508 00:D61E: 86 D6              .word ERR_OM            ;$0C out of memory
  8509 00:D620: 94 D6              .word ERR_US            ;$0E undefined statement
  8510 00:D622: A8 D6              .word ERR_BS            ;$10 array bounds
  8511 00:D624: B5 D6              .word ERR_DD            ;$12 double dimension array
  8512 00:D626: C6 D6              .word ERR_D0            ;$14 divide by 0
  8513 00:D628: D5 D6              .word ERR_ID            ;$16 illegal direct
  8514 00:D62A: E4 D6              .word ERR_TM            ;$18 type mismatch
  8515 00:D62C: F2 D6              .word ERR_LS            ;$1A long string
  8516 00:D62E: 02 D7              .word ERR_ST            ;$1C string too complex
  8517 00:D630: 15 D7              .word ERR_CN            ;$1E continue error
  8518 00:D632: 24 D7              .word ERR_UF            ;$20 undefined function
  8519 00:D634: 37 D7              .word ERR_LD            ;$22 LOOP without DO
  8520                        
  Mon Feb  8 2021  9:20                                                                                                    Page 137


  8521                        ; I may implement these two errors to force definition of variables and
  8522                        ; dimensioning of arrays before use.
  8523                        
  8524                        ;     .word ERR_UV            ;$24 undefined variable
  8525                        
  8526                        ; the above error has been tested and works (see code and comments below LAB_1D8B)
  8527                        
  8528                        ;     .word ERR_UA            ;$26 undimensioned array
  8529                        
  8530 00:D636: 4E 45 58 54  ERR_NF      .byte "NEXT without FOR",$00
       00:D63A: 20 77 69 74 
       00:D63E: 68 6F 75 74 
       00:D642: 20 46 4F 52 
       00:D646: 00 
  8531 00:D647: 53 79 6E 74  ERR_SN      .byte "Syntax",$00
       00:D64B: 61 78 00 
  8532 00:D64E: 52 45 54 55  ERR_RG      .byte "RETURN without GOSUB",$00
       00:D652: 52 4E 20 77 
       00:D656: 69 74 68 6F 
       00:D65A: 75 74 20 47 
       00:D65E: 4F 53 55 42 
       00:D662: 00 
  8533 00:D663: 4F 75 74 20  ERR_OD      .byte "Out of DATA",$00
       00:D667: 6F 66 20 44 
       00:D66B: 41 54 41 00 
  8534 00:D66F: 46 75 6E 63  ERR_FC      .byte "Function call",$00
       00:D673: 74 69 6F 6E 
       00:D677: 20 63 61 6C 
       00:D67B: 6C 00 
  8535 00:D67D: 4F 76 65 72  ERR_OV      .byte "Overflow",$00
       00:D681: 66 6C 6F 77 
       00:D685: 00 
  8536 00:D686: 4F 75 74 20  ERR_OM      .byte "Out of memory",$00
       00:D68A: 6F 66 20 6D 
       00:D68E: 65 6D 6F 72 
       00:D692: 79 00 
  8537 00:D694: 55 6E 64 65  ERR_US      .byte "Undefined statement",$00
       00:D698: 66 69 6E 65 
       00:D69C: 64 20 73 74 
       00:D6A0: 61 74 65 6D 
       00:D6A4: 65 6E 74 00 
  8538 00:D6A8: 41 72 72 61  ERR_BS      .byte "Array bounds",$00
       00:D6AC: 79 20 62 6F 
       00:D6B0: 75 6E 64 73 
       00:D6B4: 00 
  8539 00:D6B5: 44 6F 75 62  ERR_DD      .byte "Double dimension",$00
       00:D6B9: 6C 65 20 64 
       00:D6BD: 69 6D 65 6E 
       00:D6C1: 73 69 6F 6E 
       00:D6C5: 00 
  8540 00:D6C6: 44 69 76 69  ERR_D0      .byte "Divide by zero",$00
       00:D6CA: 64 65 20 62 
       00:D6CE: 79 20 7A 65 
       00:D6D2: 72 6F 00 
  8541 00:D6D5: 49 6C 6C 65  ERR_ID      .byte "Illegal direct",$00
       00:D6D9: 67 61 6C 20 
       00:D6DD: 64 69 72 65 
       00:D6E1: 63 74 00 
  8542 00:D6E4: 54 79 70 65  ERR_TM      .byte "Type mismatch",$00
       00:D6E8: 20 6D 69 73 
       00:D6EC: 6D 61 74 63 
       00:D6F0: 68 00 
  8543 00:D6F2: 53 74 72 69  ERR_LS      .byte "String too long",$00
  Mon Feb  8 2021  9:20                                                                                                    Page 138


       00:D6F6: 6E 67 20 74 
       00:D6FA: 6F 6F 20 6C 
       00:D6FE: 6F 6E 67 00 
  8544 00:D702: 53 74 72 69  ERR_ST      .byte "String too complex",$00
       00:D706: 6E 67 20 74 
       00:D70A: 6F 6F 20 63 
       00:D70E: 6F 6D 70 6C 
       00:D712: 65 78 00 
  8545 00:D715: 43 61 6E 27  ERR_CN      .byte "Can't continue",$00
       00:D719: 74 20 63 6F 
       00:D71D: 6E 74 69 6E 
       00:D721: 75 65 00 
  8546 00:D724: 55 6E 64 65  ERR_UF      .byte "Undefined function",$00
       00:D728: 66 69 6E 65 
       00:D72C: 64 20 66 75 
       00:D730: 6E 63 74 69 
       00:D734: 6F 6E 00 
  8547 00:D737: 4C 4F 4F 50  ERR_LD      .byte "LOOP without DO",$00
       00:D73B: 20 77 69 74 
       00:D73F: 68 6F 75 74 
       00:D743: 20 44 4F 00 
  8548                        
  8549                        ;ERR_UV     .byte "Undefined variable",$00
  8550                        
  8551                        ; the above error has been tested and works (see code and comments below LAB_1D8B)
  8552                        
  8553                        ;ERR_UA     .byte "Undimensioned array",$00
  8554                        
  8555 00:D747: 0D 0A 42 72  LAB_BMSG    .byte $0D,$0A,"Break",$00
       00:D74B: 65 61 6B 00 
  8556 00:D74F: 20 45 72 72  LAB_EMSG    .byte " Error",$00
       00:D753: 6F 72 00 
  8557 00:D756: 20 69 6E 20  LAB_LMSG    .byte " in line ",$00
       00:D75A: 6C 69 6E 65 
       00:D75E: 20 00 
  8558 00:D760: 0D 0A 52 65  LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
       00:D764: 61 64 79 0D 
       00:D768: 0A 00 
  8559                        
  8560 00:D76A: 20 45 78 74  LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
       00:D76E: 72 61 20 69 
       00:D772: 67 6E 6F 72 
       00:D776: 65 64 0D 0A 
       00:D77A: 00 
  8561 00:D77B: 20 52 65 64  LAB_REDO    .byte " Redo from start",$0D,$0A,$00
       00:D77F: 6F 20 66 72 
       00:D783: 6F 6D 20 73 
       00:D787: 74 61 72 74 
       00:D78B: 0D 0A 00 
  8562                        
  8563                         .END


      Lines assembled: 8563
      Errors: 0
